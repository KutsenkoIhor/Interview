# Middle PHP

## Оглавление
1. [Как передаются переменные (по значению или по ссылке)?](#1-как-передаются-переменные-по-значению-или-по-ссылке)
2. [Какие процессы происходят, когда пользователь вводит URL в браузере?](#2-какие-процессы-происходят-когда-пользователь-вводит-url-в-браузере)
3. [Что такое вариативная функция или splat-оператор?](#3-что-такое-вариативная-функция-или-splat-оператор)
4. [Что такое OWASP?](#4-что-такое-owasp)
5. [Какие типы уязвимостей вы знаете и как от них защищаться?](#5-какие-типы-уязвимостей-вы-знаете-и-как-от-них-защищаться)
6. [Что такое идемпотентные методы? Какие HTTP-методы являются идемпотентными в REST?](#6-что-такое-идемпотентные-методы-какие-http-методы-являются-идемпотентными-в-rest)
7. [Что такое stateless?](#7-что-такое-stateless)
8. [SOAP vs REST — в чем разница?](#8-soap-vs-rest-в-чем-разница)
9. [Какие методы авторизации используются для построения API?](#9-какие-методы-авторизации-используются-для-построения-api)
10. [Что может содержать интерфейс?](#10-что-может-содержать-интерфейс)
11. [Клонирование объектов и вложенные объекты (shallow / deep clone).](#11-клонирование-объектов-и-вложенные-объекты-shallow-deep-clone)
12. [Что такое Mock? Где используется и зачем?](#12-что-такое-mock-где-используется-и-зачем)
13. [Что такое PSR?](#13-что-такое-psr)
14. [Опишите реализацию одного из паттернов проектирования.](#14-опишите-реализацию-одного-из-паттернов-проектирования)
15. [Что такое Redis?](#15-что-такое-redis)
16. [Как хранятся данные в Redis и Memcached?](#16-как-хранятся-данные-в-redis-и-memcached)
17. [Redis и Memcached для кеширования: плюсы и минусы.](#17-redis-и-memcached-для-кеширования-плюсы-и-минусы)
18. [Отличия между nginx и Apache.](#18-отличия-между-nginx-и-apache)
19. [Что такое OPcache и как он работает?](#19-что-такое-opcache-и-как-он-работает)
20. [Что такое JIT и как он работает?](#20-что-такое-jit-и-как-он-работает)
21. [Зачем нужно ключевое слово final?](#21-зачем-нужно-ключевое-слово-final)
22. [Что нового в PHP 7 и PHP 8?](#22-что-нового-в-php-7-и-php-8)
23. [SOLID, DRY, KISS, YAGNI.](#23-solid-dry-kiss-yagni)
24. [Паттерны проектирования, с которыми приходилось работать.](#24-паттерны-проектирования-с-которыми-приходилось-работать)
25. [Что такое простая фабрика?](#25-что-такое-простая-фабрика)
26. [Что такое Service Layer и где его стоит применять?](#26-что-такое-service-layer-и-где-его-стоит-применять)
27. [Singleton: как устроен и почему является антипаттерном.](#27-singleton-как-устроен-и-почему-является-антипаттерном)
28. [Что такое идемпотентность?](#28-что-такое-идемпотентность)
29. [Жизненный цикл HTTP-запроса.](#29-жизненный-цикл-http-запроса)
30. [Что такое куча и стек?](#30-что-такое-куча-и-стек)
31. [Что такое рефлексия?](#31-что-такое-рефлексия)
32. [Что такое хеш-функция и где она используется?](#32-что-такое-хеш-функция-и-где-она-используется)
33. [Как используются очереди в PHP?](#33-как-используются-очереди-в-php)
34. [Как в общих чертах работает OPcache?](#34-как-в-общих-чертах-работает-opcache)
35. [Что такое GRASP?](#35-что-такое-grasp)
36. [Что такое TDD?](#36-что-такое-tdd)
37. [Чем отличаются модульные тесты от интеграционных?](#37-чем-отличаются-модульные-тесты-от-интеграционных)
38. [Что такое трейты и как применять их на практике?](#38-что-такое-трейты-и-как-применять-их-на-практике)
39. [Как решать конфликты при использовании trait?](#39-как-решать-конфликты-при-использовании-trait)
40. [Как работает автозагрузка классов?](#40-как-работает-автозагрузка-классов)
41. [Разница между стеком и очередью.](#41-разница-между-стеком-и-очередью)
42. [Unit и Functional тесты. Моки и стабы в PHP.](#42-unit-и-functional-тесты-моки-и-стабы-в-php)
43. [Как вызвать приватный метод (гипотетическая ситуация)?](#43-как-вызвать-приватный-метод-гипотетическая-ситуация)
44. [Разница между PHP-FPM и «PHP на сокете».](#44-разница-между-php-fpm-и-php-на-сокете)
45. [Как реализовать загрузку больших отчетов (1GB и более)?](#45-как-реализовать-загрузку-больших-отчетов-1gb-и-более)
46. [Как импортировать 50GB XML в базу данных?](#46-как-импортировать-50gb-xml-в-базу-данных)
47. [Почему после PHP 5 сразу вышел PHP 7, куда делся PHP 6?](#47-почему-после-php-5-сразу-вышел-php-7-куда-делся-php-6)
48. [Есть ли разница между self и $this в PHP?](#48-есть-ли-разница-между-self-и-this-в-php)
49. [Что такое PuTTY?](#49-что-такое-putty)
50. [Как запускать важный PHP-файл каждые 20 секунд?](#50-как-запускать-важный-php-файл-каждые-20-секунд)
51. [Как расшифровать права 644 для файла в Linux?](#51-как-расшифровать-права-644-для-файла-в-linux)
52. [Что такое Opcode?](#52-что-такое-opcode)

---
### 1. Как передаются переменные (по значению или по ссылке)?

<details>
<summary>Раскрыть:</summary>

В PHP аргументы функций **по умолчанию передаются по значению**.  
Это означает, что функция получает **копию значения**, а не саму переменную.

```php
function foo($a) {
    $a = 10;
}

$b = 5;
foo($b);
echo $b; // 5
```
Передача по ссылке выполняется с помощью оператора &.
```php
function foo(&$a) {
    $a = 10;
}

$b = 5;
foo($b);
echo $b; // 10
```
Важно:
* объекты в PHP передаются по значению ссылки
* & используется редко и требует аккуратности
* лишние ссылки могут усложнять отладку
</details>

---
### 2. Какие процессы происходят, когда пользователь вводит URL в браузере?

<details>
<summary>Раскрыть:</summary>

Основные этапы:

#### 1. Парсинг URL
* протокол, домен, путь, query
#### 2. DNS-запрос
* получение IP-адреса сервера
#### 3. Установка соединения
* TCP (3-way handshake)
* TLS (если HTTPS)
#### 4. HTTP-запрос
* отправка заголовков и тела
#### 5. Обработка на сервере
* web-сервер → PHP-FPM → приложение
#### 6. HTTP-ответ
* статус, заголовки, тело
#### 7. Рендеринг браузером
* HTML → CSS → JS → DOM
</details>

---
### 3. Что такое вариативная функция или splat-оператор?

<details>
<summary>Раскрыть:</summary>

**Вариативная функция** принимает произвольное количество аргументов.
```php
function sum(int ...$numbers): int {
    return array_sum($numbers);
}

sum(1, 2, 3); // 6
```
splat-оператор (...) также используется для распаковки массивов:
```php
$args = [1, 2, 3];
sum(...$args);
```
Используется:
* в прокси-методах
* в middleware
* для гибких API
</details>

---
### 4. Что такое OWASP?

<details>
<summary>Раскрыть:</summary>

**OWASP (Open Worldwide Application Security Project)** — международная организация,
занимающаяся безопасностью веб-приложений.

Самый известный документ — OWASP Top 10, список критических уязвимостей:
* SQL Injection
* XSS
* CSRF
* Broken Authentication
* Security Misconfiguration

Используется как стандарт secure-coding.
</details>

---
### 5. Какие типы уязвимостей вы знаете и как от них защищаться?

<details>
<summary>Раскрыть:</summary>

#### 1. SQL Injection
**Описание:**  
Атака, при которой злоумышленник внедряет SQL-код в пользовательский ввод, чтобы:
- получить доступ к данным,
- изменить данные,
- выполнить админские операции.
 
**Защита:**
- Использовать prepared statements:
  - PDO (prepare, bindParam)
  - Doctrine ORM / DBAL
- Никогда не конкатенировать SQL-строки
- Ограничивать права БД-пользователя

#### 2. XSS (Cross-Site Scripting)
**Описание:**  
Внедрение JavaScript-кода, который выполняется в браузере жертвы.

**Защита:**
- Экранирование вывода (htmlspecialchars, Twig auto-escape)
- Никогда не доверять данным от пользователя
- Content Security Policy (CSP):
  - запрет inline-скриптов
  - whitelist источников
- Использование безопасных шаблонизаторов

✅ Важно: экранируем на выводе, а не на входе

#### 3. CSRF (Cross-Site Request Forgery)
**Описание:**  
Атака, при которой пользователь неосознанно отправляет запрос от своего имени (например, перевод денег).

**Защита:**
- **CSRF-токены** (уникальные, одноразовые)
- Проверка Origin / Referer
- Cookies с флагом SameSite:
  - Lax / Strict
- Использование POST/PUT/DELETE для изменений

✅ Frameworks: Symfony CSRF, Laravel CSRF, Yii CSRF

#### 4. Broken Authentication
**Описание:**  
Ошибки в логике аутентификации:
- слабые пароли,
- утечка токенов,
- отсутствие ограничения попыток входа.

**Защита:**
- Хеширование паролей:
  - bcrypt
  - argon2id
- Ограничение количества login attempts
- JWT:
  - короткий TTL access-токена
  - refresh-токены
- HTTP-only cookies
- 2FA / MFA

❌ Никогда не хранить пароли в открытом виде
</details>

---
### 6. Что такое идемпотентные методы? Какие HTTP-методы являются идемпотентными в REST?

<details>
<summary>Раскрыть:</summary>

**Идемпотентность** — повторный вызов операции даёт тот же результат.

Идемпотентные HTTP-методы:
- GET
- PUT
- DELETE
- HEAD

Неидемпотентный:
- POST

Пример:
```php
PUT /users/1
```
</details>

---
### 7. Что такое stateless?

<details>
<summary>Раскрыть:</summary>

**Stateless** (без состояния) — это принцип, при котором **сервер не хранит информацию о состоянии клиента между запросами**.  
Каждый запрос обрабатывается **независимо** и содержит **всю необходимую информацию** для его выполнения.

#### Stateless в контексте HTTP

HTTP — это **stateless-протокол** по своей природе.

Это означает:
- сервер **не помнит** предыдущие запросы клиента,
- каждый HTTP-запрос самодостаточен,
- сервер не хранит данные о сессии между запросами.

**Пример:**
```http
GET /api/users/me
Authorization: Bearer <token>
```
</details>

---
### 8. SOAP vs REST. В чем разница?

<details>
<summary>Раскрыть:</summary>

**SOAP** и **REST** — это два разных подхода к построению веб-сервисов и API, которые отличаются философией, протоколами, форматом данных и областью применения.  

SOAP — это **строгий протокол обмена сообщениями**, основанный на XML и формальных контрактах.  
REST — это **архитектурный стиль**, а не протокол, использующий стандартные возможности HTTP.

| Критерий           | SOAP                     | REST                          |
|--------------------|--------------------------|-------------------------------|
| **Тип**            | Протокол                 | Архитектурный стиль           |
| **Формат данных**  | XML                      | JSON / XML                    |
| **Контракт**       | WSDL                     | OpenAPI (опционально)         |
| **Stateful**       | Может быть               | Stateless                     |
| **Производительность** | Ниже               | Выше                          |
| **Простота**       | Сложный                  | Простой                       |
| **Кеширование**    | Нет                      | Есть (HTTP Cache)             |
| **Безопасность**   | WS-Security              | HTTPS, OAuth, JWT             |

**Когда использовать SOAP**
- Корпоративные системы
- Банковские и финансовые интеграции
- Нужны транзакции и гарантированная доставка
- Требуется строгий контракт

**Когда использовать REST**
- Web / Mobile / SPA
- Микросервисы
- Высокая нагрузка
- Простота и скорость важнее формальностей

**Короткий ответ для собеседования**

**SOAP** — это строгий XML-протокол с контрактом WSDL, поддержкой транзакций и расширенной безопасности.  
**REST** — это архитектурный стиль, основанный на HTTP, stateless и чаще использующий JSON.  
**REST** проще, быстрее и лучше подходит для современных веб-приложений, SOAP — для enterprise-систем.
</details>

---
### 9. Какие методы авторизации используются для построения API?

<details>
<summary>Раскрыть:</summary>

Для API используются:
 - **Basic Auth** - Простейший механизм, при котором логин и пароль передаются в заголовке `Authorization`, закодированные в Base64.
 - **API Key** - Клиенту выдаётся уникальный ключ, который передаётся в каждом запросе.
 - **OAuth 2.0** - Стандарт авторизации, позволяющий безопасно делегировать доступ к ресурсам без передачи пароля.
 - **JWT** - Самодостаточный токен, содержащий информацию о пользователе и правах доступа, подписанный криптографически.
 - **Session + Cookie** - Классический подход, сервер хранит сессию, клиент передаёт session ID в cookie.

| Метод              | Stateless | Масштабируемость | Безопасность | Использование          |
|--------------------|-----------|------------------|--------------|------------------------|
| **Basic Auth**     | ❌        | ❌               | ❌           | Тесты                  |
| **API Key**        | ✅        | ✅               | ⚠️           | Service-to-service     |
| **OAuth 2.0**      | ✅        | ✅               | ✅           | Enterprise             |
| **JWT**            | ✅        | ✅               | ⚠️           | API, микросервисы      |
| **Session + Cookie** | ❌      | ❌               | ✅           | Web                    |

В микросервисах чаще всего применяют OAuth 2.0 для выдачи токенов и JWT как stateless-механизм авторизации.
</details>

---
### 10. Что может содержать интерфейс?

<details>
<summary>Раскрыть:</summary>

Интерфейс может содержать:
- объявления методов (все методы public, можно объявлять extends от других интерфейсов)
- константы (всегда public, нельзя переопределять значение константы в классе)

Не может содержать:
- реализацию методов
- свойства

| Критерий                   | Интерфейс | Абстрактный класс |
|----------------------------|-----------|-------------------|
| **Методы с реализацией**   | ❌        | ✅                |
| **Свойства**               | ❌        | ✅                |
| **Константы**              | ✅        | ✅                |
| **Множественное наследование** | ✅    | ❌                |
| **Конструктор**            | ❌        | ✅                |
</details>

---
### 11. Клонирование объектов и вложенные объекты shallow deep clone.

<details>
<summary>Раскрыть:</summary>

В PHP оператор `clone` создаёт **копию объекта**, но важно понимать, что это копирование **по умолчанию поверхностное (shallow)**:  
сам объект копируется, а **вложенные объекты внутри свойств** продолжают ссылаться на те же экземпляры, пока вы не выполните “глубокое” копирование вручную.

#### 1. Shallow clone (поверхностное клонирование)
* Создаётся новый объект (новый идентификатор).
* **Скалярные** свойства копируются как значения.
* **Объекты внутри свойств** остаются теми же (копируются ссылки на них).

Пример:
```php
final class Address {
    public function __construct(public string $city) {}
}

final class UserProfile {
    public function __construct(
        public string $name,
        public Address $address
    ) {}
}

$u1 = new UserProfile('Ihor', new Address('Warsaw'));
$u2 = clone $u1;

$u2->name = 'Max';
$u2->address->city = 'Krakow';

echo $u1->name;            // Ihor (скаляр отдельно)
echo $u1->address->city;   // Krakow (вложенный объект общий!)
```

#### 2. Deep clone (глубокое клонирование)
Чтобы клон был “независимым”, нужно вручную клонировать вложенные объекты — обычно через `__clone()`.

```php
final class UserProfile {
    public function __construct(
        public string $name,
        public Address $address
    ) {}

    public function __clone(): void
    {
        $this->address = clone $this->address; // deep для вложенного объекта
    }
}
```

#### 3. Что происходит при `clone`
* Вызывается “внутренний” механизм копирования объекта.
* Затем, если определён метод `__clone()`, он вызывается **на новом объекте**.

#### 4. Частые нюансы на практике
* **ORM (Doctrine)**: клонирование Entity может быть опасным (id, UnitOfWork, коллекции). Обычно делают отдельные DTO/Factory для “копирования”.
* **Коллекции/массивы с объектами**: массив копируется, но элементы-объекты остаются общими → нужен deep clone для каждого элемента.
* `DateTimeImmutable` безопаснее для “шеринга”, чем `DateTime`, потому что он неизменяемый.

#### 5. Когда использовать
* Прототипирование объектов (паттерн Prototype).
* Подготовка “черновика” данных перед изменениями.
* Копирование конфигураций/настроек (при условии корректного deep clone).
</details>

---
### 12. Что такое Mock? Где используется и зачем?

<details>
<summary>Раскрыть:</summary>

**Mock (мок)** — это тестовый двойник (test double), который:
* имитирует зависимость (например, репозиторий, HTTP-клиент),
* позволяет **задавать ожидания**: какие методы должны быть вызваны, сколько раз и с какими аргументами.

#### 1. Зачем нужен Mock
* Изолировать unit-тест от внешних зависимостей: БД, сеть, очередь, время.
* Проверить **поведение** (behavior): “вызвали ли мы нужный метод?”
* Сделать тесты быстрыми, стабильными и предсказуемыми.

#### 2. Mock vs Stub (важное отличие)
* **Stub** — возвращает заранее подготовленные данные, без проверки “как его вызывали”.
* **Mock** — кроме возврата данных, ещё и **проверяет взаимодействие** (expectations).

#### 3. Пример в PHPUnit (простая идея)
```php
$repo = $this->createMock(UserRepository::class);

$repo->expects($this->once())
    ->method('save')
    ->with($this->isInstanceOf(User::class));

$service = new UserService($repo);
$service->register('test@example.com');
```

#### 4. Где обычно используют
* Unit-тесты сервисов (Service Layer, UseCase/Handler).
* Тестирование контроллеров (реже — если это не интеграционный тест).
* Тестирование кода, который дергает внешние API (HTTP client) или очередь.

#### 5. Типичные ошибки
* Слишком много моков → тест становится “тестом реализации”, ломается при рефакторинге.
* Мокать “свою” бизнес-логику вместо границ системы — обычно мокают **инфраструктуру** (репозитории, клиенты, логгеры).
* Не различать unit и интеграционные тесты.
</details>

---
### 13. Что такое PSR?

<details>
<summary>Раскрыть:</summary>

**PSR (PHP Standards Recommendations)** — набор рекомендаций/стандартов, публикуемых группой **PHP-FIG**, чтобы разные библиотеки и фреймворки были совместимы по интерфейсам и стилю.

#### 1. Зачем это нужно
* Унификация кода в проектах и командах.
* Совместимость компонентов (например, любой PSR-3 Logger можно подменить другим).
* Упрощение интеграции пакетов из Composer-экосистемы.

#### 2. Наиболее важные PSR (то, что часто спрашивают)
* **PSR-4** — автозагрузка классов (namespace → путь).
* **PSR-3** — интерфейс логгера (`LoggerInterface`).
* **PSR-7** — HTTP сообщения (Request/Response/Stream).
* **PSR-11** — контейнер зависимостей (`ContainerInterface`).
* **PSR-15** — HTTP middleware (request handler + middleware).
* **PSR-18** — HTTP client.
* **PSR-6 / PSR-16** — кеширование (pool/simple-cache).
* **PSR-12** — код-стайл (расширение PSR-2).

#### 3. Пример: PSR-3 Logger
```php
use Psr\Log\LoggerInterface;

final class PaymentService {
    public function __construct(private LoggerInterface $logger) {}

    public function pay(): void {
        $this->logger->info('Payment started');
    }
}
```
Тут важно: сервису всё равно, какой именно логгер внутри (Monolog, кастомный и т.д.) — главное, что он PSR-3.

#### 4. Как это проявляется в Symfony
* Многие компоненты Symfony “наружу” дают PSR-интерфейсы (логгер, кеш, контейнер, HTTP).
* Это облегчает замену реализации без переписывания кода.
</details>

---
### 14. Опишите реализацию одного из паттернов проектирования.

<details>
<summary>Раскрыть:</summary>

Опишем **Strategy (Стратегия)** — паттерн, который позволяет **заменять алгоритм поведения** во время выполнения через общий интерфейс.

#### 1. Идея паттерна
* Есть “контекст”, которому нужно выполнить действие (например, рассчитать комиссию).
* Алгоритмы разные (для разных провайдеров/стран/режимов).
* Мы выносим алгоритмы в отдельные классы-стратегии.

#### 2. Пример (PHP)
```php
interface FeeStrategyInterface {
    public function calculate(int $amount): int;
}

final class FixedFeeStrategy implements FeeStrategyInterface {
    public function __construct(private int $fee) {}
    public function calculate(int $amount): int { return $amount + $this->fee; }
}

final class PercentFeeStrategy implements FeeStrategyInterface {
    public function __construct(private int $percent) {}
    public function calculate(int $amount): int {
        return $amount + (int) round($amount * $this->percent / 100);
    }
}

final class PaymentCalculator {
    public function __construct(private FeeStrategyInterface $strategy) {}

    public function total(int $amount): int {
        return $this->strategy->calculate($amount);
    }
}
```

#### 3. Что даёт Strategy
* Убирает большие `if/else` или `switch` по типам.
* Упрощает расширение: добавили новую стратегию — не ломаем старые.
* Легче тестировать: каждая стратегия тестируется отдельно.

#### 4. Где часто используют в реальных проектах
* Тарифы/комиссии, расчёты, валидации по разным правилам.
* Выбор провайдера/интеграции (Stripe/Adyen/PayPal).
* В Symfony удобно через DI + теги/Registry (собираем набор стратегий).
</details>

---
### 15. Что такое Redis?

<details>
<summary>Раскрыть:</summary>

**Redis** — высокопроизводительное in-memory хранилище данных (key-value), которое поддерживает разные структуры данных и часто используется как кеш, брокер событий и быстрое хранилище.

#### 1. Ключевые особенности
* Данные хранятся в памяти → очень быстро.
* Поддерживает структуры:
  * Strings
  * Hashes
  * Lists
  * Sets / Sorted Sets
  * Streams
* Может сохранять данные на диск (persistency):
  * **RDB** (снимки)
  * **AOF** (журнал операций)

#### 2. Типовые кейсы использования
* **Кеширование** (страницы/запросы/DTO/флаги)
* **Сессии** (особенно при масштабировании)
* **Rate limiting** (счётчики запросов)
* **Distributed locks** (защита от параллельных запусков)
* **Очереди / стримы** (Streams, списки)
* **Pub/Sub** (уведомления)

#### 3. Важные концепции для продакшна
* **TTL/expiration** — время жизни ключей.
* **Eviction policy** — что делать при нехватке памяти (LRU/LFU и т.д.).
* **Replication / Sentinel / Cluster** — отказоустойчивость и масштабирование.
* **Проблемы “кеш-штампа”** — когда много запросов одновременно пытаются пересоздать истёкший кеш (решают locks, jitter TTL, soft TTL).

#### 4. Пример: простое кеширование (идея)
```php
// Псевдо-логика: положить значение с TTL
SET user:123 "{...json...}" EX 300
```

#### 5. Redis vs Memcached (коротко)
* Redis богаче по структурам и возможностям (locks, streams, persistence).
* Memcached проще и очень быстрый для простого кеша, но функциональность меньше.
</details>

---
### 16. Как хранятся данные в Redis и Memcached?

<details>
<summary>Раскрыть:</summary>

И Redis, и Memcached — это быстрые in-memory хранилища, но **модель хранения и возможности сильно отличаются**.

#### 1. Memcached: простое key-value хранилище
Memcached хранит данные как:
* **ключ → бинарная строка (blob)**

То есть вы сами решаете, что класть:
* JSON
* сериализованный PHP (`serialize()`)
* простая строка/число

Особенности:
* **только память**, без “родного” persistence (обычно без сохранения на диск)
* нет сложных структур (только value-blob)
* TTL есть (expiration)
* при нехватке памяти удаляет ключи согласно политике (LRU — классический вариант)

Пример (идея):
```
SET user:123 "{...json...}" EX 300
GET user:123
```

#### 2. Redis: key-value + структуры данных
Redis тоже хранит:
* **ключ → значение**, но значение может быть **разных типов**:

* **String** — строка/число/байты
* **Hash** — набор полей (похоже на мини-объект)
* **List** — список (очереди, ленты)
* **Set** — множество уникальных значений
* **Sorted Set** — множество с сортировкой по score
* **Stream** — поток сообщений
* и другие (bitmaps, hyperloglog, geo)

Это даёт возможность делать операции **на стороне Redis**, без скачивания/пересборки всего объекта.

Пример: Hash для пользователя
```
HSET user:123 name "Ihor" city "Warsaw"
HGET user:123 name
```

#### 3. Persistence: главное отличие
Redis умеет сохранять данные на диск:
* **RDB** — снимки (snapshot)
* **AOF** — журнал операций (append-only file)
  Можно включать отдельно или вместе.

Memcached обычно не хранит данные на диск (это чистый кеш).

#### 4. Истечение ключей (TTL)
И там, и там можно задавать TTL:
* ключ живёт N секунд, потом удаляется
* в Redis TTL применяется ко всему ключу (не к отдельным полям hash)

#### 5. Практические последствия
* Memcached чаще всего используют как “тупой” кеш (простые ключи/значения).
* Redis подходит и для кеша, и для более сложных задач (locks, rate-limit, очереди, pub/sub, streams).
</details>

---
### 17. Redis и Memcached для кеширования: плюсы и минусы.

<details>
<summary>Раскрыть:</summary>

Оба решения подходят для кеширования, но выбор зависит от задачи.

#### 1. Redis — плюсы
* **Больше возможностей**: структуры данных, atomic операции.
* **Locks** (distributed locks) — защита от параллельных запусков/кеш-штампа.
* **Rate limiting** (счётчики, sliding window).
* **Pub/Sub, Streams** — события/очереди.
* **Persistence** (RDB/AOF) и репликация → может переживать перезапуски лучше.
* **Lua scripts** — сложные атомарные сценарии на стороне Redis.

#### 2. Redis — минусы
* Сложнее в эксплуатации: настройки памяти, persistence, репликация/cluster.
* При неверной конфигурации persistence может влиять на latency.
* Можно “перегрузить” Redis задачами, которые лучше делать отдельным брокером (RabbitMQ/Kafka), если нет дисциплины.

#### 3. Memcached — плюсы
* **Очень простой**: ключ → значение.
* Часто даёт отличную производительность на “тупом” кеше.
* Меньше “функций” → меньше способов ошибиться.
* Хорош для больших объёмов однотипного кеша.

#### 4. Memcached — минусы
* Нет сложных структур и атомарных сценариев уровня Redis.
* Обычно без persistence (после рестарта кеш пропадает).
* Меньше инструментов для locks/rate-limit/pubsub.

#### 5. Что выбрать на практике
* **Нужен простой кеш страниц/ответов/DTO** → Memcached или Redis (оба ок).
* **Нужны locks / rate-limit / счётчики / очереди / streams** → Redis.
* **Микросервисы + много use-case** → Redis чаще выигрывает универсальностью, но важно не превращать его во “всё сразу”.

#### 6. Типичные ошибки при кешировании (для обоих)
* Нет стратегии инвалидирования (теги, версии ключей).
* Неправильный TTL (слишком большой или слишком маленький).
* Нет защиты от cache stampede (jitter TTL, locks, soft TTL).
* Кешируют “персональные” данные без учёта контекста (locale, permissions, brand, etc.).
</details>

---
### 18. Отличия между nginx и Apache.

<details>
<summary>Раскрыть:</summary>

Оба — веб-серверы, но архитектура и сценарии применения отличаются.

#### 1. Архитектура
**nginx**
* event-driven, асинхронная модель
* хорошо держит много одновременных соединений
* низкое потребление памяти при высокой нагрузке

**Apache**
* исторически process/thread-based (prefork/worker/event MPM)
* более “тяжёлый” в классических конфигурациях, но гибкий

#### 2. Статика и проксирование
nginx очень силён в:
* раздаче статики (css/js/images)
* reverse proxy (проксирование на PHP-FPM, Node, Go)
* балансировке
* TLS termination

Apache тоже умеет, но nginx часто проще и быстрее в роли “фронта”.

#### 3. Конфигурация и .htaccess
Apache:
* поддерживает `.htaccess` (конфиги в директориях)
* удобно для shared-hosting, но это накладно по производительности (нужно проверять .htaccess)

nginx:
* **нет** `.htaccess`
* все правила в одном месте (централизованно) → лучше для продакшна и контроля

#### 4. Модули и экосистема
Apache:
* огромная экосистема модулей
* мощные возможности на уровне директории (auth, rewrite)

nginx:
* тоже модули, но подход другой; часто меньше “магии”, больше явной конфигурации

#### 5. Типичный сетап для PHP
На практике очень распространено:
* **nginx** как фронт (TLS, статика, proxy)
* **PHP-FPM** как обработчик PHP
* Apache в современных PHP-проектах реже используется как основной фронт, но встречается

#### 6. Когда выбирать что
* Высокая нагрузка, много соединений, прокси, микросервисы → nginx.
* Shared-hosting, проекты, завязанные на .htaccess/модули Apache → Apache.
</details>

---
### 19. Что такое OPcache и как он работает?

<details>
<summary>Раскрыть:</summary>

**OPcache** — встроенный в PHP механизм кеширования **скомпилированного байткода (opcode)**.

Идея: PHP — интерпретируемый язык, и без OPcache на каждый запрос происходило бы:
* чтение PHP-файла
* парсинг
* компиляция в opcode
* выполнение

OPcache убирает “компиляцию на каждый запрос”.

#### 1. Что кешируется
* результат компиляции PHP-скриптов → **opcode** в общей памяти (shared memory)
* несколько процессов PHP-FPM могут использовать один кеш

#### 2. Как работает (в общем виде)
1) Первый запрос к файлу:
* PHP компилирует файл в opcode
* кладёт в OPcache

2) Следующие запросы:
* opcode берётся из кеша
* этапы парсинга/компиляции пропускаются

#### 3. Важные настройки (по смыслу)
* размер памяти OPcache
* количество кешируемых файлов
* валидация изменений файлов:
  * в dev — часто включают проверку изменений
  * в prod — часто отключают постоянную проверку и используют деплой с рестартом/инвалидацией

#### 4. Что даёт OPcache
* сильно снижает CPU на парсинг/компиляцию
* ускоряет отклик
* особенно заметно на больших Symfony/Laravel проектах

#### 5. Типовые нюансы
* Если OPcache не проверяет изменения, после деплоя нужен рестарт PHP-FPM/инвалидация.
* При нехватке памяти: “cache full” → падение эффективности (частые вытеснения).
* OPcache — не кеш результата выполнения, а кеш компиляции.
</details>

---
### 20. Что такое JIT и как он работает?

<details>
<summary>Раскрыть:</summary>

**JIT (Just-In-Time compiler)** — механизм, который **во время выполнения** может компилировать часть opcode в **машинный код**, чтобы ускорить выполнение.

В PHP JIT появился в PHP 8 (как часть OPcache).

#### 1. Как это работает концептуально
1) PHP компилирует скрипт в opcode (как обычно).
2) JIT анализирует горячие участки (часто выполняемые).
3) Эти участки могут быть скомпилированы в машинный код.
4) Повторные выполнения идут быстрее.

#### 2. Где JIT реально помогает
Лучше всего — в “CPU-bound” задачах:
* численные вычисления
* обработка больших массивов данных
* алгоритмы, криптография (частично), парсеры, вычисления

В типичных веб-приложениях (Symfony/Laravel), где основное время:
* БД
* сеть
* сериализация
* IO
  — JIT часто даёт **небольшой эффект**.

#### 3. JIT vs OPcache (важно)
* **OPcache** кеширует *opcode* (убирает компиляцию на каждый запрос).
* **JIT** ускоряет *выполнение* opcode, компилируя “горячее” в машинный код.

#### 4. Риски и нюансы
* JIT потребляет память и может усложнить профилирование.
* Не всегда ускоряет веб, иногда эффект близок к нулю.
* В проде включают осознанно, после измерений (benchmarks/profiling).

#### 5. Как “правильно” рассказывать на собесе
* OPcache — must-have почти всегда.
* JIT — опционально, помогает в вычислениях, не магическая кнопка ускорения API.
</details>

---
### 21. Зачем нужно ключевое слово final?

<details>
<summary>Раскрыть:</summary>

`final` в PHP используется, чтобы **запретить наследование** от класса или **переопределение** конкретного метода.

#### 1. `final class` — запрет наследования
```php
final class Money {
    public function __construct(public int $amount) {}
}
```
* Никто не сможет сделать `class MyMoney extends Money {}`.
* Полезно, когда класс — законченная единица, которую нельзя безопасно расширять.

#### 2. `final method` — запрет переопределения метода
```php
class BaseService {
    final public function execute(): void {
        $this->validate();
        $this->handle();
    }

    protected function validate(): void {}
    protected function handle(): void {}
}
```
* `execute()` нельзя переопределить, но можно переопределять “хуки” (`validate`, `handle`).
* Это часто используется в паттерне **Template Method**.

#### 3. Зачем применять `final`
* **Безопасность инвариантов**: запрещаем ломать правила домена через наследование.
* **Ясный API**: класс/метод “не для расширения”.
* **Проще поддерживать**: меньше неожиданных наследников и side effects.
* **Оптимизации**: теоретически рантайм может оптимизировать вызовы, но обычно это не главный мотив.

#### 4. Когда не стоит злоупотреблять
* Если библиотека/фреймворк предполагает расширяемость через наследование.
* Если проект использует наследование как основной механизм расширения (хотя предпочтительнее композиция).

#### 5. Практическая рекомендация
В современных проектах часто:
* доменные value-objects/DTO делают `final`
* сервисы и хендлеры тоже часто `final`
* расширяемость достигается через **интерфейсы + DI** вместо наследования
</details>

---
### 22. Что нового в PHP 7 и PHP 8?

<details>
<summary>Раскрыть:</summary>

#### PHP 8 (8.0+): основные изменения
##### 1. Named arguments
```php
foo(b: 2, a: 1);
```

##### 2. Attributes
```php
#[Route('/api')]
public function index() {}
```

##### 3. Union types
```php
function f(int|string $x): int|string {}
```

##### 4. Match expression
```php
$res = match($type) {
  'a' => 1,
  'b' => 2,
  default => 0,
};
```

##### 5. Nullsafe operator
```php
$name = $user?->profile?->name;
```

##### 6. Constructor property promotion
```php
public function __construct(
  private int $id,
  private string $email
) {}
```

##### 7. JIT (через OPcache)
* может ускорять CPU-bound задачи, но обычно умеренно влияет на веб.

##### 8. Более строгие ошибки
* много warning/notice стали исключениями/фаталами → лучше качество кода, но возможны breaking changes.

---

#### Как правильно отвечать на собесе
* PHP 7: производительность + типизация.
* PHP 8: удобные фичи (attributes/match/union/nullsafe) + строгий рантайм.
* Для веба чаще важнее архитектура, БД/IO и OPcache, чем JIT.
</details>

---
### 23. SOLID, DRY, KISS, YAGNI.

<details>
<summary>Раскрыть:</summary>

Это базовые принципы проектирования кода, которые помогают писать поддерживаемые системы.

#### 1. SOLID

##### S — Single Responsibility Principle
* Класс имеет одну ответственность и одну причину для изменений.

##### O — Open/Closed Principle
* Расширяем функциональность без изменения существующего кода (через интерфейсы/стратегии/декораторы).

##### L — Liskov Substitution Principle
* Наследники должны быть взаимозаменяемы без нарушения контрактов.

##### I — Interface Segregation Principle
* Много маленьких интерфейсов лучше, чем один огромный.

##### D — Dependency Inversion Principle
* Зависим от абстракций, а не от конкретных классов (DI, интерфейсы).

---

#### 2. DRY (Don’t Repeat Yourself)
* Не повторяем бизнес-правила/знания в разных местах.
* Важно не “вынести всё в абстракции”, а удерживать баланс.

---

#### 3. KISS (Keep It Simple)
* Решение должно быть максимально простым, без лишней магии.

---

#### 4. YAGNI (You Aren’t Gonna Need It)
* Не добавляем функциональность “на будущее”, если её нет в требованиях сейчас.

---

#### 5. Практика
* SOLID помогает строить слои (Controller → Service/UseCase → Repository).
* DRY снижает дублирование бизнес-логики.
* KISS/YAGNI защищают от оверинжиниринга.
</details>

---
### 24. Паттерны проектирования, с которыми приходилось работать.

<details>
<summary>Раскрыть:</summary>

На собеседовании лучше перечислять паттерны через “проблема → решение → где применял”.

#### 1. Creational
* **Factory / Abstract Factory** — создание объектов без привязки к конкретным классам.
* **Builder** — сборка сложных объектов/DTO шаг за шагом.
* **Prototype** — создание через клонирование.
* **Singleton** — встречается, но часто считают антипаттерном в приложениях.

#### 2. Structural
* **Adapter** — адаптация внешнего API/SDK к внутреннему интерфейсу.
* **Decorator** — добавление поведения (кеш/логирование) без наследования.
* **Facade** — простой интерфейс к сложной подсистеме.
* **Proxy** — проксирование вызовов (кеш, lazy, remote calls).

#### 3. Behavioral
* **Strategy** — выбор алгоритма (комиссии, правила).
* **Observer / Event Dispatcher** — события (Symfony events, Doctrine subscribers).
* **Command** — действие как объект (handlers, async jobs).
* **Chain of Responsibility** — цепочка обработчиков (middleware).
* **Template Method** — общий алгоритм + переопределяемые шаги.

#### 4. Примеры “из жизни”
* Middleware (PSR-15) → Chain of Responsibility.
* CacheTagHelper/кеширование поверх репозитория → Decorator/Proxy.
* Разные способы расчёта комиссии → Strategy.
</details>

---
### 25. Что такое простая фабрика?

<details>
<summary>Раскрыть:</summary>

**Простая фабрика (Simple Factory)** — практический приём: класс/метод, который **создаёт нужную реализацию** по параметру.

#### 1. Зачем нужна
* убирает `new` из бизнес-логики
* централизует выбор реализаций
* упрощает тестирование и поддержку

#### 2. Пример
```php
interface NotifierInterface {
    public function send(string $msg): void;
}

final class EmailNotifier implements NotifierInterface {
    public function send(string $msg): void {}
}

final class SmsNotifier implements NotifierInterface {
    public function send(string $msg): void {}
}

final class NotifierFactory {
    public static function make(string $type): NotifierInterface
    {
        return match ($type) {
            'email' => new EmailNotifier(),
            'sms'   => new SmsNotifier(),
            default => throw new InvalidArgumentException('Unknown notifier type'),
        };
    }
}
```

#### 3. Плюсы
* простота
* быстро внедряется
* уменьшает дублирование создания объектов

#### 4. Минусы
* фабрика может вырасти в большой `switch/match` (нарушение OCP)
* при росте вариантов лучше:
  * DI container + autowiring
  * registry стратегий
  * factory method / abstract factory

#### 5. “Middle” формулировка
* “Simple Factory — это централизованное создание объектов по входному параметру. Удобно на старте, но при расширении лучше уходить в DI/стратегии, чтобы не разрастался switch.”
</details>

---
### 26. Что такое Service Layer и где его стоит применять?

<details>
<summary>Раскрыть:</summary>

**Service Layer** — это слой приложения, который содержит **бизнес-операции (use-cases)** и координирует работу домена и инфраструктуры.  
Его задача — держать “командную” логику в одном месте, а контроллеры/CLI/консоль — максимально тонкими.

#### 1. Что делает Service Layer
* принимает входные данные (DTO/команда)
* валидирует/нормализует (или вызывает валидатор)
* вызывает доменные сущности/доменные сервисы
* работает с репозиториями/транзакциями
* публикует события/интеграции (очередь, email, webhook)
* возвращает результат (DTO/ResponseModel)

#### 2. Что НЕ должен делать Service Layer
* не должен знать про HTTP/Request/Response (это ответственность контроллера)
* не должен содержать SQL/ORM-детали напрямую (лучше репозитории)
* не должен превращаться в “God Service” (слишком много обязанностей)

#### 3. Типичный пример структуры (упрощённо)
* Controller (Infrastructure) → вызывает
* Application Service / UseCase (Service Layer) → использует
* Domain (Entities, ValueObjects, Domain Services)
* Infrastructure (Repositories, HTTP clients, Cache, Queue)

#### 4. Пример (идея)
```php
final class CreateUserService
{
    public function __construct(
        private UserRepositoryInterface $users,
        private PasswordHasherInterface $hasher
    ) {}

    public function handle(CreateUserCommand $cmd): UserDto
    {
        $user = User::register($cmd->email, $this->hasher->hash($cmd->password));
        $this->users->save($user);

        return UserDto::fromEntity($user);
    }
}
```

#### 5. Где применять
* когда есть **несколько точек входа** (HTTP, CLI, cron, message bus) к одной логике
* когда бизнес-операции сложные и не должны жить в контроллере
* когда нужен чистый DDD/слоистая архитектура

#### 6. Плюсы
* тонкие контроллеры
* тестируемость (unit-тесты сервисов)
* переиспользуемость use-case
* лучшее разделение ответственности

#### 7. Минусы/ошибки
* можно “раздуть” слой, если нет границ
* чрезмерная абстракция в маленьких проектах (YAGNI)
</details>

---
### 27. Singleton: как устроен и почему является антипаттерном.

<details>
<summary>Раскрыть:</summary>

**Singleton** — паттерн, который гарантирует, что у класса будет **только один экземпляр** и предоставляет глобальную точку доступа к нему.

#### 1. Как устроен (классический вариант)
```php
final class Config
{
    private static ?self $instance = null;

    private function __construct() {}
    private function __clone() {}
    public function __wakeup() { throw new \RuntimeException('No'); }

    public static function getInstance(): self
    {
        return self::$instance ??= new self();
    }
}
```

#### 2. Почему в приложениях его часто считают антипаттерном
* **Скрытые зависимости**: класс в любом месте кода может дернуть Singleton, DI не видно.
* **Глобальное состояние**: сложно контролировать и тестировать.
* **Сложные тесты**: трудно подменять реализацию (моки), состояние “течёт” между тестами.
* **Нарушение SRP/DIP**: класс сам управляет своим жизненным циклом и доступом.
* **Проблемы с параллелизмом/конкурентностью** в некоторых сценариях.

#### 3. Чем заменить в современных проектах
* **DI container** (Symfony Container) — один shared-сервис = “singleton по контейнеру”, но без глобального доступа
* **Интерфейсы** + конфигурации
* **Factory / Provider** для управляемого создания
* **Static config** — только там, где действительно безопасно и нужно

#### 4. Когда Singleton допустим
* очень ограниченно: глобальные константные данные, которые не меняются
* внутренние механизмы языка/расширений (не бизнес-уровень)
  Но в большинстве бизнес-приложений лучше DI.
</details>

---
### 28. Что такое идемпотентность?

<details>
<summary>Раскрыть:</summary>

**Идемпотентность** — свойство операции, при котором **повторное выполнение** (один или много раз) приводит к **тому же состоянию**, что и одно выполнение.

#### 1. Идемпотентность в HTTP
Идемпотентные методы:
* **GET** — не меняет состояние
* **PUT** — устанавливает состояние ресурса
* **DELETE** — удаление (повторный delete не меняет итог)
* **HEAD** — как GET без тела

Неидемпотентный:
* **POST** — обычно создаёт новый ресурс каждый раз

#### 2. Пример
```http
PUT /users/1
{ "name": "Ihor" }
```
Если отправить 5 раз — пользователь всё равно будет “Ihor”.

А вот:
```http
POST /users
{ "name": "Ihor" }
```
5 раз → может создать 5 пользователей.

#### 3. Идемпотентность в бизнес-операциях
Иногда нужно сделать POST идемпотентным:
* платежи
* создание заявок
* отправка уведомлений

Обычно решают через **Idempotency-Key**:
* клиент присылает уникальный ключ
* сервер хранит результат по ключу и возвращает тот же ответ при повторе

#### 4. Зачем это важно
* сеть ненадёжна, ретраи неизбежны
* балансировщики/клиенты могут повторять запрос
* идемпотентность предотвращает двойные платежи/создания
</details>

---
### 29. Жизненный цикл HTTP-запроса.

<details>
<summary>Раскрыть:</summary>

Это “путь” запроса от браузера/клиента до приложения и обратно.

#### 1. Клиент формирует запрос
* URL, метод, заголовки, тело
* cookies, auth headers

#### 2. DNS
* домен → IP (кеш браузера/ОС/резолвер)

#### 3. Соединение
* TCP handshake
* TLS handshake (если HTTPS)
* возможен HTTP/2 или HTTP/3

#### 4. Запрос попадает на web-server
* nginx / apache принимает соединение
* проверка правил (location, rewrite)
* статика отдаётся сразу или проксируется дальше

#### 5. Передача в приложение
Для PHP обычно:
* nginx → **PHP-FPM** (FastCGI) → PHP runtime → framework (Symfony/Laravel)

#### 6. Обработка в приложении
* Routing → Controller
* Middleware/Kernel events
* Service Layer / UseCase
* DB/Cache/HTTP calls
* формирование ответа

#### 7. Ответ клиенту
* статус (200/201/400/500)
* headers (cache-control, content-type, set-cookie)
* body (HTML/JSON)

#### 8. На стороне клиента
* браузер рендерит HTML/CSS/JS или клиент обрабатывает JSON
* кеширование и повторные запросы (ETag, If-Modified-Since)

#### 9. Где чаще всего “узкие места”
* DB (запросы, индексы)
* внешние API
* сериализация больших ответов
* отсутствие кеша / неправильно настроенный кеш
* медленный TLS/сеть при большом трафике
</details>

---
### 30. Что такое куча и стек?

<details>
<summary>Раскрыть:</summary>

Это две базовые области памяти, которые используются программой по-разному.

#### 1. Стек (Stack)
Стек — это область памяти для:
* локальных переменных функций
* параметров вызова
* адресов возврата
* кадров стека (stack frames)

Особенности:
* работает по принципу **LIFO** (последний вошёл — первый вышел)
* очень быстрый (выделение/освобождение)
* ограничен по размеру → возможен **stack overflow** при глубокой рекурсии

Пример: глубокая рекурсия в PHP может привести к ошибкам/лимитам.

#### 2. Куча (Heap)
Куча — это область памяти для:
* объектов
* больших структур данных
* данных с “непредсказуемым” временем жизни

Особенности:
* управление памятью сложнее
* освобождение происходит через сборщик мусора (GC) / reference counting (в PHP)

#### 3. Как это связано с PHP
* Переменные в PHP — это zval структуры, а объекты обычно живут в куче.
* PHP использует **reference counting + cycle collector** (GC) для циклических ссылок.
* Стек используется для вызовов функций, но сам PHP-уровень скрывает детали.

#### 4. Важные практические последствия
* бесконтрольная рекурсия → проблемы со стеком
* циклические ссылки в объектах → может потребоваться GC
* большие массивы/объекты → давление на кучу и память
</details>

---
### 31. Что такое рефлексия?

<details>
<summary>Раскрыть:</summary>

**Рефлексия** — это механизм, который позволяет программе **исследовать свою структуру во время выполнения**:
* какие есть классы/методы/свойства
* какие типы параметров
* какие атрибуты (attributes)
* какие модификаторы доступа (public/protected/private)

В PHP это реализовано через набор классов `Reflection*` (ReflectionClass, ReflectionMethod, и т.д.).

#### 1. Зачем нужна рефлексия
* **DI-контейнеры** (Symfony) — автосвязывание зависимостей по типам.
* **ORM/Serializer** — чтение метаданных, аннотаций/атрибутов.
* **Автогенерация документации** (OpenAPI).
* **Тестирование** — доступ к приватным методам/свойствам в редких случаях.
* **Фреймворки** — роутинг, middleware, атрибуты.

#### 2. Пример: узнать методы класса
```php
$ref = new ReflectionClass(UserService::class);

foreach ($ref->getMethods() as $method) {
    echo $method->getName() . PHP_EOL;
}
```

#### 3. Пример: получить атрибуты (PHP 8+)
```php
#[Attribute]
class Route {
    public function __construct(public string $path) {}
}

final class Controller {
    #[Route('/users')]
    public function list() {}
}

$refMethod = new ReflectionMethod(Controller::class, 'list');
$attrs = $refMethod->getAttributes(Route::class);

$route = $attrs[0]->newInstance();
echo $route->path; // /users
```

#### 4. Минусы рефлексии
* медленнее, чем прямые вызовы (обычно не критично, но важно)
* повышает “магичность” кода и может усложнить отладку
* может ломать инкапсуляцию (если использовать для доступа к private)

#### 5. Как звучит “Middle” ответ
* “Рефлексия — это интроспекция структуры кода во время выполнения. В PHP она используется в DI, ORM, сериализации и атрибутах, но нужно помнить про накладные расходы и не злоупотреблять.”
</details>

---
### 32. Что такое хеш-функция и где она используется?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 33. Как используются очереди в PHP?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 34. Как в общих чертах работает OPcache?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 35. Что такое GRASP?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 36. Что такое TDD?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 37. Чем отличаются модульные тесты от интеграционных?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 38. Что такое трейты и как применять их на практике?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 39. Как решать конфликты при использовании trait?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 40. Как работает автозагрузка классов?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 41. Разница между стеком и очередью.

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 42. Unit и Functional тесты. Моки и стабы в PHP.

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 43. Как вызвать приватный метод (гипотетическая ситуация)?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 44. Разница между PHP-FPM и «PHP на сокете».

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 45. Как реализовать загрузку больших отчетов (1GB и более)?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 46. Как импортировать 50GB XML в базу данных?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 47. Почему после PHP 5 сразу вышел PHP 7, куда делся PHP 6?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 48. Есть ли разница между self и $this в PHP?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 49. Что такое PuTTY?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 50. Как запускать важный PHP-файл каждые 20 секунд?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 51. Как расшифровать права 644 для файла в Linux?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
### 52. Что такое Opcode?

<details>
<summary>Раскрыть:</summary>

...
</details>

---
