# Middle PHP

## Оглавление
1. [Как передаются переменные (по значению или по ссылке)?](#1-как-передаются-переменные-по-значению-или-по-ссылке)
2. [Какие процессы происходят, когда пользователь вводит URL в браузере?](#2-какие-процессы-происходят-когда-пользователь-вводит-url-в-браузере)
3. [Что такое вариативная функция или splat-оператор?](#3-что-такое-вариативная-функция-или-splat-оператор)
4. [Что такое OWASP?](#4-что-такое-owasp)
5. [Какие типы уязвимостей вы знаете и как от них защищаться?](#5-какие-типы-уязвимостей-вы-знаете-и-как-от-них-защищаться)
6. [Что такое идемпотентные методы? Какие HTTP-методы являются идемпотентными в REST?](#6-что-такое-идемпотентные-методы-какие-http-методы-являются-идемпотентными-в-rest)
7. [Что такое stateless?](#7-что-такое-stateless)
8. [SOAP vs REST — в чем разница?](#8-soap-vs-rest-в-чем-разница)
9. [Какие методы авторизации используются для построения API?](#9-какие-методы-авторизации-используются-для-построения-api)
10. [Что может содержать интерфейс?](#10-что-может-содержать-интерфейс)
11. [Клонирование объектов и вложенные объекты (shallow / deep clone).](#11-клонирование-объектов-и-вложенные-объекты-shallow-deep-clone)
12. [Что такое Mock? Где используется и зачем?](#12-что-такое-mock-где-используется-и-зачем)
13. [Что такое PSR?](#13-что-такое-psr)
14. [Опишите реализацию одного из паттернов проектирования.](#14-опишите-реализацию-одного-из-паттернов-проектирования)
15. [Что такое Redis?](#15-что-такое-redis)
16. [Как хранятся данные в Redis и Memcached?](#16-как-хранятся-данные-в-redis-и-memcached)
17. [Redis и Memcached для кеширования: плюсы и минусы.](#17-redis-и-memcached-для-кеширования-плюсы-и-минусы)
18. [Отличия между nginx и Apache.](#18-отличия-между-nginx-и-apache)
19. [Что такое OPcache и как он работает?](#19-что-такое-opcache-и-как-он-работает)
20. [Что такое JIT и как он работает?](#20-что-такое-jit-и-как-он-работает)
21. [Зачем нужно ключевое слово final?](#21-зачем-нужно-ключевое-слово-final)
22. [Что нового в PHP 7 и PHP 8?](#22-что-нового-в-php-7-и-php-8)
23. [SOLID, DRY, KISS, YAGNI.](#23-solid-dry-kiss-yagni)
24. [Паттерны проектирования, с которыми приходилось работать.](#24-паттерны-проектирования-с-которыми-приходилось-работать)
25. [Что такое простая фабрика?](#25-что-такое-простая-фабрика)
26. [Что такое Service Layer и где его стоит применять?](#26-что-такое-service-layer-и-где-его-стоит-применять)
27. [Singleton: как устроен и почему является антипаттерном.](#27-singleton-как-устроен-и-почему-является-антипаттерном)
28. [Что такое идемпотентность?](#28-что-такое-идемпотентность)
29. [Жизненный цикл HTTP-запроса.](#29-жизненный-цикл-http-запроса)
30. [Что такое куча и стек?](#30-что-такое-куча-и-стек)
31. [Что такое рефлексия?](#31-что-такое-рефлексия)
32. [Что такое хеш-функция и где она используется?](#32-что-такое-хеш-функция-и-где-она-используется)
33. [Как используются очереди в PHP?](#33-как-используются-очереди-в-php)
34. [Как в общих чертах работает OPcache?](#34-как-в-общих-чертах-работает-opcache)
35. [Что такое GRASP?](#35-что-такое-grasp)
36. [Что такое TDD?](#36-что-такое-tdd)
37. [Чем отличаются модульные тесты от интеграционных?](#37-чем-отличаются-модульные-тесты-от-интеграционных)
38. [Что такое трейты и как применять их на практике?](#38-что-такое-трейты-и-как-применять-их-на-практике)
39. [Как решать конфликты при использовании trait?](#39-как-решать-конфликты-при-использовании-trait)
40. [Как работает автозагрузка классов?](#40-как-работает-автозагрузка-классов)
41. [Разница между стеком и очередью.](#41-разница-между-стеком-и-очередью)
42. [Unit и Functional тесты. Моки и стабы в PHP.](#42-unit-и-functional-тесты-моки-и-стабы-в-php)
43. [Как вызвать приватный метод (гипотетическая ситуация)?](#43-как-вызвать-приватный-метод-гипотетическая-ситуация)
44. [Разница между PHP-FPM и «PHP на сокете».](#44-разница-между-php-fpm-и-php-на-сокете)
45. [Как реализовать загрузку больших отчетов (1GB и более)?](#45-как-реализовать-загрузку-больших-отчетов-1gb-и-более)
46. [Как импортировать 50GB XML в базу данных?](#46-как-импортировать-50gb-xml-в-базу-данных)
47. [Почему после PHP 5 сразу вышел PHP 7, куда делся PHP 6?](#47-почему-после-php-5-сразу-вышел-php-7-куда-делся-php-6)
48. [Есть ли разница между self и $this в PHP?](#48-есть-ли-разница-между-self-и-this-в-php)
49. [Что такое PuTTY?](#49-что-такое-putty)
50. [Как запускать важный PHP-файл каждые 20 секунд?](#50-как-запускать-важный-php-файл-каждые-20-секунд)
51. [Как расшифровать права 644 для файла в Linux?](#51-как-расшифровать-права-644-для-файла-в-linux)
52. [Что такое Opcode?](#52-что-такое-opcode)

---
### 1. Как передаются переменные (по значению или по ссылке)?

<details>
<summary>Раскрыть:</summary>

В PHP аргументы функций **по умолчанию передаются по значению**.  
Это означает, что функция получает **копию значения**, а не саму переменную.

```php
function foo($a) {
    $a = 10;
}

$b = 5;
foo($b);
echo $b; // 5
```
Передача по ссылке выполняется с помощью оператора &.
```php
function foo(&$a) {
    $a = 10;
}

$b = 5;
foo($b);
echo $b; // 10
```
Важно:
* объекты в PHP передаются по значению ссылки
* & используется редко и требует аккуратности
* лишние ссылки могут усложнять отладку
</details>

---
### 2. Какие процессы происходят, когда пользователь вводит URL в браузере?

<details>
<summary>Раскрыть:</summary>

Основные этапы:

#### 1. Парсинг URL
* протокол, домен, путь, query
#### 2. DNS-запрос
* получение IP-адреса сервера
#### 3. Установка соединения
* TCP (3-way handshake)
* TLS (если HTTPS)
#### 4. HTTP-запрос
* отправка заголовков и тела
#### 5. Обработка на сервере
* web-сервер → PHP-FPM → приложение
#### 6. HTTP-ответ
* статус, заголовки, тело
#### 7. Рендеринг браузером
* HTML → CSS → JS → DOM
</details>

---
### 3. Что такое вариативная функция или splat-оператор?

<details>
<summary>Раскрыть:</summary>

**Вариативная функция** принимает произвольное количество аргументов.
```php
function sum(int ...$numbers): int {
    return array_sum($numbers);
}

sum(1, 2, 3); // 6
```
splat-оператор (...) также используется для распаковки массивов:
```php
$args = [1, 2, 3];
sum(...$args);
```
Используется:
* в прокси-методах
* в middleware
* для гибких API
</details>

---
### 4. Что такое OWASP?

<details>
<summary>Раскрыть:</summary>

**OWASP (Open Worldwide Application Security Project)** — международная организация,
занимающаяся безопасностью веб-приложений.

Самый известный документ — OWASP Top 10, список критических уязвимостей:
* SQL Injection
* XSS
* CSRF
* Broken Authentication
* Security Misconfiguration

Используется как стандарт secure-coding.
</details>

---
### 5. Какие типы уязвимостей вы знаете и как от них защищаться?

<details>
<summary>Раскрыть:</summary>

#### 1. SQL Injection
**Описание:**  
Атака, при которой злоумышленник внедряет SQL-код в пользовательский ввод, чтобы:
- получить доступ к данным,
- изменить данные,
- выполнить админские операции.
 
**Защита:**
- Использовать prepared statements:
  - PDO (prepare, bindParam)
  - Doctrine ORM / DBAL
- Никогда не конкатенировать SQL-строки
- Ограничивать права БД-пользователя

#### 2. XSS (Cross-Site Scripting)
**Описание:**  
Внедрение JavaScript-кода, который выполняется в браузере жертвы.

**Защита:**
- Экранирование вывода (htmlspecialchars, Twig auto-escape)
- Никогда не доверять данным от пользователя
- Content Security Policy (CSP):
  - запрет inline-скриптов
  - whitelist источников
- Использование безопасных шаблонизаторов

✅ Важно: экранируем на выводе, а не на входе

#### 3. CSRF (Cross-Site Request Forgery)
**Описание:**  
Атака, при которой пользователь неосознанно отправляет запрос от своего имени (например, перевод денег).

**Защита:**
- **CSRF-токены** (уникальные, одноразовые)
- Проверка Origin / Referer
- Cookies с флагом SameSite:
  - Lax / Strict
- Использование POST/PUT/DELETE для изменений

✅ Frameworks: Symfony CSRF, Laravel CSRF, Yii CSRF

#### 4. Broken Authentication
**Описание:**  
Ошибки в логике аутентификации:
- слабые пароли,
- утечка токенов,
- отсутствие ограничения попыток входа.

**Защита:**
- Хеширование паролей:
  - bcrypt
  - argon2id
- Ограничение количества login attempts
- JWT:
  - короткий TTL access-токена
  - refresh-токены
- HTTP-only cookies
- 2FA / MFA

❌ Никогда не хранить пароли в открытом виде
</details>

---
### 6. Что такое идемпотентные методы? Какие HTTP-методы являются идемпотентными в REST?

<details>
<summary>Раскрыть:</summary>

**Идемпотентность** — повторный вызов операции даёт тот же результат.

Идемпотентные HTTP-методы:
- GET
- PUT
- DELETE
- HEAD

Неидемпотентный:
- POST

Пример:
```php
PUT /users/1
```
</details>

---
### 7. Что такое stateless?

<details>
<summary>Раскрыть:</summary>

**Stateless** (без состояния) — это принцип, при котором **сервер не хранит информацию о состоянии клиента между запросами**.  
Каждый запрос обрабатывается **независимо** и содержит **всю необходимую информацию** для его выполнения.

#### Stateless в контексте HTTP

HTTP — это **stateless-протокол** по своей природе.

Это означает:
- сервер **не помнит** предыдущие запросы клиента,
- каждый HTTP-запрос самодостаточен,
- сервер не хранит данные о сессии между запросами.

**Пример:**
```http
GET /api/users/me
Authorization: Bearer <token>
```
</details>

---
### 8. SOAP vs REST. В чем разница?

<details>
<summary>Раскрыть:</summary>

**SOAP** и **REST** — это два разных подхода к построению веб-сервисов и API, которые отличаются философией, протоколами, форматом данных и областью применения.  

SOAP — это **строгий протокол обмена сообщениями**, основанный на XML и формальных контрактах.  
REST — это **архитектурный стиль**, а не протокол, использующий стандартные возможности HTTP.

| Критерий           | SOAP                     | REST                          |
|--------------------|--------------------------|-------------------------------|
| **Тип**            | Протокол                 | Архитектурный стиль           |
| **Формат данных**  | XML                      | JSON / XML                    |
| **Контракт**       | WSDL                     | OpenAPI (опционально)         |
| **Stateful**       | Может быть               | Stateless                     |
| **Производительность** | Ниже               | Выше                          |
| **Простота**       | Сложный                  | Простой                       |
| **Кеширование**    | Нет                      | Есть (HTTP Cache)             |
| **Безопасность**   | WS-Security              | HTTPS, OAuth, JWT             |

**Когда использовать SOAP**
- Корпоративные системы
- Банковские и финансовые интеграции
- Нужны транзакции и гарантированная доставка
- Требуется строгий контракт

**Когда использовать REST**
- Web / Mobile / SPA
- Микросервисы
- Высокая нагрузка
- Простота и скорость важнее формальностей

**Короткий ответ для собеседования**

**SOAP** — это строгий XML-протокол с контрактом WSDL, поддержкой транзакций и расширенной безопасности.  
**REST** — это архитектурный стиль, основанный на HTTP, stateless и чаще использующий JSON.  
**REST** проще, быстрее и лучше подходит для современных веб-приложений, SOAP — для enterprise-систем.
</details>

---
### 9. Какие методы авторизации используются для построения API?

<details>
<summary>Раскрыть:</summary>

Для API используются:
 - **Basic Auth** - Простейший механизм, при котором логин и пароль передаются в заголовке `Authorization`, закодированные в Base64.
 - **API Key** - Клиенту выдаётся уникальный ключ, который передаётся в каждом запросе.
 - **OAuth 2.0** - Стандарт авторизации, позволяющий безопасно делегировать доступ к ресурсам без передачи пароля.
 - **JWT** - Самодостаточный токен, содержащий информацию о пользователе и правах доступа, подписанный криптографически.
 - **Session + Cookie** - Классический подход, сервер хранит сессию, клиент передаёт session ID в cookie.

| Метод              | Stateless | Масштабируемость | Безопасность | Использование          |
|--------------------|-----------|------------------|--------------|------------------------|
| **Basic Auth**     | ❌        | ❌               | ❌           | Тесты                  |
| **API Key**        | ✅        | ✅               | ⚠️           | Service-to-service     |
| **OAuth 2.0**      | ✅        | ✅               | ✅           | Enterprise             |
| **JWT**            | ✅        | ✅               | ⚠️           | API, микросервисы      |
| **Session + Cookie** | ❌      | ❌               | ✅           | Web                    |

В микросервисах чаще всего применяют OAuth 2.0 для выдачи токенов и JWT как stateless-механизм авторизации.
</details>

---
### 10. Что может содержать интерфейс?

<details>
<summary>Раскрыть:</summary>

Интерфейс может содержать:
- объявления методов (все методы public, можно объявлять extends от других интерфейсов)
- константы (всегда public, нельзя переопределять значение константы в классе)

Не может содержать:
- реализацию методов
- свойства

| Критерий                   | Интерфейс | Абстрактный класс |
|----------------------------|-----------|-------------------|
| **Методы с реализацией**   | ❌        | ✅                |
| **Свойства**               | ❌        | ✅                |
| **Константы**              | ✅        | ✅                |
| **Множественное наследование** | ✅    | ❌                |
| **Конструктор**            | ❌        | ✅                |
</details>

---
### 11. Клонирование объектов и вложенные объекты shallow deep clone.

<details>
<summary>Раскрыть:</summary>

В PHP оператор `clone` создаёт **копию объекта**, но важно понимать, что это копирование **по умолчанию поверхностное (shallow)**:  
сам объект копируется, а **вложенные объекты внутри свойств** продолжают ссылаться на те же экземпляры, пока вы не выполните “глубокое” копирование вручную.

#### 1. Shallow clone (поверхностное клонирование)
* Создаётся новый объект (новый идентификатор).
* **Скалярные** свойства копируются как значения.
* **Объекты внутри свойств** остаются теми же (копируются ссылки на них).

Пример:
```php
final class Address {
    public function __construct(public string $city) {}
}

final class UserProfile {
    public function __construct(
        public string $name,
        public Address $address
    ) {}
}

$u1 = new UserProfile('Ihor', new Address('Warsaw'));
$u2 = clone $u1;

$u2->name = 'Max';
$u2->address->city = 'Krakow';

echo $u1->name;            // Ihor (скаляр отдельно)
echo $u1->address->city;   // Krakow (вложенный объект общий!)
```

#### 2. Deep clone (глубокое клонирование)
Чтобы клон был “независимым”, нужно вручную клонировать вложенные объекты — обычно через `__clone()`.

```php
final class UserProfile {
    public function __construct(
        public string $name,
        public Address $address
    ) {}

    public function __clone(): void
    {
        $this->address = clone $this->address; // deep для вложенного объекта
    }
}
```

#### 3. Что происходит при `clone`
* Вызывается “внутренний” механизм копирования объекта.
* Затем, если определён метод `__clone()`, он вызывается **на новом объекте**.

#### 4. Частые нюансы на практике
* **ORM (Doctrine)**: клонирование Entity может быть опасным (id, UnitOfWork, коллекции). Обычно делают отдельные DTO/Factory для “копирования”.
* **Коллекции/массивы с объектами**: массив копируется, но элементы-объекты остаются общими → нужен deep clone для каждого элемента.
* `DateTimeImmutable` безопаснее для “шеринга”, чем `DateTime`, потому что он неизменяемый.

#### 5. Когда использовать
* Прототипирование объектов (паттерн Prototype).
* Подготовка “черновика” данных перед изменениями.
* Копирование конфигураций/настроек (при условии корректного deep clone).
</details>

---
### 12. Что такое Mock? Где используется и зачем?

<details>
<summary>Раскрыть:</summary>

**Mock (мок)** — это тестовый двойник (test double), который:
* имитирует зависимость (например, репозиторий, HTTP-клиент),
* позволяет **задавать ожидания**: какие методы должны быть вызваны, сколько раз и с какими аргументами.

#### 1. Зачем нужен Mock
* Изолировать unit-тест от внешних зависимостей: БД, сеть, очередь, время.
* Проверить **поведение** (behavior): “вызвали ли мы нужный метод?”
* Сделать тесты быстрыми, стабильными и предсказуемыми.

#### 2. Mock vs Stub (важное отличие)
* **Stub** — возвращает заранее подготовленные данные, без проверки “как его вызывали”.
* **Mock** — кроме возврата данных, ещё и **проверяет взаимодействие** (expectations).

#### 3. Пример в PHPUnit (простая идея)
```php
$repo = $this->createMock(UserRepository::class);

$repo->expects($this->once())
    ->method('save')
    ->with($this->isInstanceOf(User::class));

$service = new UserService($repo);
$service->register('test@example.com');
```

#### 4. Где обычно используют
* Unit-тесты сервисов (Service Layer, UseCase/Handler).
* Тестирование контроллеров (реже — если это не интеграционный тест).
* Тестирование кода, который дергает внешние API (HTTP client) или очередь.

#### 5. Типичные ошибки
* Слишком много моков → тест становится “тестом реализации”, ломается при рефакторинге.
* Мокать “свою” бизнес-логику вместо границ системы — обычно мокают **инфраструктуру** (репозитории, клиенты, логгеры).
* Не различать unit и интеграционные тесты.
</details>

---
### 13. Что такое PSR?

<details>
<summary>Раскрыть:</summary>

**PSR (PHP Standards Recommendations)** — набор рекомендаций/стандартов, публикуемых группой **PHP-FIG**, чтобы разные библиотеки и фреймворки были совместимы по интерфейсам и стилю.

#### 1. Зачем это нужно
* Унификация кода в проектах и командах.
* Совместимость компонентов (например, любой PSR-3 Logger можно подменить другим).
* Упрощение интеграции пакетов из Composer-экосистемы.

#### 2. Наиболее важные PSR (то, что часто спрашивают)
* **PSR-4** — автозагрузка классов (namespace → путь).
* **PSR-3** — интерфейс логгера (`LoggerInterface`).
* **PSR-7** — HTTP сообщения (Request/Response/Stream).
* **PSR-11** — контейнер зависимостей (`ContainerInterface`).
* **PSR-15** — HTTP middleware (request handler + middleware).
* **PSR-18** — HTTP client.
* **PSR-6 / PSR-16** — кеширование (pool/simple-cache).
* **PSR-12** — код-стайл (расширение PSR-2).

#### 3. Пример: PSR-3 Logger
```php
use Psr\Log\LoggerInterface;

final class PaymentService {
    public function __construct(private LoggerInterface $logger) {}

    public function pay(): void {
        $this->logger->info('Payment started');
    }
}
```
Тут важно: сервису всё равно, какой именно логгер внутри (Monolog, кастомный и т.д.) — главное, что он PSR-3.

#### 4. Как это проявляется в Symfony
* Многие компоненты Symfony “наружу” дают PSR-интерфейсы (логгер, кеш, контейнер, HTTP).
* Это облегчает замену реализации без переписывания кода.
</details>

---
### 14. Опишите реализацию одного из паттернов проектирования.

<details>
<summary>Раскрыть:</summary>

Опишем **Strategy (Стратегия)** — паттерн, который позволяет **заменять алгоритм поведения** во время выполнения через общий интерфейс.

#### 1. Идея паттерна
* Есть “контекст”, которому нужно выполнить действие (например, рассчитать комиссию).
* Алгоритмы разные (для разных провайдеров/стран/режимов).
* Мы выносим алгоритмы в отдельные классы-стратегии.

#### 2. Пример (PHP)
```php
interface FeeStrategyInterface {
    public function calculate(int $amount): int;
}

final class FixedFeeStrategy implements FeeStrategyInterface {
    public function __construct(private int $fee) {}
    public function calculate(int $amount): int { return $amount + $this->fee; }
}

final class PercentFeeStrategy implements FeeStrategyInterface {
    public function __construct(private int $percent) {}
    public function calculate(int $amount): int {
        return $amount + (int) round($amount * $this->percent / 100);
    }
}

final class PaymentCalculator {
    public function __construct(private FeeStrategyInterface $strategy) {}

    public function total(int $amount): int {
        return $this->strategy->calculate($amount);
    }
}
```

#### 3. Что даёт Strategy
* Убирает большие `if/else` или `switch` по типам.
* Упрощает расширение: добавили новую стратегию — не ломаем старые.
* Легче тестировать: каждая стратегия тестируется отдельно.

#### 4. Где часто используют в реальных проектах
* Тарифы/комиссии, расчёты, валидации по разным правилам.
* Выбор провайдера/интеграции (Stripe/Adyen/PayPal).
* В Symfony удобно через DI + теги/Registry (собираем набор стратегий).
</details>

---
### 15. Что такое Redis?

<details>
<summary>Раскрыть:</summary>

**Redis** — высокопроизводительное in-memory хранилище данных (key-value), которое поддерживает разные структуры данных и часто используется как кеш, брокер событий и быстрое хранилище.

#### 1. Ключевые особенности
* Данные хранятся в памяти → очень быстро.
* Поддерживает структуры:
  * Strings
  * Hashes
  * Lists
  * Sets / Sorted Sets
  * Streams
* Может сохранять данные на диск (persistency):
  * **RDB** (снимки)
  * **AOF** (журнал операций)

#### 2. Типовые кейсы использования
* **Кеширование** (страницы/запросы/DTO/флаги)
* **Сессии** (особенно при масштабировании)
* **Rate limiting** (счётчики запросов)
* **Distributed locks** (защита от параллельных запусков)
* **Очереди / стримы** (Streams, списки)
* **Pub/Sub** (уведомления)

#### 3. Важные концепции для продакшна
* **TTL/expiration** — время жизни ключей.
* **Eviction policy** — что делать при нехватке памяти (LRU/LFU и т.д.).
* **Replication / Sentinel / Cluster** — отказоустойчивость и масштабирование.
* **Проблемы “кеш-штампа”** — когда много запросов одновременно пытаются пересоздать истёкший кеш (решают locks, jitter TTL, soft TTL).

#### 4. Пример: простое кеширование (идея)
```php
// Псевдо-логика: положить значение с TTL
SET user:123 "{...json...}" EX 300
```

#### 5. Redis vs Memcached (коротко)
* Redis богаче по структурам и возможностям (locks, streams, persistence).
* Memcached проще и очень быстрый для простого кеша, но функциональность меньше.
</details>

---
### 16. Как хранятся данные в Redis и Memcached?

<details>
<summary>Раскрыть:</summary>

И Redis, и Memcached — это быстрые in-memory хранилища, но **модель хранения и возможности сильно отличаются**.

#### 1. Memcached: простое key-value хранилище
Memcached хранит данные как:
* **ключ → бинарная строка (blob)**

То есть вы сами решаете, что класть:
* JSON
* сериализованный PHP (`serialize()`)
* простая строка/число

Особенности:
* **только память**, без “родного” persistence (обычно без сохранения на диск)
* нет сложных структур (только value-blob)
* TTL есть (expiration)
* при нехватке памяти удаляет ключи согласно политике (LRU — классический вариант)

Пример (идея):
```
SET user:123 "{...json...}" EX 300
GET user:123
```

#### 2. Redis: key-value + структуры данных
Redis тоже хранит:
* **ключ → значение**, но значение может быть **разных типов**:

* **String** — строка/число/байты
* **Hash** — набор полей (похоже на мини-объект)
* **List** — список (очереди, ленты)
* **Set** — множество уникальных значений
* **Sorted Set** — множество с сортировкой по score
* **Stream** — поток сообщений
* и другие (bitmaps, hyperloglog, geo)

Это даёт возможность делать операции **на стороне Redis**, без скачивания/пересборки всего объекта.

Пример: Hash для пользователя
```
HSET user:123 name "Ihor" city "Warsaw"
HGET user:123 name
```

#### 3. Persistence: главное отличие
Redis умеет сохранять данные на диск:
* **RDB** — снимки (snapshot)
* **AOF** — журнал операций (append-only file)
  Можно включать отдельно или вместе.

Memcached обычно не хранит данные на диск (это чистый кеш).

#### 4. Истечение ключей (TTL)
И там, и там можно задавать TTL:
* ключ живёт N секунд, потом удаляется
* в Redis TTL применяется ко всему ключу (не к отдельным полям hash)

#### 5. Практические последствия
* Memcached чаще всего используют как “тупой” кеш (простые ключи/значения).
* Redis подходит и для кеша, и для более сложных задач (locks, rate-limit, очереди, pub/sub, streams).
</details>

---
### 17. Redis и Memcached для кеширования: плюсы и минусы.

<details>
<summary>Раскрыть:</summary>

Оба решения подходят для кеширования, но выбор зависит от задачи.

#### 1. Redis — плюсы
* **Больше возможностей**: структуры данных, atomic операции.
* **Locks** (distributed locks) — защита от параллельных запусков/кеш-штампа.
* **Rate limiting** (счётчики, sliding window).
* **Pub/Sub, Streams** — события/очереди.
* **Persistence** (RDB/AOF) и репликация → может переживать перезапуски лучше.
* **Lua scripts** — сложные атомарные сценарии на стороне Redis.

#### 2. Redis — минусы
* Сложнее в эксплуатации: настройки памяти, persistence, репликация/cluster.
* При неверной конфигурации persistence может влиять на latency.
* Можно “перегрузить” Redis задачами, которые лучше делать отдельным брокером (RabbitMQ/Kafka), если нет дисциплины.

#### 3. Memcached — плюсы
* **Очень простой**: ключ → значение.
* Часто даёт отличную производительность на “тупом” кеше.
* Меньше “функций” → меньше способов ошибиться.
* Хорош для больших объёмов однотипного кеша.

#### 4. Memcached — минусы
* Нет сложных структур и атомарных сценариев уровня Redis.
* Обычно без persistence (после рестарта кеш пропадает).
* Меньше инструментов для locks/rate-limit/pubsub.

#### 5. Что выбрать на практике
* **Нужен простой кеш страниц/ответов/DTO** → Memcached или Redis (оба ок).
* **Нужны locks / rate-limit / счётчики / очереди / streams** → Redis.
* **Микросервисы + много use-case** → Redis чаще выигрывает универсальностью, но важно не превращать его во “всё сразу”.

#### 6. Типичные ошибки при кешировании (для обоих)
* Нет стратегии инвалидирования (теги, версии ключей).
* Неправильный TTL (слишком большой или слишком маленький).
* Нет защиты от cache stampede (jitter TTL, locks, soft TTL).
* Кешируют “персональные” данные без учёта контекста (locale, permissions, brand, etc.).
</details>

---
### 18. Отличия между nginx и Apache.

<details>
<summary>Раскрыть:</summary>

Оба — веб-серверы, но архитектура и сценарии применения отличаются.

#### 1. Архитектура
**nginx**
* event-driven, асинхронная модель
* хорошо держит много одновременных соединений
* низкое потребление памяти при высокой нагрузке

**Apache**
* исторически process/thread-based (prefork/worker/event MPM)
* более “тяжёлый” в классических конфигурациях, но гибкий

#### 2. Статика и проксирование
nginx очень силён в:
* раздаче статики (css/js/images)
* reverse proxy (проксирование на PHP-FPM, Node, Go)
* балансировке
* TLS termination

Apache тоже умеет, но nginx часто проще и быстрее в роли “фронта”.

#### 3. Конфигурация и .htaccess
Apache:
* поддерживает `.htaccess` (конфиги в директориях)
* удобно для shared-hosting, но это накладно по производительности (нужно проверять .htaccess)

nginx:
* **нет** `.htaccess`
* все правила в одном месте (централизованно) → лучше для продакшна и контроля

#### 4. Модули и экосистема
Apache:
* огромная экосистема модулей
* мощные возможности на уровне директории (auth, rewrite)

nginx:
* тоже модули, но подход другой; часто меньше “магии”, больше явной конфигурации

#### 5. Типичный сетап для PHP
На практике очень распространено:
* **nginx** как фронт (TLS, статика, proxy)
* **PHP-FPM** как обработчик PHP
* Apache в современных PHP-проектах реже используется как основной фронт, но встречается

#### 6. Когда выбирать что
* Высокая нагрузка, много соединений, прокси, микросервисы → nginx.
* Shared-hosting, проекты, завязанные на .htaccess/модули Apache → Apache.
</details>

---
### 19. Что такое OPcache и как он работает?

<details>
<summary>Раскрыть:</summary>

**OPcache** — встроенный в PHP механизм кеширования **скомпилированного байткода (opcode)**.

Идея: PHP — интерпретируемый язык, и без OPcache на каждый запрос происходило бы:
* чтение PHP-файла
* парсинг
* компиляция в opcode
* выполнение

OPcache убирает “компиляцию на каждый запрос”.

#### 1. Что кешируется
* результат компиляции PHP-скриптов → **opcode** в общей памяти (shared memory)
* несколько процессов PHP-FPM могут использовать один кеш

#### 2. Как работает (в общем виде)
1) Первый запрос к файлу:
* PHP компилирует файл в opcode
* кладёт в OPcache

2) Следующие запросы:
* opcode берётся из кеша
* этапы парсинга/компиляции пропускаются

#### 3. Важные настройки (по смыслу)
* размер памяти OPcache
* количество кешируемых файлов
* валидация изменений файлов:
  * в dev — часто включают проверку изменений
  * в prod — часто отключают постоянную проверку и используют деплой с рестартом/инвалидацией

#### 4. Что даёт OPcache
* сильно снижает CPU на парсинг/компиляцию
* ускоряет отклик
* особенно заметно на больших Symfony/Laravel проектах

#### 5. Типовые нюансы
* Если OPcache не проверяет изменения, после деплоя нужен рестарт PHP-FPM/инвалидация.
* При нехватке памяти: “cache full” → падение эффективности (частые вытеснения).
* OPcache — не кеш результата выполнения, а кеш компиляции.
</details>

---
### 20. Что такое JIT и как он работает?

<details>
<summary>Раскрыть:</summary>

**JIT (Just-In-Time compiler)** — механизм, который **во время выполнения** может компилировать часть opcode в **машинный код**, чтобы ускорить выполнение.

В PHP JIT появился в PHP 8 (как часть OPcache).

#### 1. Как это работает концептуально
1) PHP компилирует скрипт в opcode (как обычно).
2) JIT анализирует горячие участки (часто выполняемые).
3) Эти участки могут быть скомпилированы в машинный код.
4) Повторные выполнения идут быстрее.

#### 2. Где JIT реально помогает
Лучше всего — в “CPU-bound” задачах:
* численные вычисления
* обработка больших массивов данных
* алгоритмы, криптография (частично), парсеры, вычисления

В типичных веб-приложениях (Symfony/Laravel), где основное время:
* БД
* сеть
* сериализация
* IO
  — JIT часто даёт **небольшой эффект**.

#### 3. JIT vs OPcache (важно)
* **OPcache** кеширует *opcode* (убирает компиляцию на каждый запрос).
* **JIT** ускоряет *выполнение* opcode, компилируя “горячее” в машинный код.

#### 4. Риски и нюансы
* JIT потребляет память и может усложнить профилирование.
* Не всегда ускоряет веб, иногда эффект близок к нулю.
* В проде включают осознанно, после измерений (benchmarks/profiling).

#### 5. Как “правильно” рассказывать на собесе
* OPcache — must-have почти всегда.
* JIT — опционально, помогает в вычислениях, не магическая кнопка ускорения API.
</details>

---
### 21. Зачем нужно ключевое слово final?

<details>
<summary>Раскрыть:</summary>

`final` в PHP используется, чтобы **запретить наследование** от класса или **переопределение** конкретного метода.

#### 1. `final class` — запрет наследования
```php
final class Money {
    public function __construct(public int $amount) {}
}
```
* Никто не сможет сделать `class MyMoney extends Money {}`.
* Полезно, когда класс — законченная единица, которую нельзя безопасно расширять.

#### 2. `final method` — запрет переопределения метода
```php
class BaseService {
    final public function execute(): void {
        $this->validate();
        $this->handle();
    }

    protected function validate(): void {}
    protected function handle(): void {}
}
```
* `execute()` нельзя переопределить, но можно переопределять “хуки” (`validate`, `handle`).
* Это часто используется в паттерне **Template Method**.

#### 3. Зачем применять `final`
* **Безопасность инвариантов**: запрещаем ломать правила домена через наследование.
* **Ясный API**: класс/метод “не для расширения”.
* **Проще поддерживать**: меньше неожиданных наследников и side effects.
* **Оптимизации**: теоретически рантайм может оптимизировать вызовы, но обычно это не главный мотив.

#### 4. Когда не стоит злоупотреблять
* Если библиотека/фреймворк предполагает расширяемость через наследование.
* Если проект использует наследование как основной механизм расширения (хотя предпочтительнее композиция).

#### 5. Практическая рекомендация
В современных проектах часто:
* доменные value-objects/DTO делают `final`
* сервисы и хендлеры тоже часто `final`
* расширяемость достигается через **интерфейсы + DI** вместо наследования
</details>

---
### 22. Что нового в PHP 7 и PHP 8?

<details>
<summary>Раскрыть:</summary>

#### PHP 8 (8.0+): основные изменения
##### 1. Named arguments
```php
foo(b: 2, a: 1);
```

##### 2. Attributes
```php
#[Route('/api')]
public function index() {}
```

##### 3. Union types
```php
function f(int|string $x): int|string {}
```

##### 4. Match expression
```php
$res = match($type) {
  'a' => 1,
  'b' => 2,
  default => 0,
};
```

##### 5. Nullsafe operator
```php
$name = $user?->profile?->name;
```

##### 6. Constructor property promotion
```php
public function __construct(
  private int $id,
  private string $email
) {}
```

##### 7. JIT (через OPcache)
* может ускорять CPU-bound задачи, но обычно умеренно влияет на веб.

##### 8. Более строгие ошибки
* много warning/notice стали исключениями/фаталами → лучше качество кода, но возможны breaking changes.

---

#### Как правильно отвечать на собесе
* PHP 7: производительность + типизация.
* PHP 8: удобные фичи (attributes/match/union/nullsafe) + строгий рантайм.
* Для веба чаще важнее архитектура, БД/IO и OPcache, чем JIT.
</details>

---
### 23. SOLID, DRY, KISS, YAGNI.

<details>
<summary>Раскрыть:</summary>

Это базовые принципы проектирования кода, которые помогают писать поддерживаемые системы.

#### 1. SOLID

##### S — Single Responsibility Principle
* Класс имеет одну ответственность и одну причину для изменений.

##### O — Open/Closed Principle
* Расширяем функциональность без изменения существующего кода (через интерфейсы/стратегии/декораторы).

##### L — Liskov Substitution Principle
* Наследники должны быть взаимозаменяемы без нарушения контрактов.

##### I — Interface Segregation Principle
* Много маленьких интерфейсов лучше, чем один огромный.

##### D — Dependency Inversion Principle
* Зависим от абстракций, а не от конкретных классов (DI, интерфейсы).

---

#### 2. DRY (Don’t Repeat Yourself)
* Не повторяем бизнес-правила/знания в разных местах.
* Важно не “вынести всё в абстракции”, а удерживать баланс.

---

#### 3. KISS (Keep It Simple)
* Решение должно быть максимально простым, без лишней магии.

---

#### 4. YAGNI (You Aren’t Gonna Need It)
* Не добавляем функциональность “на будущее”, если её нет в требованиях сейчас.

---

#### 5. Практика
* SOLID помогает строить слои (Controller → Service/UseCase → Repository).
* DRY снижает дублирование бизнес-логики.
* KISS/YAGNI защищают от оверинжиниринга.
</details>

---
### 24. Паттерны проектирования, с которыми приходилось работать.

<details>
<summary>Раскрыть:</summary>

На собеседовании лучше перечислять паттерны через “проблема → решение → где применял”.

#### 1. Creational
* **Factory / Abstract Factory** — создание объектов без привязки к конкретным классам.
* **Builder** — сборка сложных объектов/DTO шаг за шагом.
* **Prototype** — создание через клонирование.
* **Singleton** — встречается, но часто считают антипаттерном в приложениях.

#### 2. Structural
* **Adapter** — адаптация внешнего API/SDK к внутреннему интерфейсу.
* **Decorator** — добавление поведения (кеш/логирование) без наследования.
* **Facade** — простой интерфейс к сложной подсистеме.
* **Proxy** — проксирование вызовов (кеш, lazy, remote calls).

#### 3. Behavioral
* **Strategy** — выбор алгоритма (комиссии, правила).
* **Observer / Event Dispatcher** — события (Symfony events, Doctrine subscribers).
* **Command** — действие как объект (handlers, async jobs).
* **Chain of Responsibility** — цепочка обработчиков (middleware).
* **Template Method** — общий алгоритм + переопределяемые шаги.

#### 4. Примеры “из жизни”
* Middleware (PSR-15) → Chain of Responsibility.
* CacheTagHelper/кеширование поверх репозитория → Decorator/Proxy.
* Разные способы расчёта комиссии → Strategy.
</details>

---
### 25. Что такое простая фабрика?

<details>
<summary>Раскрыть:</summary>

**Простая фабрика (Simple Factory)** — практический приём: класс/метод, который **создаёт нужную реализацию** по параметру.

#### 1. Зачем нужна
* убирает `new` из бизнес-логики
* централизует выбор реализаций
* упрощает тестирование и поддержку

#### 2. Пример
```php
interface NotifierInterface {
    public function send(string $msg): void;
}

final class EmailNotifier implements NotifierInterface {
    public function send(string $msg): void {}
}

final class SmsNotifier implements NotifierInterface {
    public function send(string $msg): void {}
}

final class NotifierFactory {
    public static function make(string $type): NotifierInterface
    {
        return match ($type) {
            'email' => new EmailNotifier(),
            'sms'   => new SmsNotifier(),
            default => throw new InvalidArgumentException('Unknown notifier type'),
        };
    }
}
```

#### 3. Плюсы
* простота
* быстро внедряется
* уменьшает дублирование создания объектов

#### 4. Минусы
* фабрика может вырасти в большой `switch/match` (нарушение OCP)
* при росте вариантов лучше:
  * DI container + autowiring
  * registry стратегий
  * factory method / abstract factory

#### 5. “Middle” формулировка
* “Simple Factory — это централизованное создание объектов по входному параметру. Удобно на старте, но при расширении лучше уходить в DI/стратегии, чтобы не разрастался switch.”
</details>

---
### 26. Что такое Service Layer и где его стоит применять?

<details>
<summary>Раскрыть:</summary>

**Service Layer** — это слой приложения, который содержит **бизнес-операции (use-cases)** и координирует работу домена и инфраструктуры.  
Его задача — держать “командную” логику в одном месте, а контроллеры/CLI/консоль — максимально тонкими.

#### 1. Что делает Service Layer
* принимает входные данные (DTO/команда)
* валидирует/нормализует (или вызывает валидатор)
* вызывает доменные сущности/доменные сервисы
* работает с репозиториями/транзакциями
* публикует события/интеграции (очередь, email, webhook)
* возвращает результат (DTO/ResponseModel)

#### 2. Что НЕ должен делать Service Layer
* не должен знать про HTTP/Request/Response (это ответственность контроллера)
* не должен содержать SQL/ORM-детали напрямую (лучше репозитории)
* не должен превращаться в “God Service” (слишком много обязанностей)

#### 3. Типичный пример структуры (упрощённо)
* Controller (Infrastructure) → вызывает
* Application Service / UseCase (Service Layer) → использует
* Domain (Entities, ValueObjects, Domain Services)
* Infrastructure (Repositories, HTTP clients, Cache, Queue)

#### 4. Пример (идея)
```php
final class CreateUserService
{
    public function __construct(
        private UserRepositoryInterface $users,
        private PasswordHasherInterface $hasher
    ) {}

    public function handle(CreateUserCommand $cmd): UserDto
    {
        $user = User::register($cmd->email, $this->hasher->hash($cmd->password));
        $this->users->save($user);

        return UserDto::fromEntity($user);
    }
}
```

#### 5. Где применять
* когда есть **несколько точек входа** (HTTP, CLI, cron, message bus) к одной логике
* когда бизнес-операции сложные и не должны жить в контроллере
* когда нужен чистый DDD/слоистая архитектура

#### 6. Плюсы
* тонкие контроллеры
* тестируемость (unit-тесты сервисов)
* переиспользуемость use-case
* лучшее разделение ответственности

#### 7. Минусы/ошибки
* можно “раздуть” слой, если нет границ
* чрезмерная абстракция в маленьких проектах (YAGNI)
</details>

---
### 27. Singleton: как устроен и почему является антипаттерном.

<details>
<summary>Раскрыть:</summary>

**Singleton** — паттерн, который гарантирует, что у класса будет **только один экземпляр** и предоставляет глобальную точку доступа к нему.

#### 1. Как устроен (классический вариант)
```php
final class Config
{
    private static ?self $instance = null;

    private function __construct() {}
    private function __clone() {}
    public function __wakeup() { throw new \RuntimeException('No'); }

    public static function getInstance(): self
    {
        return self::$instance ??= new self();
    }
}
```

#### 2. Почему в приложениях его часто считают антипаттерном
* **Скрытые зависимости**: класс в любом месте кода может дернуть Singleton, DI не видно.
* **Глобальное состояние**: сложно контролировать и тестировать.
* **Сложные тесты**: трудно подменять реализацию (моки), состояние “течёт” между тестами.
* **Нарушение SRP/DIP**: класс сам управляет своим жизненным циклом и доступом.
* **Проблемы с параллелизмом/конкурентностью** в некоторых сценариях.

#### 3. Чем заменить в современных проектах
* **DI container** (Symfony Container) — один shared-сервис = “singleton по контейнеру”, но без глобального доступа
* **Интерфейсы** + конфигурации
* **Factory / Provider** для управляемого создания
* **Static config** — только там, где действительно безопасно и нужно

#### 4. Когда Singleton допустим
* очень ограниченно: глобальные константные данные, которые не меняются
* внутренние механизмы языка/расширений (не бизнес-уровень)
  Но в большинстве бизнес-приложений лучше DI.
</details>

---
### 28. Что такое идемпотентность?

<details>
<summary>Раскрыть:</summary>

**Идемпотентность** — свойство операции, при котором **повторное выполнение** (один или много раз) приводит к **тому же состоянию**, что и одно выполнение.

#### 1. Идемпотентность в HTTP
Идемпотентные методы:
* **GET** — не меняет состояние
* **PUT** — устанавливает состояние ресурса
* **DELETE** — удаление (повторный delete не меняет итог)
* **HEAD** — как GET без тела

Неидемпотентный:
* **POST** — обычно создаёт новый ресурс каждый раз

#### 2. Пример
```http
PUT /users/1
{ "name": "Ihor" }
```
Если отправить 5 раз — пользователь всё равно будет “Ihor”.

А вот:
```http
POST /users
{ "name": "Ihor" }
```
5 раз → может создать 5 пользователей.

#### 3. Идемпотентность в бизнес-операциях
Иногда нужно сделать POST идемпотентным:
* платежи
* создание заявок
* отправка уведомлений

Обычно решают через **Idempotency-Key**:
* клиент присылает уникальный ключ
* сервер хранит результат по ключу и возвращает тот же ответ при повторе

#### 4. Зачем это важно
* сеть ненадёжна, ретраи неизбежны
* балансировщики/клиенты могут повторять запрос
* идемпотентность предотвращает двойные платежи/создания
</details>

---
### 29. Жизненный цикл HTTP-запроса.

<details>
<summary>Раскрыть:</summary>

Это “путь” запроса от браузера/клиента до приложения и обратно.

#### 1. Клиент формирует запрос
* URL, метод, заголовки, тело
* cookies, auth headers

#### 2. DNS
* домен → IP (кеш браузера/ОС/резолвер)

#### 3. Соединение
* TCP handshake
* TLS handshake (если HTTPS)
* возможен HTTP/2 или HTTP/3

#### 4. Запрос попадает на web-server
* nginx / apache принимает соединение
* проверка правил (location, rewrite)
* статика отдаётся сразу или проксируется дальше

#### 5. Передача в приложение
Для PHP обычно:
* nginx → **PHP-FPM** (FastCGI) → PHP runtime → framework (Symfony/Laravel)

#### 6. Обработка в приложении
* Routing → Controller
* Middleware/Kernel events
* Service Layer / UseCase
* DB/Cache/HTTP calls
* формирование ответа

#### 7. Ответ клиенту
* статус (200/201/400/500)
* headers (cache-control, content-type, set-cookie)
* body (HTML/JSON)

#### 8. На стороне клиента
* браузер рендерит HTML/CSS/JS или клиент обрабатывает JSON
* кеширование и повторные запросы (ETag, If-Modified-Since)

#### 9. Где чаще всего “узкие места”
* DB (запросы, индексы)
* внешние API
* сериализация больших ответов
* отсутствие кеша / неправильно настроенный кеш
* медленный TLS/сеть при большом трафике
</details>

---
### 30. Что такое куча и стек?

<details>
<summary>Раскрыть:</summary>

Это две базовые области памяти, которые используются программой по-разному.

#### 1. Стек (Stack)
Стек — это область памяти для:
* локальных переменных функций
* параметров вызова
* адресов возврата
* кадров стека (stack frames)

Особенности:
* работает по принципу **LIFO** (последний вошёл — первый вышел)
* очень быстрый (выделение/освобождение)
* ограничен по размеру → возможен **stack overflow** при глубокой рекурсии

Пример: глубокая рекурсия в PHP может привести к ошибкам/лимитам.

#### 2. Куча (Heap)
Куча — это область памяти для:
* объектов
* больших структур данных
* данных с “непредсказуемым” временем жизни

Особенности:
* управление памятью сложнее
* освобождение происходит через сборщик мусора (GC) / reference counting (в PHP)

#### 3. Как это связано с PHP
* Переменные в PHP — это zval структуры, а объекты обычно живут в куче.
* PHP использует **reference counting + cycle collector** (GC) для циклических ссылок.
* Стек используется для вызовов функций, но сам PHP-уровень скрывает детали.

#### 4. Важные практические последствия
* бесконтрольная рекурсия → проблемы со стеком
* циклические ссылки в объектах → может потребоваться GC
* большие массивы/объекты → давление на кучу и память
</details>

---
### 31. Что такое рефлексия?

<details>
<summary>Раскрыть:</summary>

**Рефлексия** — это механизм, который позволяет программе **исследовать свою структуру во время выполнения**:
* какие есть классы/методы/свойства
* какие типы параметров
* какие атрибуты (attributes)
* какие модификаторы доступа (public/protected/private)

В PHP это реализовано через набор классов `Reflection*` (ReflectionClass, ReflectionMethod, и т.д.).

#### 1. Зачем нужна рефлексия
* **DI-контейнеры** (Symfony) — автосвязывание зависимостей по типам.
* **ORM/Serializer** — чтение метаданных, аннотаций/атрибутов.
* **Автогенерация документации** (OpenAPI).
* **Тестирование** — доступ к приватным методам/свойствам в редких случаях.
* **Фреймворки** — роутинг, middleware, атрибуты.

#### 2. Пример: узнать методы класса
```php
$ref = new ReflectionClass(UserService::class);

foreach ($ref->getMethods() as $method) {
    echo $method->getName() . PHP_EOL;
}
```

#### 3. Пример: получить атрибуты (PHP 8+)
```php
#[Attribute]
class Route {
    public function __construct(public string $path) {}
}

final class Controller {
    #[Route('/users')]
    public function list() {}
}

$refMethod = new ReflectionMethod(Controller::class, 'list');
$attrs = $refMethod->getAttributes(Route::class);

$route = $attrs[0]->newInstance();
echo $route->path; // /users
```

#### 4. Минусы рефлексии
* медленнее, чем прямые вызовы (обычно не критично, но важно)
* повышает “магичность” кода и может усложнить отладку
* может ломать инкапсуляцию (если использовать для доступа к private)

#### 5. Как звучит “Middle” ответ
* “Рефлексия — это интроспекция структуры кода во время выполнения. В PHP она используется в DI, ORM, сериализации и атрибутах, но нужно помнить про накладные расходы и не злоупотреблять.”
</details>

---
### 32. Что такое хеш-функция и где она используется?

<details>
<summary>Раскрыть:</summary>

**Хеш-функция** — это функция, которая преобразует данные произвольной длины в строку фиксированной длины (хеш).  
Хеш обычно выглядит как набор символов (hex/base64) и используется для быстрого сравнения/поиска и контроля целостности.

#### 1. Основные свойства хеш-функций
* **Детерминированность**: одинаковый вход → одинаковый хеш.
* **Быстрота вычисления**.
* **Лавинный эффект**: малое изменение входа сильно меняет хеш.
* **Коллизии возможны**, но качественные функции делают их очень редкими.

#### 2. Криптографические vs некриптографические
**Криптографические** (SHA-256, SHA-512):
* устойчивы к подбору, коллизиям (на практике)
* используются в безопасности и целостности

**Некриптографические** (CRC32, MurmurHash):
* быстрые, но не для безопасности
* используются в хеш-таблицах, шардировании

#### 3. Где используют хеши
* **Пароли**: хранить не пароль, а хеш + salt  
  ⚠️ Важно: для паролей используют специальные функции (`password_hash`) — не просто SHA.
* **Подписи запросов** (HMAC) — защита от подмены.
* **Проверка целостности** файлов/данных (checksum).
* **Кеш-ключи**: md5/sha от параметров запроса.
* **Индексация/хеш-таблицы**: быстрый доступ к данным.
* **Дедупликация**: найти одинаковые файлы по хешу.

#### 4. Пример: пароли в PHP (правильно)
```php
$hash = password_hash($password, PASSWORD_ARGON2ID);

if (password_verify($password, $hash)) {
    // ok
}
```

#### 5. Пример: HMAC подпись
```php
$signature = hash_hmac('sha256', $payload, $secret);
```
</details>

---
### 33. Как используются очереди в PHP?

<details>
<summary>Раскрыть:</summary>

**Очереди** используют, чтобы выполнять задачи **асинхронно** и разгружать основной поток обработки запроса.

Идея:
* веб-запрос должен быть быстрым
* тяжёлые операции отправляем в background

#### 1. Типичные кейсы
* отправка email/SMS
* генерация отчётов, экспорт CSV/PDF
* обработка изображений
* интеграции (webhooks, сторонние API)
* перерасчёты, миграции данных
* обработка событий из других сервисов

#### 2. Архитектура: Producer → Broker → Consumer
##### Producer (продьюсер)
* приложение кладёт сообщение в очередь (job/event)

##### Broker (брокер)
* RabbitMQ / Redis Streams / Kafka / SQS

##### Consumer (воркер)
* отдельный процесс/контейнер читает очередь и выполняет задачу

#### 3. Важные понятия
* **At-least-once delivery** — сообщение может прийти повторно → обработка должна быть идемпотентной.
* **Retry** — повторная попытка при ошибке.
* **DLQ (dead-letter queue)** — очередь для “упавших” сообщений.
* **Visibility timeout / ack** — подтверждение успешной обработки.

#### 4. Как это выглядит в PHP (концептуально)
* Symfony Messenger (AMQP/Redis)
* Laravel Queue (Redis/RabbitMQ/SQS)
* Свой consumer на основе php-amqplib

Пример “идея”:
```php
// producer
$bus->dispatch(new SendEmailMessage($userId));
```

#### 5. Практические советы
* Делать jobs **идемпотентными** (особенно при ретраях).
* Логировать correlation id, trace id.
* Ограничивать память воркеров, перезапускать по лимитам.
* Метрики: время обработки, размер очереди, ошибки.
</details>

---
### 34. Как в общих чертах работает OPcache?

<details>
<summary>Раскрыть:</summary>

**OPcache** — механизм PHP, который кеширует **скомпилированные opcode** в shared memory, чтобы не компилировать PHP-файлы на каждом запросе.

#### 1. Что происходит без OPcache
На каждый запрос:
1) читается файл PHP
2) парсится код
3) компилируется в opcode
4) выполняется

Это дорого по CPU.

#### 2. Что меняет OPcache
##### Первый запрос к файлу
* PHP компилирует файл в opcode
* кладёт opcode в общий кеш (shared memory)

##### Следующие запросы
* opcode берётся из OPcache
* парсинг/компиляция пропускаются
* остаётся только выполнение

#### 3. Почему OPcache важен для веба
* снижает CPU
* уменьшает latency
* особенно заметно на больших фреймворках (Symfony/Laravel)

#### 4. Важные настройки (по смыслу)
* размер памяти OPcache
* количество файлов
* проверка обновления файлов:
  * dev: проверять часто
  * prod: лучше деплой + рестарт/инвалидация, без постоянных проверок

#### 5. Нюансы
* OPcache не кеширует результаты выполнения — только компиляцию.
* Если кеш переполнен, эффективность падает (вытеснения).
* При деплое без проверки изменений нужен рестарт PHP-FPM или сброс кеша.
</details>

---
### 35. Что такое GRASP?

<details>
<summary>Раскрыть:</summary>

**GRASP (General Responsibility Assignment Software Patterns)** — набор принципов/паттернов, которые помогают **правильно распределять ответственность** между объектами.

Это не “классические” GoF паттерны, а скорее гайд по дизайну.

#### 1. Зачем нужен GRASP
* уменьшить связанность
* повысить переиспользуемость
* улучшить читаемость и тестируемость
* избежать “God object”

#### 2. Основные принципы GRASP (что важно знать)
##### 1) Information Expert (Информационный эксперт)
* ответственность даётся тому классу, у которого есть нужные данные  
  Пример: `Order` считает total, потому что у него есть позиции.

##### 2) Creator (Создатель)
* объект должен создавать другой объект, если:
  * он агрегирует его
  * содержит/управляет им
  * имеет данные для его создания

##### 3) Controller
* выделение контроллера как точки входа (не UI-контроллер, а use-case контроллер)
* принимает запрос и делегирует домену/сервисам

##### 4) Low Coupling
* минимизировать зависимости между классами

##### 5) High Cohesion
* класс должен быть сфокусирован на своей задаче, без разнородных обязанностей

##### 6) Polymorphism
* использовать полиморфизм вместо `if/switch` по типам (стратегии, интерфейсы)

##### 7) Indirection
* добавлять промежуточные слои (например, сервис/фасад), чтобы снизить связанность

##### 8) Protected Variations
* защищать систему от изменений через стабильные интерфейсы/абстракции

#### 3. Как применить в “middle” объяснении
* “GRASP помогает распределять ответственность: высокое сцепление, низкая связанность, эксперт, контроллер, полиморфизм. Это как набор правил, как правильно строить объектную модель.”
</details>

---
### 36. Что такое TDD?

<details>
<summary>Раскрыть:</summary>

**TDD (Test-Driven Development)** — подход к разработке, при котором код пишется **через тесты**.  
Классический цикл: **Red → Green → Refactor**.

#### 1. Цикл TDD (Red → Green → Refactor)
##### 1) Red
* Пишем тест на новую функциональность.
* Запускаем — тест падает (функциональности ещё нет).

##### 2) Green
* Пишем минимальный код, чтобы тест прошёл.
* Главное — сделать тест зелёным, без идеальной архитектуры.

##### 3) Refactor
* Улучшаем код (чистота, структура, SOLID), сохраняя тесты зелёными.

#### 2. Зачем TDD
* помогает уточнить требования (тест = спецификация)
* снижает количество регрессий
* улучшает дизайн (код становится более модульным)
* ускоряет рефакторинг (есть “страховка”)

#### 3. Виды TDD на практике
* “Классический” — с unit-тестами.
* “Outside-in / BDD” — от сценария/контракта (feature) к деталям.
* В реальности часто используют “semi-TDD”: пишут тесты параллельно с кодом.

#### 4. Минусы / ограничения
* требует дисциплины и времени в начале
* сложно применять к legacy-коду без тестов (нужны seams)
* не все вещи удобно тестировать на unit-уровне (интеграции)

#### 5. Как звучит хороший ответ на собесе
* “TDD — это цикл red-green-refactor: сначала тест, потом минимальная реализация, потом рефакторинг. Это повышает качество, ускоряет безопасные изменения и улучшает дизайн, но требует дисциплины и разумного баланса с интеграционными тестами.”
</details>

---
### 37. Чем отличаются модульные тесты от интеграционных?

<details>
<summary>Раскрыть:</summary>

**Unit-тесты (модульные)** проверяют **маленькую единицу** (функцию/класс) в изоляции.  
**Интеграционные** проверяют работу **нескольких компонентов вместе** (например, сервис + БД).

#### 1. Unit (модульные) тесты
* Тестируют один класс/метод.
* Зависимости обычно мокают/стабят.
* Быстрые, запускаются часто.
* Хорошо ловят логические ошибки.

Пример: тест сервиса с mocked repository.

#### 2. Интеграционные тесты
* Поднимают реальные зависимости:
  * БД (MySQL/PostgreSQL)
  * кеш (Redis)
  * файловую систему
  * HTTP-клиент (иногда с test-server)
* Медленнее, сложнее в настройке.
* Ловят ошибки интеграции: миграции, конфиги, SQL, маппинги.

#### 3. Ключевые отличия (коротко)
* **Изоляция**: unit — да, интеграция — нет
* **Скорость**: unit быстрее
* **Достоверность окружения**: интеграция ближе к продакшну
* **Сложность поддержки**: интеграция сложнее

#### 4. Как правильно выстраивать пирамиду тестов
* много unit-тестов (быстро и дёшево)
* меньше интеграционных (важно, но дороже)
* ещё меньше e2e/functional (самые дорогие)

#### 5. Practical tip
* Unit хорошо проверяет бизнес-правила.
* Интеграционные обязательно нужны для:
  * Doctrine mapping
  * реальные SQL запросы
  * транзакции, миграции
  * кеш-инвалидация
</details>

---
### 38. Что такое трейты и как применять их на практике?

<details>
<summary>Раскрыть:</summary>

**Trait** — механизм повторного использования кода в PHP (аналог “миксина”).  
Trait позволяет “вмешать” методы/свойства в класс **без наследования**.

#### 1. Зачем нужны traits
* переиспользование общей логики в разных классах
* альтернатива множественному наследованию (которого в PHP нет)

#### 2. Пример trait
```php
trait TimestampableTrait
{
    private \DateTimeImmutable $createdAt;
    private \DateTimeImmutable $updatedAt;

    public function touch(): void {
        $this->updatedAt = new \DateTimeImmutable();
    }
}
```

Использование:
```php
final class User
{
    use TimestampableTrait;
}
```

#### 3. Где traits полезны
* общие инфраструктурные вещи:
  * timestamps (createdAt/updatedAt)
  * soft-delete
  * логирование
  * небольшие helper-методы
* в Doctrine Entity часто применяют traits для повторяющихся полей

#### 4. Минусы traits (важно на собесе)
* могут ухудшать читаемость (методы “появляются” неявно)
* риск конфликтов имён
* легко превратить в “свалку” логики, нарушая SRP

#### 5. Рекомендации
* trait должен быть маленьким и сфокусированным
* не смешивать бизнес-логику домена в “общие” traits
* для поведения чаще лучше композиция (объекты/сервисы), чем trait
</details>

---
### 39. Как решать конфликты при использовании trait?

<details>
<summary>Раскрыть:</summary>

Конфликт возникает, когда:
* два trait содержат метод с одинаковым именем
* или класс и trait имеют одинаковый метод

PHP даёт инструменты:
* `insteadof` — выбрать, какой метод использовать
* `as` — сделать алиас (переименовать метод)

#### 1. Пример конфликта двух traits
```php
trait A {
    public function foo(): string { return 'A'; }
}

trait B {
    public function foo(): string { return 'B'; }
}
```

Исправление:
```php
final class C
{
    use A, B {
        A::foo insteadof B; // берём foo из A
        B::foo as fooFromB; // алиас для foo из B
    }
}
```

Теперь:
```php
$c = new C();
$c->foo();       // A
$c->fooFromB();  // B
```

#### 2. Конфликт trait vs класс
* метод класса имеет приоритет над методом trait
* метод trait имеет приоритет над методом родительского класса

#### 3. Практические советы
* избегать больших traits
* давать уникальные имена методам
* если конфликтов много — возможно, trait не подходит, лучше композиция
</details>

---
### 40. Как работает автозагрузка классов?

<details>
<summary>Раскрыть:</summary>

**Автозагрузка (autoload)** — механизм, который подгружает PHP-класс **в момент первого обращения** к нему, без ручных `require/include`.

В современном PHP это почти всегда делается через **Composer autoload** и стандарт **PSR-4**.

#### 1. Идея PSR-4
Namespace соответствует директории.

Пример настройки в `composer.json`:
```json
{
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  }
}
```

Это значит:
* `App\Service\UserService` → `src/Service/UserService.php`

#### 2. Как это работает (в общем)
1) В проекте подключён `vendor/autoload.php`.
2) Когда PHP встречает неизвестный класс:
  * вызывается зарегистрированная функция автозагрузки
3) Composer по правилам PSR-4 строит путь к файлу.
4) Если файл найден — подключает его.

#### 3. Почему это важно
* нет ручного require
* стандартизированная структура проекта
* совместимость библиотек

#### 4. Полезные команды Composer
* после изменения автозагрузки:
```bash
composer dump-autoload
```

#### 5. Нюансы
* В больших проектах используют оптимизацию:
  * classmap / authoritative classmap
  * opcache + preload
* Ошибки часто из-за:
  * неправильного namespace
  * неправильного пути/регистра букв
  * забыли `composer dump-autoload`
</details>

---
### 41. Разница между стеком и очередью.

<details>
<summary>Раскрыть:</summary>

Стек и очередь — это структуры данных, которые отличаются **порядком извлечения элементов**.

#### 1. Стек (Stack) — LIFO
* **Last In, First Out**: последний добавленный выходит первым.
* Операции:
  * `push` — добавить
  * `pop` — достать последний
  * `peek/top` — посмотреть последний

Пример:
* добавили: 1, 2, 3
* достали: 3, 2, 1

Где используется:
* стек вызовов функций
* undo/redo
* парсинг выражений
* обход графов/деревьев (DFS)

#### 2. Очередь (Queue) — FIFO
* **First In, First Out**: первый добавленный выходит первым.
* Операции:
  * `enqueue` — добавить в конец
  * `dequeue` — достать из начала
  * `front` — посмотреть первый

Пример:
* добавили: 1, 2, 3
* достали: 1, 2, 3

Где используется:
* очереди задач (jobs)
* обработка событий
* планировщики
* сетевые буферы
* обход графов (BFS)

#### 3. Практический “middle” вывод
* стек — для вложенности/обратного порядка
* очередь — для справедливой обработки по порядку поступления
* в асинхронных системах чаще нужен FIFO (очереди задач)
</details>

---
### 42. Unit и Functional тесты. Моки и стабы в PHP.

<details>
<summary>Раскрыть:</summary>

#### 1. Unit tests
Unit-тесты проверяют **маленький кусок логики** (класс/метод) в изоляции.
* зависимости подменяются моками/стабами
* быстрые
* легко запускать постоянно

Пример: тестируем `FeeCalculator`, мокаем `RateProvider`.

#### 2. Functional tests
Functional-тесты проверяют **поведение фичи** ближе к реальности:
* часто поднимается контейнер Symfony
* реальный роутинг, контроллер, сериализация
* могут использовать тестовую БД или фикстуры
* медленнее, но ловят “стыковые” ошибки

В Symfony это обычно:
* `WebTestCase` / `KernelTestCase`
* запросы через test client

#### 3. Моки и стабы: отличия
**Stub**:
* возвращает заранее подготовленные данные
* не проверяет, “как” его вызывали

**Mock**:
* может возвращать данные
* плюс проверяет взаимодействие: вызовы, аргументы, количество

#### 4. Пример (идея PHPUnit)
```php
$repo = $this->createMock(UserRepository::class);

$repo->expects($this->once())
    ->method('save')
    ->with($this->isInstanceOf(User::class));
```

#### 5. Где что использовать
* unit: бизнес-правила, алгоритмы, use-case логика
* functional: API endpoints, интеграция контейнера, сериализация/валидаторы
* интеграционные: БД, doctrine mapping, кеш, очереди

#### 6. Типичные ошибки
* слишком много моков → тест “зависит от реализации”, ломается при рефакторинге
* отсутствие интеграционных тестов → проблемы с ORM/SQL всплывают поздно
* functional тесты без чистой тестовой среды → флейки (нестабильные) тесты
</details>

---
### 43. Как вызвать приватный метод (гипотетическая ситуация)?

<details>
<summary>Раскрыть:</summary>

В нормальной архитектуре приватные методы **не вызывают напрямую** — тестируют публичное поведение.  
Но если это “гипотетическая” ситуация, есть варианты.

#### 1. Правильный подход (рекомендуется)
* не тестировать private напрямую
* тестировать через public API (behavior)
* если private сложный — вынести логику в отдельный класс/сервис и тестировать его

#### 2. Reflection (как “последний вариант”)
```php
$ref = new ReflectionClass(MyClass::class);
$method = $ref->getMethod('privateMethod');
$method->setAccessible(true);

$obj = new MyClass();
$result = $method->invoke($obj, $arg1, $arg2);
```

Минусы:
* тест становится привязан к реализации
* ломается при рефакторинге
* нарушает инкапсуляцию

#### 3. Closure binding (редко)
```php
$call = function() { return $this->privateMethod(); };
$call = $call->bindTo($obj, $obj);
$call();
```

#### 4. Наследование не поможет
Private-методы не доступны наследникам.

#### 5. Как отвечать на собесе
* “Лучше тестировать public. Если нужно — вынесу private-логику в отдельный сервис. В крайнем случае можно через Reflection, но это костыль.”
</details>

---
### 44. Разница между PHP-FPM и «PHP на сокете».

<details>
<summary>Раскрыть:</summary>

Тут обычно имеют в виду два способа связки веб-сервера и PHP:

#### 1. PHP-FPM (FastCGI Process Manager)
* отдельный процесс-менеджер для PHP
* nginx/apache передают запросы по FastCGI
* FPM управляет пулом воркеров (процессы), перезапусками, лимитами

Плюсы:
* масштабируемость (pool workers)
* стабильность и управление ресурсами
* изоляция от веб-сервера
* стандартный продакшн-выбор для nginx + PHP

#### 2. «PHP на сокете» — что обычно имеют в виду
Чаще всего это один из вариантов:
* **FastCGI через Unix socket** (например `/var/run/php/php-fpm.sock`)
* либо устаревший запуск через CGI (реже)

Если речь про **Unix socket vs TCP**:
* Unix socket — быстрее на одной машине, проще безопасность
* TCP — удобно, если FPM на другом хосте/контейнере

Пример nginx:
```nginx
fastcgi_pass unix:/run/php/php-fpm.sock; # Unix socket
# или
fastcgi_pass 127.0.0.1:9000;            # TCP
```

#### 3. Как объяснить кратко
* PHP-FPM — это менеджер PHP-воркеров.
* «на сокете» — это транспорт, по которому nginx общается с PHP-FPM (unix socket или tcp).
* Чаще в проде nginx + PHP-FPM, а выбор socket/tcp зависит от инфраструктуры.
</details>

---
### 45. Как реализовать загрузку больших отчетов (1GB и более)?

<details>
<summary>Раскрыть:</summary>

Большие отчёты нельзя генерировать и отдавать “в одном HTTP-запросе” обычным способом — упрёмся в таймауты и память.

Правильный подход — **асинхронно + потоково**.

#### 1. Асинхронная генерация (лучший подход)
##### Шаг 1: старт задачи
* API принимает запрос “сгенерировать отчёт”
* создаёт запись “report job” в БД (status = pending)
* отправляет job в очередь (RabbitMQ/Redis/SQS)

##### Шаг 2: worker генерирует файл
* consumer читает job
* генерирует отчёт **потоково** (streaming) в файл (CSV/JSONL)
* сохраняет в объектное хранилище (S3/MinIO) или файловое хранилище
* обновляет статус job (done) и ссылку на файл

##### Шаг 3: скачивание
* клиент дергает endpoint “скачать отчёт”
* сервер отдаёт ссылку или стримит файл (лучше через nginx/X-Accel-Redirect)

#### 2. Потоковая генерация (streaming) — обязательно
Чтобы не держать 1GB в памяти:
* читаем данные батчами (chunking)
* пишем в файл построчно

Пример идеи (CSV):
```php
$fp = fopen($path, 'w');
foreach ($repo->iterateByChunks(1000) as $rows) {
    foreach ($rows as $row) {
        fputcsv($fp, $row);
    }
}
fclose($fp);
```

#### 3. Streaming download
Если нужно отдавать файл напрямую:
* использовать `readfile()`/streams
* отключать буферизацию
* лучше — отдавать через nginx (X-Accel-Redirect), чтобы PHP не тащил 1GB через себя

#### 4. Архитектурные варианты
* CSV/JSONL + gzip (сжатие на лету)
* подготовка отчёта заранее по расписанию (precompute)
* пагинация/фильтрация вместо “всё сразу” (если бизнес позволяет)

#### 5. Важные нюансы
* лимиты времени выполнения и памяти
* ретраи и идемпотентность job
* мониторинг (прогресс/статус)
* очистка старых отчётов (TTL)

#### 6. Как звучит хороший ответ
* “1GB отчёт — это job в очереди + streaming генерация батчами + хранение файла (S3) + скачивание по ссылке/через nginx. В синхронном HTTP это делать нельзя.”
</details>

---
### 46. Как импортировать 50GB XML в базу данных?

<details>
<summary>Раскрыть:</summary>

Импорт 50GB XML нельзя делать “в лоб” через `simplexml_load_file()` — упадёшь по памяти/времени. Нужен **стриминг + батчи + контроль транзакций**.

#### 1. Общая стратегия
**Цель:** читать XML потоково, доставать нужные элементы, писать в БД пакетами.

Основные принципы:
* **Streaming parser**: `XMLReader` (pull-парсер) или SAX.
* **Chunk/batch**: вставки пачками (например, 500–5000 строк).
* **Транзакции**: коммитить по пачкам, не держать одну транзакцию на 50GB.
* **Минимум индексов во время импорта**: по возможности отключить/снять индексы и создать после.
* **Staging table**: сначала в “сырую” таблицу, потом нормализация/merge.

#### 2. Вариант А: XMLReader + батч-вставки (типовой)
```php
$reader = new XMLReader();
$reader->open($file);

$batch = [];
$batchSize = 1000;

while ($reader->read()) {
    if ($reader->nodeType === XMLReader::ELEMENT && $reader->name === 'item') {
        $xml = $reader->readOuterXML();

        // Парсим только "один item", не весь файл
        $item = simplexml_load_string($xml);

        $batch[] = [
            'id' => (string)$item->id,
            'name' => (string)$item->name,
            // ...
        ];

        if (count($batch) >= $batchSize) {
            insertBatch($batch); // prepared statements / bulk insert
            $batch = [];
        }
    }
}

if ($batch) {
    insertBatch($batch);
}

$reader->close();
```

#### 3. Вариант B: “Преобразовать в CSV → LOAD DATA”
Если XML однотипный, иногда выгодно:
1) потоково распарсить XML и записать в CSV/TSV,
2) затем загрузить в MySQL/PostgreSQL через bulk-loader (`LOAD DATA INFILE` / `COPY`).

Плюс:
* bulk loader обычно быстрее, чем INSERT.

Минус:
* доп. шаг и место на диске.

#### 4. Производительность: что важно сделать
* **Подготовленные запросы** (PDO) и множественные вставки:
  * `INSERT INTO t (...) VALUES (...), (...), (...)`
* **Отключить автокоммит** и делать commit пачками.
* **Временно отключить/отложить индексы** (если возможно).
* **Увеличить буферы/лимиты** (в рамках разумного): innodb_buffer_pool_size, max_allowed_packet.
* **Параллелизм**: если XML можно безопасно разделить (по файлам/диапазонам) — несколько воркеров.

#### 5. Надёжность: контроль ошибок и возобновление
* вести **checkpoint**: позиция/последний обработанный id
* логировать “плохие” записи отдельно (dead-letter file)
* делать import idempotent (upsert / ignore duplicates)

#### 6. Итоговая “правильная” архитектура
* CLI-команда (не HTTP)
* streaming parser
* batch inserts
* staging tables
* метрики/логирование/чекпоинты
</details>

---
### 47. Почему после PHP 5 сразу вышел PHP 7, куда делся PHP 6?

<details>
<summary>Раскрыть:</summary>

“PHP 6” как полноценный релиз **не вышел**, поэтому следующая крупная версия после 5 стала 7.

#### 1. Что планировалось в PHP 6
* Основная большая цель: **полная поддержка Unicode** на уровне ядра/строк.
* Разработка шла отдельной веткой, появлялись патчи и экспериментальные изменения.

#### 2. Почему PHP 6 “не случился”
* Unicode-подход оказался слишком сложным и конфликтным для экосистемы.
* Было много несовместимостей и проблем производительности.
* В итоге ветку фактически “заморозили”, а часть полезных идей/фич постепенно попала в PHP 5.3+.

#### 3. Почему назвали следующую версию PHP 7
* Чтобы не путать людей с существующей “веткой PHP 6” (которую многие видели/упоминали).
* Большой набор изменений производительности/ядра (Zend Engine), поэтому было логично поднять major.
* Итог: “6” пропустили, чтобы избежать путаницы и подчеркнуть новый этап развития.
</details>

---
### 48. Есть ли разница между self и $this в PHP?

<details>
<summary>Раскрыть:</summary>

Да, разница принципиальная.

#### 1. `$this`
* это **текущий объект (экземпляр класса)**.
* доступен **только в нестатическом контексте** (в обычных методах).
* используется для обращения к:
  * свойствам объекта: `$this->prop`
  * методам объекта: `$this->method()`

```php
class A {
    public function foo(): void {
        $this->bar();
    }
    private function bar(): void {}
}
```

#### 2. `self`
* это ссылка на **текущий класс**, в котором написан код.
* используется в статическом контексте:
  * `self::CONST`
  * `self::staticMethod()`

```php
class A {
    public const NAME = 'A';
    public static function name(): string {
        return self::NAME;
    }
}
```

#### 3. Важный нюанс: `self::` vs `static::` (Late Static Binding)
* `self::` привязан к **классу, где объявлен метод**.
* `static::` учитывает **класс, на котором вызвали метод** (позднее статическое связывание).

```php
class A {
    public static function who(): string { return self::class; }
    public static function whoLate(): string { return static::class; }
}
class B extends A {}

echo B::who();     // A
echo B::whoLate(); // B
```

#### 4. Как отвечать на собесе (коротко)
* `$this` — объект, только instance.
* `self` — текущий класс (compile-time binding).
* `static` — late static binding (runtime).
</details>

---
### 49. Что такое PuTTY?

<details>
<summary>Раскрыть:</summary>

**PuTTY** — популярный клиент для удалённых подключений, прежде всего:
* **SSH**
* также исторически поддерживал Telnet, rlogin, serial (в зависимости от сборки)

Чаще всего PuTTY используют (особенно на Windows):
* подключиться по SSH к серверу
* работать в терминале
* хранить профили подключений

#### 1. Что обычно входит в “набор PuTTY”
* **PuTTY** — SSH-клиент (терминал)
* **PuTTYgen** — генератор ключей (RSA/Ed25519 в новых версиях)
* **Pageant** — SSH-agent (хранит ключи в памяти)
* **Plink** — консольный клиент для скриптов/CI

#### 2. Чем похож/отличается от OpenSSH
* По сути решает ту же задачу (SSH).
* На Linux/macOS обычно используют `ssh` из OpenSSH.
* PuTTY удобен интерфейсом и исторически был стандартом в Windows-среде.
</details>

---
### 50. Как запускать важный PHP-файл каждые 20 секунд?

<details>
<summary>Раскрыть:</summary>

Классический cron работает с точностью **в 1 минуту**, поэтому “каждые 20 секунд” делается обходными способами.

#### Вариант 1: cron + sleep (3 запуска в минуту)
В crontab:
```cron
* * * * * /usr/bin/php /app/job.php
* * * * * sleep 20; /usr/bin/php /app/job.php
* * * * * sleep 40; /usr/bin/php /app/job.php
```
Плюс:
* просто и быстро
  Минус:
* нужно следить за временем выполнения (чтобы не налезали процессы)

#### Вариант 2: бесконечный worker под supervisor/systemd
Скрипт:
```bash
while true; do
  /usr/bin/php /app/job.php
  sleep 20
done
```
Запускать как сервис (systemd) или под supervisor.
Плюс:
* лучше контроль рестартов/логов
  Минус:
* нужно правильно настроить monitoring/restart policy

#### Вариант 3: systemd timer (если нужен более “родной” подход)
Systemd timers могут быть гибче cron (но зависит от дистрибутива и настройки).

#### Важные нюансы (обязательно на собесе)
* защита от параллельных запусков:
  * file lock (`flock`)
  * redis lock
  * “unique job” в очереди
* логирование и алерты
* ограничения по памяти/времени
</details>

---
### 51. Как расшифровать права 644 для файла в Linux?

<details>
<summary>Раскрыть:</summary>

Права `644` — это запись в восьмеричной системе (octal) для:
* владельца (user)
* группы (group)
* остальных (others)

#### 1. Раскладка цифр
`6 4 4`

Каждая цифра — сумма:
* `4` — read (r)
* `2` — write (w)
* `1` — execute (x)

#### 2. Расшифровка 6
`6 = 4 + 2` → `rw-`
* владелец: читать и писать

#### 3. Расшифровка 4
`4 = 4` → `r--`
* группа: только читать
* остальные: только читать

#### 4. Итог в виде rwx
`644` → `rw-r--r--`

То есть:
* owner: rw-
* group: r--
* others: r--

#### 5. Команда для установки
```bash
chmod 644 file.txt
```
</details>

---
### 52. Что такое Opcode?

<details>
<summary>Раскрыть:</summary>

**Opcode** — это промежуточный “байткод” (инструкции), в который PHP компилирует исходный код перед выполнением.

#### 1. Как выполняется PHP-код (упрощённо)
1) PHP читает файл
2) парсит и строит AST
3) компилирует в **opcodes**
4) Zend VM выполняет эти opcodes

#### 2. Почему это важно
* На каждый запрос компиляция в opcode — это CPU-затраты.
* **OPcache** кеширует opcodes в общей памяти, поэтому:
  * компиляция делается один раз
  * дальше — берём opcode из кеша и выполняем

#### 3. Opcode ≠ машинный код
* opcode — инструкции виртуальной машины (Zend VM)
* машинный код — это уже то, что выполняет процессор
* JIT (PHP 8) может компилировать часть opcodes в машинный код для ускорения CPU-bound задач

#### 4. Как звучит хороший ответ
* “Opcode — это байткод Zend VM. PHP компилирует скрипт в opcode и исполняет. OPcache кеширует opcode, чтобы не компилировать на каждом запросе.”
</details>

---
