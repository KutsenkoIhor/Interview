

[Наверх](/GubaEvgeniy/e4336f908606d5f7361fb6baf3c19324)

# Junior Database

## Оглавление

1. [Что такое транзакция?](#1-что-такое-транзакция)
2. [Что такое нормализация?](#2-что-такое-нормализация)
3. [Что такое денормализация? Для чего она нужна?](#3-что-такое-денормализации-для-чего-она-нужна)
4. [Какие типы связей в базе данных?](#4-какие-типы-связей-в-базе-данных)
5. [Что означает утверждение о том, что СУБД поддерживает контроль ссылочной целостности связей?](#5-что-означает-утверждение-о-том-что-субд-поддерживает-контроль-ссылочной-целостности-связей)
6. [Если используемая вами СУБД не поддерживает каскадные удаления для поддержки ссылочной целостности связей, что можно сделать для достижения аналогичного результата?](#6-если-используемая-вами-субд-не-поддерживает-каскадные-удаления-для-поддержки-ссылочной-целостности-связей-что-можно-сделать-для-достижения-аналогичного-результата)
7. [Что такое первичный и внешний ключи?](#7-что-такое-первичный-и-внешний-ключи)
8. [Какие различия между первичным и уникальным ключами?](#8-какие-различия-между-первичным-и-уникальным-ключами)
9. [Какие типы JOIN и в чем различия?](#9-какие-типы-join-и-в-чем-различия)
10. [Что такое курсоры в базах данных?](#10-что-такое-курсоры-в-базах-данных)
11. [Что такое агрегатные функции SQL? Приведите несколько примеров.](#11-что-такое-агрегатные-функции-sql-приведите-несколько-примеров)
12. [Что такое миграции?](#12-что-такое-миграции)
13. [Расскажите о связи друг к другу, один ко многим, многие ко многим.](#13-расскажите-о-связи-друг-к-другу-один-ко-многим-многие-ко-многим)
14. [Зачем используют оператор группировки GROUP BY?](#14-зачем-используют-оператор-группировки-group-by)
15. [В чем разница между WHERE и HAVING? Приведите примеры.](#15-в-чем-разница-между-where-и-having-приведите-примеры)
16. [В чем разница между операторами DISTINCT и GROUP BY?](#16-в-чем-разница-между-операторами-distinct-и-group-by)
17. [Для чего нужны операторы UNION, INTERSECT, EXCEPT?](#17-для-чего-нужны-операторы-union-intersect-except)
18. [Опишите разницу типов данных DATETIME и TIMESTAMP](#18-опишите-разницу-типов-данных-datetime-и-timestamp)
19. [Какие вы знаете двигатели таблиц и чем они отличаются?](#19-какие-вы-знаете-двигатели-таблиц-и-чем-они-отличаются)
20. [Какие способы оптимизации производительности баз данных знаете?](#20-какие-способы-оптимизации-производительности-баз-данных-знаете)
21. [Что такое партицирование, репликация и шардинг?](#21-что-такое-партицирование-репликация-и-шардинг)
22. [Чем отличаются SQL от NoSQL базы данных?](#22-чем-отличаются-sql-от-nosql-базы-данных)
23. [Какие типы данных есть в MySQL?](#23-какие-типы-данных-есть-в-mysql)
24. [Разница между JOIN и UNION?](#24-разница-между-join-и-union)
25. [Что такое индексы? Как они влияют на время выполнения SELECT, INSERT?](#25-что-такое-индексы-как-они-влияют-на-время-выполнения-select-insert)
26. [Что такое хранимые процедуры, функции и триггеры в MySQL? Для чего они? Приведите примеры использования.](#26-что-такое-хранимые-процедуры-функции-и-триггеры-в-mysql-для-чего-они-приведите-примеры-использования)
27. [Как организовать сохранность вложенных категорий в MySQL?](#27-как-организовать-сохранность-вложенных-категорий-в-mysql)

---

### 1. Что такое транзакция?
<details>
<summary>Раскрыть:</summary>

**Транзакция** в базах данных — это последовательность операций, которая выполняется как единое целое. Она гарантирует, что все операции либо успешно выполнятся, либо все изменения будут отменены, если произошла ошибка. Транзакции позволяют сохранить целостность и согласованность данных в базе данных.

### Основные свойства транзакции: ACID

Транзакции обладают четырьмя основными свойствами, которые обозначаются как **ACID**:

1. **Atomicity (Атомарность)**:
    - Транзакция выполняется как единое неделимое действие: либо все операции в транзакции выполняются успешно, либо ни одна из них не будет применена. Если что-то пошло не так (например, произошла ошибка при записи), все изменения, сделанные в рамках транзакции, откатываются (отменяются).

2. **Consistency (Согласованность)**:
    - После завершения транзакции база данных должна оставаться в согласованном состоянии. Это означает, что любые изменения, сделанные транзакцией, должны быть корректными с точки зрения всех правил, установленных для базы данных (ограничения целостности, триггеры и т.д.).

3. **Isolation (Изоляция)**:
    - Операции транзакции изолированы от других параллельных транзакций. Это означает, что результаты операций одной транзакции не видны другим транзакциям до тех пор, пока транзакция не завершится (выполнится коммит).

4. **Durability (Долговечность)**:
    - После того как транзакция завершена (сделан **commit**), её результаты сохраняются в базе данных, даже если произошел сбой системы (например, отключение питания). Это достигается за счет записи данных на диск.

### Пример работы с транзакцией

Предположим, у вас есть банковская система, и вы хотите перевести деньги с одного счета на другой. Операции могут включать:
1. Снятие денег с одного счета.
2. Зачисление денег на другой счет.

Эти операции должны быть выполнены вместе. Если одна операция выполнится, а другая нет (например, деньги списались с одного счета, но не зачислились на другой), это нарушит целостность данных.

#### Пример транзакции на SQL:
```sql
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;  -- Снятие денег
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;  -- Зачисление денег

COMMIT;  -- Завершаем транзакцию
```

1. **START TRANSACTION** — начало транзакции. С этого момента все операции, которые вы выполняете, рассматриваются как часть одной транзакции.
2. **UPDATE** — операции изменения данных. В данном случае деньги переводятся с одного аккаунта на другой.
3. **COMMIT** — завершение транзакции. Если все прошло успешно, изменения фиксируются в базе данных.

Если что-то пошло не так (например, произошла ошибка при обновлении одного из счетов), можно использовать команду **ROLLBACK**, чтобы отменить все изменения в рамках транзакции:
```sql
ROLLBACK;  -- Отмена всех изменений, выполненных в транзакции
```

### Зачем нужны транзакции?

1. **Гарантия целостности данных**:
    - Транзакции гарантируют, что все операции в рамках одного логического действия (например, перевод денег) будут выполнены целиком или отменены, если что-то пошло не так.

2. **Изоляция параллельных операций**:
    - В многопользовательских системах транзакции обеспечивают, что операции одного пользователя не будут конфликтовать с операциями другого.

3. **Безопасность и защита от сбоев**:
    - Транзакции гарантируют, что данные останутся в целостном состоянии даже в случае сбоя или ошибки.

</details>

---

### 2. Что такое нормализация?

<details>
<summary>Раскрыть:</summary>

**Нормализация** — это процесс организации данных в базе данных с целью минимизации избыточности (дублирования данных) и обеспечения целостности данных. Основная цель нормализации — разбиение больших таблиц на более мелкие и связывание этих таблиц с помощью отношений, чтобы устранить повторяющуюся информацию и предотвратить аномалии при вставке, обновлении и удалении данных.

### Основные цели нормализации:
1. **Минимизация дублирования данных**: Это помогает уменьшить объем памяти, занимаемой данными, и предотвращает ошибки, связанные с несогласованностью данных (когда одна и та же информация хранится в разных местах).
2. **Обеспечение целостности данных**: Правильная структура данных помогает предотвратить ошибки и аномалии при вставке, обновлении и удалении данных.
3. **Упрощение управления данными**: Разделение данных на логически связанные таблицы делает их структуру более понятной и поддерживаемой.

### Процесс нормализации:

Процесс нормализации данных проходит через несколько этапов, называемых **нормальными формами**. Каждая последующая нормальная форма основывается на предыдущей и улучшает структуру данных.

#### 1. **Первая нормальная форма (1NF)**:
Таблица находится в первой нормальной форме, если:
- Все столбцы содержат **атомарные значения** (неделимые значения).
- Все записи таблицы уникальны.

Это означает, что в таблице не должно быть массивов или повторяющихся групп данных в одном столбце. Каждое поле должно содержать одно значение.

##### Пример:
Ненормализованная таблица:
| Student | Courses       |
|---------|---------------|
| John    | Math, Physics |
| Jane    | Biology       |

Таблица в первой нормальной форме (1NF):
| Student | Course  |
|---------|---------|
| John    | Math    |
| John    | Physics |
| Jane    | Biology |

#### 2. **Вторая нормальная форма (2NF)**:
Таблица находится во второй нормальной форме, если:
- Она уже находится в 1NF.
- Все неключевые атрибуты зависят от **полного первичного ключа**, а не от его части (если ключ составной).

Во второй нормальной форме устраняются частичные зависимости — это зависимости атрибутов от части составного ключа.

##### Пример:
Таблица в 1NF:
| Student | Course  | Instructor |
|---------|---------|------------|
| John    | Math    | Mr. Smith  |
| John    | Physics | Mr. Brown  |
| Jane    | Biology | Mr. Green  |

Здесь зависимость "инструктор курса" зависит только от курса, а не от студента, поэтому мы можем выделить эту информацию в отдельную таблицу.

Таблица во второй нормальной форме (2NF):
- Таблица студентов и курсов:
  | Student | Course  |
  |---------|---------|
  | John    | Math    |
  | John    | Physics |
  | Jane    | Biology |

- Таблица курсов и инструкторов:
  | Course  | Instructor |
  |---------|------------|
  | Math    | Mr. Smith  |
  | Physics | Mr. Brown  |
  | Biology | Mr. Green  |

#### 3. **Третья нормальная форма (3NF)**:
Таблица находится в третьей нормальной форме, если:
- Она уже находится во второй нормальной форме.
- Все неключевые атрибуты зависят **только от первичного ключа** и не зависят от других неключевых атрибутов (устраняются транзитивные зависимости).

Транзитивная зависимость — это когда один неключевой атрибут зависит от другого неключевого атрибута.

##### Пример:
Таблица во второй нормальной форме (2NF):
| Course  | Instructor | Instructor Phone |
|---------|------------|------------------|
| Math    | Mr. Smith  | 555-1234         |
| Physics | Mr. Brown  | 555-5678         |
| Biology | Mr. Green  | 555-9876         |

Здесь поле `Instructor Phone` зависит не от курса, а от инструктора. Мы можем выделить эту зависимость в отдельную таблицу, что приведет к нормализации.

Таблица в третьей нормальной форме (3NF):
- Таблица курсов и инструкторов:
  | Course  | Instructor |
  |---------|------------|
  | Math    | Mr. Smith  |
  | Physics | Mr. Brown  |
  | Biology | Mr. Green  |

- Таблица инструкторов и их телефонов:
  | Instructor | Instructor Phone |
  |------------|------------------|
  | Mr. Smith  | 555-1234         |
  | Mr. Brown  | 555-5678         |
  | Mr. Green  | 555-9876         |

#### 4. **Бойс-Кодд нормальная форма (BCNF)**:
BCNF является улучшенной версией 3NF и решает проблемы, которые могут возникать в 3NF, когда таблица содержит составные ключи и имеются зависимости между частями составного ключа. Таблица в BCNF не должна иметь зависимостей между составными ключами.

---

### Когда нормализация может быть излишней?

Хотя нормализация важна для минимизации избыточности данных, иногда полная нормализация может привести к чрезмерно сложным запросам и необходимости большого количества соединений (`JOIN`) таблиц. Это может негативно сказаться на производительности системы.

В некоторых случаях имеет смысл использовать **денормализацию**, которая вводит намеренные избыточности, чтобы ускорить чтение данных и уменьшить количество соединений между таблицами.

</details>

---

### 3. Что такое денормализации? Для чего она нужна?

<details>
<summary>Раскрыть:</summary>

**Денормализация** — это процесс намеренного добавления избыточности данных в базу данных, с целью повышения производительности запросов за счет сокращения количества соединений (JOIN) между таблицами. В отличие от нормализации, которая направлена на устранение дублирования и минимизацию избыточности, денормализация частично возвращает дублирующиеся данные в структуру базы данных для ускорения работы с часто запрашиваемыми данными.

### Основная цель денормализации:
Основная цель денормализации — **оптимизация производительности** чтения данных. Денормализация может уменьшить количество необходимых `JOIN`-операций или сделать некоторые запросы быстрее за счет хранения всех нужных данных в одной таблице или связанных таблицах.

### Почему денормализация может быть необходима?
Когда данные в базе данных нормализованы, это уменьшает избыточность и улучшает целостность данных, но может привести к тому, что для выполнения сложных запросов потребуется много операций объединения (`JOIN`) между таблицами. Это может замедлить выполнение запросов, особенно если объем данных велик или если база данных обслуживает множество одновременных запросов.

**Денормализация** может помочь в следующих случаях:
1. **Высокая нагрузка на чтение данных**: Когда производительность чтения данных является критически важной, денормализация может значительно сократить время выполнения запросов.
2. **Меньшее количество `JOIN`-операций**: Если в нормализованной структуре требуется выполнить множество `JOIN` для получения нужных данных, денормализация может помочь, сохранив часто используемые данные в одной таблице.
3. **Ускорение аналитических запросов**: В аналитических базах данных или OLAP-системах (онлайн аналитическая обработка) денормализация может ускорить сложные аналитические запросы, где важно получать результат как можно быстрее.

### Пример денормализации:

Предположим, у нас есть две нормализованные таблицы:

1. **Таблица `orders` (Заказы)**:
   | order_id | customer_id | total_price |
   |----------|-------------|-------------|
   | 1        | 101         | 150         |
   | 2        | 102         | 200         |

2. **Таблица `customers` (Клиенты)**:
   | customer_id | customer_name |
   |-------------|---------------|
   | 101         | John Doe      |
   | 102         | Jane Smith    |

В нормализованной структуре, чтобы получить информацию о заказах вместе с именем клиента, необходимо выполнить `JOIN` между таблицами `orders` и `customers`:
```sql
SELECT orders.order_id, customers.customer_name, orders.total_price
FROM orders
JOIN customers ON orders.customer_id = customers.customer_id;
```

В денормализованной структуре можно добавить поле с именем клиента прямо в таблицу `orders`, чтобы избежать объединения данных при выполнении запроса:
- **Таблица `orders` (денормализованная)**:
  | order_id | customer_id | customer_name | total_price |
  |----------|-------------|---------------|-------------|
  | 1        | 101         | John Doe      | 150         |
  | 2        | 102         | Jane Smith    | 200         |

Теперь, запрос для получения информации о заказах будет гораздо проще и быстрее, так как не требуется объединение с другой таблицей:
```sql
SELECT order_id, customer_name, total_price FROM orders;
```

### Плюсы денормализации:
1. **Увеличение производительности запросов**: Денормализация может значительно повысить скорость выполнения запросов, особенно если она устраняет необходимость в сложных `JOIN`-операциях.
2. **Уменьшение числа запросов**: В некоторых случаях денормализация позволяет сократить количество запросов к базе данных. Например, вам не нужно получать связанные данные из другой таблицы, так как они уже находятся в той же таблице.
3. **Ускорение аналитической обработки**: В больших аналитических системах денормализация помогает ускорить выполнение сложных отчетов и агрегатных запросов.

### Минусы денормализации:
1. **Избыточность данных**: Денормализация приводит к дублированию данных, что увеличивает размер базы данных и потенциально создает риск несогласованности данных, если обновления не будут выполнены правильно.
2. **Сложность обновления данных**: Из-за дублирования данных может возникнуть необходимость обновлять одну и ту же информацию в нескольких местах. Это усложняет обновление данных и может привести к ошибкам, если данные не синхронизируются должным образом.
3. **Потеря целостности данных**: Нормализация способствует поддержанию целостности данных, тогда как денормализация ослабляет эту целостность. Например, если имя клиента изменится, в денормализованной таблице оно должно быть обновлено во всех строках, где оно встречается.

### Когда следует использовать денормализацию?
Денормализация — это компромисс между производительностью и целостностью данных, поэтому её стоит использовать в следующих случаях:
- Когда производительность чтения данных является критически важной, а нагрузка на чтение значительно превышает нагрузку на запись.
- Когда количество `JOIN`-операций в запросах слишком велико, и они замедляют работу базы данных.
- В системах аналитической обработки, где требуется выполнять большие объемы сложных запросов с высокими требованиями к скорости.

</details>

---

### 4. Какие типы связей в базе данных?

<details>
<summary>Раскрыть:</summary>

В базах данных существуют несколько основных типов связей (отношений) между таблицами. Эти связи помогают структурировать данные и организовывать их взаимодействие. Основные типы связей в реляционных базах данных:

### 1. **Связь "Один к одному" (One-to-One)**
Связь "Один к одному" означает, что каждая запись в одной таблице может быть связана только с одной записью в другой таблице, и наоборот. Этот тип связи используется, когда определенная информация разделена на две таблицы для упрощения структуры или из-за специфики данных.

#### Пример:
- **Таблица `users`**:
  | id | username |
  |----|----------|
  | 1  | John     |
  | 2  | Jane     |

- **Таблица `user_profiles`**:
  | id | user_id | bio            |
  |----|---------|----------------|
  | 1  | 1       | Developer      |
  | 2  | 2       | Data Scientist |

Каждый пользователь имеет только один профиль, а каждый профиль относится только к одному пользователю. Для создания такой связи обычно используется внешний ключ (`foreign key`) в одной из таблиц, который ссылается на первичный ключ другой таблицы.

### 2. **Связь "Один ко многим" (One-to-Many)**
Связь "Один ко многим" означает, что одна запись в таблице может быть связана с несколькими записями в другой таблице. Это один из самых распространенных типов связей.

#### Пример:
- **Таблица `categories`**:
  | id | name        |
  |----|-------------|
  | 1  | Technology  |
  | 2  | Science     |

- **Таблица `posts`**:
  | id | title            | category_id |
  |----|------------------|-------------|
  | 1  | AI Advancements  | 1           |
  | 2  | Space Exploration| 2           |
  | 3  | PHP 8 Features   | 1           |

Один **category** может содержать много **posts**. В этом случае связь создается через внешний ключ (`category_id`) в таблице `posts`, который ссылается на первичный ключ в таблице `categories`.

### 3. **Связь "Многие к одному" (Many-to-One)**
Это обратная связь к "Один ко многим". Означает, что многие записи из одной таблицы могут быть связаны с одной записью в другой таблице.

#### Пример:
- **Таблица `posts`**:
  | id | title            | category_id |
  |----|------------------|-------------|
  | 1  | AI Advancements  | 1           |
  | 2  | Space Exploration| 2           |

- **Таблица `categories`**:
  | id | name        |
  |----|-------------|
  | 1  | Technology  |
  | 2  | Science     |

Здесь каждый пост относится к одной категории, и несколько постов могут принадлежать одной категории. Это типичное использование внешнего ключа.

### 4. **Связь "Многие ко многим" (Many-to-Many)**
Связь "Многие ко многим" означает, что каждая запись в одной таблице может быть связана с несколькими записями в другой таблице, и каждая запись во второй таблице может быть связана с несколькими записями в первой таблице. Для реализации этого типа связи обычно используется **промежуточная таблица**, которая содержит связи между записями двух таблиц.

#### Пример:
- **Таблица `students`**:
  | id | name  |
  |----|-------|
  | 1  | John  |
  | 2  | Jane  |

- **Таблица `courses`**:
  | id | title       |
  |----|-------------|
  | 1  | Math        |
  | 2  | Physics     |

- **Промежуточная таблица `student_courses`**:
  | student_id | course_id |
  |------------|-----------|
  | 1          | 1         |
  | 1          | 2         |
  | 2          | 1         |

Здесь каждый студент может посещать несколько курсов, и каждый курс может быть посещен несколькими студентами. Промежуточная таблица **`student_courses`** связывает студентов и курсы через их идентификаторы (внешние ключи).

### 5. **Самоссылающаяся связь (Self-referencing Relationship)**
Этот тип связи используется, когда запись в таблице может быть связана с другой записью из той же таблицы. Это может быть полезно для создания иерархических структур.

#### Пример:
- **Таблица `employees`**:
  | id | name      | manager_id |
  |----|-----------|------------|
  | 1  | Alice     | NULL       |
  | 2  | Bob       | 1          |
  | 3  | Charlie   | 1          |

Здесь каждый сотрудник может иметь менеджера, который также является сотрудником. Поле `manager_id` ссылается на ту же таблицу, создавая иерархию "менеджер — подчиненные".

</details>

---

### 5. Что означает утверждение о том, что СУБД поддерживает контроль ссылочной целостности связей?

<details>
<summary>Раскрыть:</summary>

Утверждение, что **СУБД поддерживает контроль ссылочной целостности** связей, означает, что система управления базами данных (СУБД) автоматически следит за корректностью данных в таблицах, которые имеют связи между собой. Это касается, прежде всего, использования **внешних ключей** и механизма, который гарантирует, что отношения между таблицами остаются непротиворечивыми.

### Что такое ссылочная целостность?
**Ссылочная целостность** — это свойство базы данных, которое обеспечивает согласованность и правильность данных при работе с отношениями между таблицами, особенно в тех случаях, когда одна таблица ссылается на другую через внешний ключ. Оно гарантирует, что записи в одной таблице (дочерней) всегда будут ссылаться на существующие записи в другой таблице (родительской), а изменения или удаление данных в родительской таблице автоматически обновятся или затронут дочерние записи.

### Как это работает:
1. **Внешний ключ (Foreign Key)**:
    - Внешний ключ — это поле или набор полей в одной таблице, которые ссылаются на **первичный ключ** или **уникальный ключ** в другой таблице.
    - **Пример**: В таблице `orders` поле `customer_id` может быть внешним ключом, ссылающимся на поле `id` в таблице `customers`.

2. **Правила поддержания ссылочной целостности**:
    - **Вставка данных**: При попытке вставить запись в дочернюю таблицу, СУБД проверяет, что значение внешнего ключа (например, `customer_id`) существует в родительской таблице (например, в `customers`). Если запись в родительской таблице отсутствует, вставка будет отклонена.
    - **Обновление данных**: Если значение первичного ключа в родительской таблице изменяется, СУБД может автоматически обновить связанные записи в дочерней таблице или отклонить запрос, в зависимости от настроек каскадирования.
    - **Удаление данных**: При удалении записи в родительской таблице СУБД следит за тем, что делать с записями в дочерней таблице. Она может:
        - Удалить связанные записи (каскадное удаление).
        - Установить внешний ключ в дочерней таблице в `NULL`.
        - Запретить удаление, если существуют связанные записи в дочерней таблице.

### Пример поддержания ссылочной целостности:

#### Родительская таблица `customers`:
| id  | name         |
|-----|--------------|
| 1   | John Doe     |
| 2   | Jane Smith   |

#### Дочерняя таблица `orders`:
| order_id | customer_id | order_total |
|----------|-------------|-------------|
| 1        | 1           | 100         |
| 2        | 1           | 150         |
| 3        | 2           | 200         |

Здесь поле `customer_id` в таблице `orders` — это внешний ключ, ссылающийся на поле `id` в таблице `customers`.

#### Контроль ссылочной целостности:
1. **Вставка**: Если вы попытаетесь вставить запись в таблицу `orders` с `customer_id = 3`, но записи с `id = 3` в таблице `customers` не существует, СУБД отклонит операцию и предотвратит вставку некорректных данных.
2. **Удаление**: Если вы попытаетесь удалить клиента с `id = 1` из таблицы `customers`, СУБД проверит, есть ли в таблице `orders` записи с `customer_id = 1`. Если такие записи существуют, она может либо запретить удаление, либо удалить связанные заказы (если настроено каскадное удаление).
3. **Обновление**: Если вы измените `id` клиента в таблице `customers` (например, `id = 1` на `id = 10`), СУБД может автоматически обновить `customer_id` в таблице `orders`, чтобы сохранить ссылочную целостность.

### Правила каскадирования при поддержании ссылочной целостности:
1. **ON DELETE CASCADE**: Если запись в родительской таблице удаляется, все записи, которые ссылаются на нее в дочерней таблице, также удаляются.
    - Пример: Если удалить клиента с `id = 1` из таблицы `customers`, все заказы с `customer_id = 1` в таблице `orders` будут автоматически удалены.

2. **ON DELETE SET NULL**: Если запись в родительской таблице удаляется, все связанные внешние ключи в дочерней таблице будут установлены в `NULL`.
    - Пример: Если удалить клиента с `id = 1` из таблицы `customers`, то все заказы с `customer_id = 1` в таблице `orders` будут обновлены, и поле `customer_id` станет `NULL`.

3. **RESTRICT** или **NO ACTION**: Запрещает удаление или обновление записи в родительской таблице, если существуют связанные записи в дочерней таблице.
    - Пример: Если вы попытаетесь удалить клиента с `id = 1`, и у этого клиента есть заказы в таблице `orders`, СУБД не позволит удалить запись в таблице `customers`.

4. **ON UPDATE CASCADE**: Если значение первичного ключа в родительской таблице изменяется, то соответствующие значения во внешних ключах дочерней таблицы автоматически обновляются.

### Зачем это нужно?
1. **Поддержание целостности данных**: Контроль ссылочной целостности гарантирует, что данные в таблицах, связанных друг с другом, всегда будут корректными. Например, нельзя вставить заказ для несуществующего клиента.
2. **Минимизация ошибок**: Автоматическое управление ссылками предотвращает ошибки при удалении или обновлении данных, которые могли бы привести к несоответствиям или потере данных.
3. **Упрощение работы с базой данных**: За счет автоматизации контроля за связями между таблицами, разработчикам не нужно вручную отслеживать целостность данных — это делает работу с базой данных проще и надежнее.

</details>

---

### 6. Если используемая вами СУБД не поддерживает каскадные удаления для поддержки ссылочной целостности связей, что можно сделать для достижения аналогичного результата?

<details>
<summary>Раскрыть:</summary>

Если используемая СУБД не поддерживает **каскадное удаление** для поддержания ссылочной целостности, можно добиться аналогичного результата с помощью альтернативных подходов на уровне приложения или базы данных. Вот несколько способов, которые можно использовать:

### 1. **Реализовать каскадное удаление на уровне приложения**

Одним из самых распространенных решений является реализация каскадного удаления в логике самого приложения, которое работает с базой данных. Этот подход включает в себя программную проверку и удаление связанных записей при удалении родительской записи.

#### Шаги:
1. При удалении записи из родительской таблицы, приложение должно найти все связанные записи в дочерней таблице.
2. Удалить все найденные связанные записи в дочерней таблице.
3. После удаления дочерних записей удалить запись из родительской таблицы.

#### Пример на PHP:
Предположим, у нас есть таблицы `customers` и `orders`, где `orders.customer_id` ссылается на `customers.id`.

```php
function deleteCustomer($customerId, $pdo) {
    // Удаляем заказы, связанные с клиентом
    $stmt = $pdo->prepare("DELETE FROM orders WHERE customer_id = :customer_id");
    $stmt->execute(['customer_id' => $customerId]);

    // Удаляем клиента
    $stmt = $pdo->prepare("DELETE FROM customers WHERE id = :id");
    $stmt->execute(['id' => $customerId]);
}
```

Этот код сначала удаляет все заказы, связанные с клиентом, а затем удаляет самого клиента. Это аналог каскадного удаления на уровне базы данных, но выполняется приложением.

### 2. **Использовать триггеры в базе данных**

Если ваша СУБД поддерживает **триггеры**, можно реализовать каскадное удаление с их помощью. Триггер — это механизм, который выполняет определенный код автоматически при определенных действиях на таблице, таких как вставка, обновление или удаление данных.

#### Пример триггера:
Для таблиц `customers` и `orders` можно создать триггер, который будет автоматически удалять заказы, связанные с клиентом, при удалении клиента из таблицы `customers`.

```sql
CREATE TRIGGER delete_orders_after_customer
BEFORE DELETE ON customers
FOR EACH ROW
BEGIN
    DELETE FROM orders WHERE customer_id = OLD.id;
END;
```

Этот триггер сработает **до удаления** записи из таблицы `customers` и удалит все заказы, связанные с удаляемым клиентом. Таким образом, триггер автоматически реализует каскадное удаление на уровне базы данных.

### 3. **Использовать хранимые процедуры**

Вместо использования триггеров можно реализовать каскадное удаление через **хранимые процедуры** в базе данных. Хранимая процедура — это блок кода, который выполняется на сервере базы данных и может быть вызван из приложения.

#### Пример хранимой процедуры:
```sql
CREATE PROCEDURE delete_customer_and_orders(IN customerId INT)
BEGIN
    -- Удаляем заказы, связанные с клиентом
    DELETE FROM orders WHERE customer_id = customerId;

    -- Удаляем самого клиента
    DELETE FROM customers WHERE id = customerId;
END;
```

Теперь вы можете вызвать эту хранимую процедуру при необходимости:
```sql
CALL delete_customer_and_orders(1);
```

### 4. **Ручное управление ссылочной целостностью**

Если ни один из вышеописанных методов не поддерживается или не подходит, можно просто вручную следить за тем, чтобы всякий раз при удалении записи из родительской таблицы удалялись или обновлялись связанные записи в дочерних таблицах. Этот подход требует больше внимания и ответственности от разработчиков и может привести к ошибкам, если будет забыто удалить или обновить связанные данные.

#### Пример:
При удалении клиента из таблицы `customers`, разработчик должен помнить о необходимости выполнения запроса на удаление всех связанных заказов:
```sql
DELETE FROM orders WHERE customer_id = 1;
DELETE FROM customers WHERE id = 1;
```

### 5. **Мягкое удаление (Soft Delete)**

Вместо физического удаления записей можно использовать технику **мягкого удаления (soft delete)**. В этом случае записи не удаляются из базы данных, а помечаются как "удаленные" с помощью специального флага, например, поля `deleted_at`. Это позволяет избежать потерь данных и конфликтов ссылочной целостности, поскольку записи остаются в базе данных, но считаются удаленными.

#### Пример:
Добавляем поле `deleted_at` в таблицу `customers` и `orders`:
```sql
ALTER TABLE customers ADD deleted_at TIMESTAMP NULL;
ALTER TABLE orders ADD deleted_at TIMESTAMP NULL;
```

Теперь, вместо физического удаления записей, мы просто обновляем это поле:
```php
function softDeleteCustomer($customerId, $pdo) {
    // Мягкое удаление заказов клиента
    $stmt = $pdo->prepare("UPDATE orders SET deleted_at = NOW() WHERE customer_id = :customer_id");
    $stmt->execute(['customer_id' => $customerId]);

    // Мягкое удаление клиента
    $stmt = $pdo->prepare("UPDATE customers SET deleted_at = NOW() WHERE id = :id");
    $stmt->execute(['id' => $customerId]);
}
```

При этом удаленные записи не участвуют в стандартных запросах:
```sql
SELECT * FROM customers WHERE deleted_at IS NULL;
```

### 6. **Асинхронная обработка на уровне приложения**

В высоконагруженных системах каскадное удаление можно реализовать через асинхронные задачи или очереди сообщений. Это помогает избежать замедления работы приложения при удалении записей, если требуется удалить большое количество связанных данных.

#### Пример:
1. Приложение отправляет задачу в очередь на удаление связанных данных.
2. Отдельный процесс асинхронно обрабатывает эту задачу, удаляя связанные записи.

Это подход масштабируем для высоконагруженных приложений

</details>

---

### 7. Что такое первичный и внешний ключи?

<details>
<summary>Раскрыть:</summary>

### 1. **Первичный ключ (Primary Key)**

**Первичный ключ** — это одно или несколько полей (столбцов) в таблице, которые **уникально идентифицируют каждую запись** в этой таблице. Каждая таблица должна иметь первичный ключ, и он должен выполнять несколько условий:

#### Основные характеристики первичного ключа:
- **Уникальность**: Каждое значение первичного ключа должно быть уникальным для каждой записи в таблице. Это означает, что не может существовать двух записей с одинаковым значением первичного ключа.
- **Непустые значения**: Поле первичного ключа не может содержать `NULL`-значений, так как оно должно всегда идентифицировать конкретную запись.
- **Один на таблицу**: В каждой таблице может быть только один первичный ключ, но он может состоять из одного или нескольких полей (составной первичный ключ).

#### Пример первичного ключа:
Предположим, у нас есть таблица `users`, где поле `id` является первичным ключом:
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,  -- Первичный ключ
    name VARCHAR(255),
    email VARCHAR(255)
);
```

Значение поля `id` будет уникальным для каждого пользователя. Например:
| id  | name       | email             |
|-----|------------|-------------------|
| 1   | John Doe   | john@example.com   |
| 2   | Jane Smith | jane@example.com   |

### 2. **Внешний ключ (Foreign Key)**

**Внешний ключ** — это поле (или набор полей) в одной таблице, которое **ссылается на первичный ключ другой таблицы**. Внешние ключи используются для создания связей между таблицами, обеспечивая ссылочную целостность данных.

#### Основные характеристики внешнего ключа:
- **Связь между таблицами**: Внешний ключ устанавливает связь между двумя таблицами: дочерней (где находится внешний ключ) и родительской (где находится первичный ключ).
- **Обеспечение целостности данных**: Внешний ключ гарантирует, что значения в дочерней таблице будут корректными и будут ссылаться на существующие записи в родительской таблице.
- **Условия при обновлении и удалении**: Внешний ключ может быть настроен таким образом, чтобы автоматически обновлять или удалять связанные записи (каскадное обновление/удаление), либо запрещать такие операции.

#### Пример внешнего ключа:
Предположим, у нас есть две таблицы: `orders` (заказы) и `customers` (клиенты). В таблице `orders` поле `customer_id` является внешним ключом, который ссылается на поле `id` в таблице `customers`.

```sql
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(255)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_total DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(id)  -- Внешний ключ
);
```

Поле `customer_id` в таблице `orders` ссылается на поле `id` в таблице `customers`. Это означает, что каждый заказ должен быть связан с существующим клиентом, и не может быть заказа с `customer_id`, которого нет в таблице `customers`.

#### Пример данных:
**Таблица `customers`**:
| id  | name       |
|-----|------------|
| 1   | John Doe   |
| 2   | Jane Smith |

**Таблица `orders`**:
| order_id | customer_id | order_total |
|----------|-------------|-------------|
| 1        | 1           | 100.00      |
| 2        | 2           | 150.00      |

Здесь значение `customer_id = 1` в таблице `orders` указывает, что заказ сделан клиентом с `id = 1` в таблице `customers`.

### Основные отличия первичного и внешнего ключей:

| **Характеристика**           | **Первичный ключ**                              | **Внешний ключ**                                  |
|------------------------------|-------------------------------------------------|---------------------------------------------------|
| **Назначение**               | Уникально идентифицирует каждую запись в таблице | Создает связь между таблицами, ссылаясь на первичный ключ |
| **Уникальность**             | Должен быть уникальным                          | Может содержать повторяющиеся значения             |
| **NULL-значения**            | Не допускаются                                 | Могут быть разрешены (в зависимости от настройки)  |
| **Расположение**             | Находится в таблице, где идентифицируются записи | Находится в дочерней таблице и ссылается на родительскую |
| **Количество на таблицу**    | Один на таблицу                                | Может быть несколько внешних ключей в одной таблице |
| **Обеспечение целостности**  | Гарантирует уникальность записи в таблице       | Гарантирует согласованность данных между таблицами |

### Как работают внешние ключи:
1. **Запрет некорректных данных**: Внешний ключ не позволяет вставить в дочернюю таблицу запись, если она ссылается на несуществующую запись в родительской таблице.
    - Пример: Если вы попытаетесь вставить запись в таблицу `orders` с `customer_id = 3`, но в таблице `customers` нет записи с `id = 3`, операция будет отклонена.

2. **Поддержка целостности при удалении и обновлении**: Если запись в родительской таблице удаляется или обновляется, внешний ключ определяет, что произойдет с дочерними записями:
    - **Каскадное удаление**: При удалении записи из родительской таблицы все связанные записи в дочерней таблице также удаляются.
    - **Каскадное обновление**: При изменении значения первичного ключа в родительской таблице все связанные записи в дочерней таблице обновляются.
    - **Запрет удаления**: Если существуют связанные записи, СУБД может запретить удаление записи в родительской таблице.

</details>

---

### 8. Какие различия между первичным и уникальным ключами?

<details>
<summary>Раскрыть:</summary>

### Основные различия между первичным и уникальным ключами:

| **Характеристика**          | **Первичный ключ (Primary Key)**               | **Уникальный ключ (Unique Key)**               |
|-----------------------------|-------------------------------------------------|------------------------------------------------|
| **Уникальность**            | Гарантирует уникальность каждой записи в таблице | Гарантирует уникальность значений в указанной колонке или колонках |
| **NULL-значения**           | **Не допускает NULL-значений**                   | **Допускает одно** `NULL`-значение на столбец или группу столбцов (в зависимости от СУБД) |
| **Количество на таблицу**   | В каждой таблице может быть **только один** первичный ключ | В одной таблице может быть **несколько** уникальных ключей |
| **Назначение**              | Используется для уникальной идентификации каждой строки | Обеспечивает уникальность значений в столбце (или комбинации столбцов) |
| **Создание индексов**       | Первичный ключ автоматически создает **кластерный индекс** (обычно) | Уникальный ключ создает **некластерный индекс** |
| **По умолчанию**            | При создании таблицы **должен быть** определен первичный ключ | Уникальный ключ **не обязателен** для создания таблицы |
| **Использование как внешний ключ** | Первичный ключ часто используется для создания внешнего ключа в других таблицах | Уникальный ключ также может быть использован как внешний ключ, но это менее распространено |

</details>

---

### 9. Какие типы JOIN и в чем различия?

<details>
<summary>Раскрыть:</summary>

### 1. **INNER JOIN** (внутреннее соединение)

**INNER JOIN** возвращает только те строки, которые имеют соответствующие значения в обеих таблицах. То есть он объединяет записи из двух таблиц, когда выполняется условие на соответствие значений в определенных столбцах.

#### Пример:
```sql
SELECT orders.order_id, customers.name
FROM orders
INNER JOIN customers ON orders.customer_id = customers.id;
```

- **Результат**: Возвращает только те заказы, для которых есть соответствующий клиент. Если в одной из таблиц нет соответствующего значения, запись не будет включена в результат.

#### Пример данных:

**Таблица `customers`**:
| id  | name       |
|-----|------------|
| 1   | John Doe   |
| 2   | Jane Smith |

**Таблица `orders`**:
| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 3           | 150    |

- **Результат `INNER JOIN`**:
  | order_id | name     |
  |----------|----------|
  | 1        | John Doe |

Здесь отображается только заказ с `order_id = 1`, так как у этого заказа есть соответствующий клиент в таблице `customers` (John Doe). Заказ с `customer_id = 3` не включён, потому что такого клиента нет в таблице `customers`.

### 2. **LEFT JOIN** (или LEFT OUTER JOIN, левое соединение)

**LEFT JOIN** возвращает все строки из **левой таблицы** (первая таблица в запросе) и соответствующие строки из правой таблицы. Если в правой таблице нет соответствующей записи, в результат будут включены строки с `NULL` для полей из правой таблицы.

#### Пример:
```sql
SELECT orders.order_id, customers.name
FROM orders
LEFT JOIN customers ON orders.customer_id = customers.id;
```

- **Результат**: Возвращает все заказы, даже если для них нет соответствующего клиента. Для тех заказов, где клиента нет, столбцы из таблицы `customers` будут заполнены `NULL`.

#### Пример данных:

**Таблица `customers`**:
| id  | name       |
|-----|------------|
| 1   | John Doe   |
| 2   | Jane Smith |

**Таблица `orders`**:
| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 3           | 150    |

- **Результат `LEFT JOIN`**:
  | order_id | name     |
  |----------|----------|
  | 1        | John Doe |
  | 2        | NULL     |

Здесь показаны все заказы. Заказ с `order_id = 2` возвращает `NULL` в столбце `name`, так как клиента с `customer_id = 3` не существует.

### 3. **RIGHT JOIN** (или RIGHT OUTER JOIN, правое соединение)

**RIGHT JOIN** возвращает все строки из **правой таблицы** и соответствующие строки из левой таблицы. Если в левой таблице нет соответствующей записи, то в результат включаются строки с `NULL` для полей из левой таблицы.

#### Пример:
```sql
SELECT orders.order_id, customers.name
FROM orders
RIGHT JOIN customers ON orders.customer_id = customers.id;
```

- **Результат**: Возвращает всех клиентов, даже если у них нет заказов. Если заказов нет, поля из таблицы `orders` будут заполнены `NULL`.

#### Пример данных:

**Таблица `customers`**:
| id  | name       |
|-----|------------|
| 1   | John Doe   |
| 2   | Jane Smith |

**Таблица `orders`**:
| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 3           | 150    |

- **Результат `RIGHT JOIN`**:
  | order_id | name       |
  |----------|------------|
  | 1        | John Doe   |
  | NULL     | Jane Smith |

Здесь все клиенты включены в результат, даже если у клиента нет заказа (например, у Jane Smith нет заказов, поэтому `order_id` для неё равен `NULL`).

### 4. **FULL JOIN** (или FULL OUTER JOIN, полное соединение)

**FULL JOIN** возвращает все строки из обеих таблиц. Если в одной из таблиц нет соответствующей строки, то для соответствующих столбцов будет выведен `NULL`. Этот тип соединения включает в себя результаты как **LEFT JOIN**, так и **RIGHT JOIN**.

#### Пример:
```sql
SELECT orders.order_id, customers.name
FROM orders
FULL JOIN customers ON orders.customer_id = customers.id;
```

- **Результат**: Возвращает все заказы и всех клиентов, даже если для некоторых заказов нет клиентов или у некоторых клиентов нет заказов.

#### Пример данных:

**Таблица `customers`**:
| id  | name       |
|-----|------------|
| 1   | John Doe   |
| 2   | Jane Smith |

**Таблица `orders`**:
| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 3           | 150    |

- **Результат `FULL JOIN`**:
  | order_id | name       |
  |----------|------------|
  | 1        | John Doe   |
  | 2        | NULL       |
  | NULL     | Jane Smith |

Здесь в результате есть все заказы и все клиенты. Там, где нет соответствующего клиента или заказа, возвращаются `NULL`.

### 5. **CROSS JOIN** (декартово произведение)

**CROSS JOIN** возвращает **декартово произведение** таблиц, то есть он сопоставляет **каждую строку** из первой таблицы с **каждой строкой** из второй таблицы. В результате получается множество всех возможных комбинаций строк.

#### Пример:
```sql
SELECT customers.name, orders.order_id
FROM customers
CROSS JOIN orders;
```

- **Результат**: Возвращает все возможные комбинации строк из таблиц `customers` и `orders`, независимо от их связей.

#### Пример данных:

**Таблица `customers`**:
| id  | name       |
|-----|------------|
| 1   | John Doe   |
| 2   | Jane Smith |

**Таблица `orders`**:
| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 3           | 150    |

- **Результат `CROSS JOIN`**:
  | name       | order_id |
  |------------|----------|
  | John Doe   | 1        |
  | John Doe   | 2        |
  | Jane Smith | 1        |
  | Jane Smith | 2        |

Это результат декартового произведения всех строк, в котором каждая строка из таблицы `customers` соединена с каждой строкой из таблицы `orders`.

### 6. **SELF JOIN** (самосоединение)

**SELF JOIN** — это специальный вид соединения, в котором таблица соединяется сама с собой. Это может быть полезно, когда необходимо сопоставить строки внутри одной таблицы.

#### Пример:
Предположим, у нас есть таблица `employees`, где каждый сотрудник может иметь менеджера, который также является сотрудником.

```sql
SELECT e1.name AS employee, e2.name AS manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id;
```

- **Результат**: Возвращает каждого сотрудника и его менеджера.


| **Тип JOIN**       | **Описание**                                                                 |
|--------------------|------------------------------------------------------------------------------|
| **INNER JOIN**     | Возвращает только те строки, которые имеют соответствующие значения в обеих таблицах. |
| **LEFT JOIN**      | Возвращает все строки из левой таблицы, даже если для них нет соответствующих записей в правой таблице. |
| **RIGHT JOIN**     | Возвращает все строки из правой таблицы, даже если для них нет соответствующих записей в левой таблице. |
| **FULL JOIN**      | Возвращает все строки из обеих таблиц, включая строки без соответствующих записей. |
| **CROSS JOIN**     | Возвращает декартово произведение таблиц (все возможные комбинации строк).     |
| **SELF JOIN**      | Соединяет таблицу сама с собой.                                               |

</details>

---

### 10. Что такое курсоры в базах данных?

<details>
<summary>Раскрыть:</summary>

**Курсоры** в базах данных — это механизм, который позволяет работать с результатами запроса построчно. В отличие от стандартных SQL-запросов, которые возвращают полный набор данных сразу, курсоры позволяют обрабатывать строки одну за другой, что полезно при работе с большими наборами данных или в тех случаях, когда необходимо выполнить построчную обработку результатов.

### Зачем нужны курсоры?

Курсоры используются в следующих ситуациях:
1. **Построчная обработка данных**: Если необходимо обрабатывать результаты по одной строке, особенно когда нужно применять сложную бизнес-логику или выполнять обновления/вставки на основе каждой строки.
2. **Оптимизация работы с большими наборами данных**: Когда набор данных слишком велик, чтобы его загружать и обрабатывать целиком в памяти. Курсор позволяет обработать результаты запроса постепенно, минимизируя использование памяти.
3. **Автоматизация обработки данных**: Используется в хранимых процедурах для автоматического выполнения операций над набором данных.

### Как работают курсоры:

1. **Открытие курсора**: Курсор инициализируется и выполняется запрос, возвращающий результат. Однако результат не сразу загружается в память, а становится доступным для построчной выборки.
2. **Чтение строк**: Курсор может перемещаться по результатам запроса построчно. Это позволяет выполнять определенные операции с каждой строкой по мере её обработки.
3. **Закрытие курсора**: Когда обработка данных завершена, курсор закрывается, и освобождаются все связанные с ним ресурсы.

### Этапы работы с курсором:

1. **Объявление курсора**: Определение, какой запрос будет выполнен курсором.
2. **Открытие курсора**: Выполнение запроса и подготовка курсора для чтения данных.
3. **Чтение данных**: Извлечение данных из набора результатов построчно.
4. **Закрытие курсора**: Завершение работы с курсором и освобождение ресурсов.

### Пример работы с курсором:

Пример на SQL (псевдокод для PostgreSQL):

```sql
DO $$
DECLARE
    -- Объявляем курсор для выборки данных
    my_cursor CURSOR FOR
    SELECT id, name FROM customers;
    
    -- Переменные для хранения данных из курсора
    customer_id INT;
    customer_name VARCHAR;
    
BEGIN
    -- Открываем курсор
    OPEN my_cursor;
    
    -- Цикл для чтения строк из курсора
    LOOP
        -- Извлекаем одну строку данных из курсора
        FETCH my_cursor INTO customer_id, customer_name;
        
        -- Прерываем цикл, если строк больше нет
        EXIT WHEN NOT FOUND;
        
        -- Выполняем операции с данными
        RAISE NOTICE 'Customer ID: %, Name: %', customer_id, customer_name;
    END LOOP;
    
    -- Закрываем курсор
    CLOSE my_cursor;
END $$;
```

### Описание шагов:
1. **Объявление курсора**: Здесь курсор `my_cursor` объявляется для выполнения запроса `SELECT id, name FROM customers`.
2. **Открытие курсора**: Курсор открывается командой `OPEN`, и запрос начинает выполняться.
3. **Чтение данных**: С помощью команды `FETCH` строки извлекаются по одной, после чего с ними можно выполнять необходимые операции.
4. **Закрытие курсора**: После завершения работы курсор закрывается командой `CLOSE`.

### Типы курсоров:

1. **Имплицитные курсоры**:
    - Создаются автоматически при выполнении любого SQL-запроса, который возвращает несколько строк. Чаще всего используются в процедурах или пакетах.
    - Пример: Если хранимая процедура делает простой `SELECT`, она может автоматически использовать неявный курсор для обработки результата.

2. **Явные курсоры**:
    - Явно создаются пользователем для выполнения запросов и управления результатами.
    - Пример: В приведенном выше коде мы явным образом объявляем и управляем курсором.

3. **Чувствительные и нечувствительные курсоры**:
    - **Чувствительный курсор**: При перемещении курсора по строкам, если в данных происходит обновление, эти изменения будут видны.
    - **Нечувствительный курсор**: Возвращает данные, которые не изменяются после выполнения запроса, независимо от того, происходят ли обновления в базе данных.

4. **Прокручиваемые курсоры (scrollable cursors)**:
    - Позволяют перемещаться не только вперед, но и назад по результатам запроса. Это полезно, когда нужно вернуться к предыдущим строкам.

   Пример:
   ```sql
   DECLARE my_scrollable_cursor SCROLL CURSOR FOR
   SELECT id, name FROM customers;
   ```

5. **READ ONLY и FOR UPDATE курсоры**:
    - **READ ONLY**: Позволяет только чтение данных из курсора.
    - **FOR UPDATE**: Позволяет обновлять строки, выбранные курсором.

### Недостатки курсоров:

1. **Производительность**: Курсоры могут быть менее эффективными, чем операции, работающие сразу с набором данных, так как они обрабатывают данные построчно. В некоторых ситуациях это может существенно замедлить работу, особенно на больших объемах данных.

2. **Ресурсы**: Курсоры используют память и ресурсы сервера для поддержания состояния между операциями выборки строк. Чем дольше курсор открыт, тем больше ресурсов используется.

3. **Сложность кода**: Работа с курсорами может усложнить код по сравнению с обычными SQL-запросами, особенно когда нужно поддерживать различные состояния и циклы обработки данных.

</details>

---

### 11. Что такое агрегатные функции SQL? Приведите несколько примеров.

<details>
<summary>Раскрыть:</summary>

**Агрегатные функции SQL** — это функции, которые выполняют вычисления на наборе значений и возвращают одно итоговое значение. Они обычно применяются к группам строк и используются в сочетании с оператором **`GROUP BY`** для выполнения групповых операций над данными. Агрегатные функции полезны для выполнения статистических, математических и аналитических операций над данными.

### Основные агрегатные функции:

1. **`COUNT()`** — подсчитывает количество строк в наборе данных.
    - Пример:
      ```sql
      SELECT COUNT(*) FROM orders;
      ```
      Этот запрос вернёт количество всех строк в таблице `orders`.

2. **`SUM()`** — вычисляет сумму значений в наборе данных.
    - Пример:
      ```sql
      SELECT SUM(amount) FROM orders;
      ```
      Этот запрос вернёт сумму значений в столбце `amount` для всех заказов.

3. **`AVG()`** — вычисляет среднее значение набора данных.
    - Пример:
      ```sql
      SELECT AVG(amount) FROM orders;
      ```
      Этот запрос вернёт среднее значение суммы заказов (`amount`).

4. **`MIN()`** — возвращает минимальное значение из набора данных.
    - Пример:
      ```sql
      SELECT MIN(amount) FROM orders;
      ```
      Этот запрос вернёт минимальную сумму заказа.

### Использование с `GROUP BY`:

Агрегатные функции часто используются в сочетании с оператором **`GROUP BY`**, чтобы выполнять операции для каждой группы строк в наборе данных.

#### Пример:

Предположим, у нас есть таблица `orders`, в которой хранятся заказы, и мы хотим узнать, сколько заказов и на какую сумму сделал каждый клиент.

```sql
SELECT customer_id, COUNT(order_id) AS total_orders, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id;
```

- **`COUNT(order_id)`** подсчитает количество заказов для каждого клиента.
- **`SUM(amount)`** вычислит общую сумму заказов для каждого клиента.

### Пример результата:

| customer_id | total_orders | total_amount |
|-------------|--------------|--------------|
| 1           | 5            | 450.00       |
| 2           | 3            | 300.00       |

Этот запрос сгруппировал заказы по клиентам и посчитал общее количество заказов и сумму для каждого клиента.

</details>

---

### 12. Что такое миграции?

<details>
<summary>Раскрыть:</summary>

**Миграции** — это механизм управления изменениями в базе данных, который позволяет отслеживать, версионировать и управлять изменениями структуры базы данных (такими как создание, изменение или удаление таблиц, индексов и полей). Миграции позволяют управлять схемой базы данных с помощью кода и упрощают синхронизацию структуры базы данных между разными средами (например, разработка, тестирование и продакшн).



**Основные цели миграций:**



1. **Управление изменениями структуры базы данных**: Миграции позволяют легко вносить изменения в структуру базы данных (добавление новых столбцов, таблиц, индексов и т. д.).

2. **Версионирование схемы базы данных**: Миграции обеспечивают версионирование изменений, что позволяет отслеживать, какие изменения были внесены, и в какой последовательности.

3. **Упрощение командной разработки**: Разработчики могут создавать и применять изменения базы данных в своей среде и распространять эти изменения через миграции на другие среды и базы данных.

4. **Автоматизация**: Миграции позволяют автоматизировать процесс обновления базы данных при развертывании приложения, что снижает вероятность ошибок.



**Как работают миграции:**



1. **Создание миграций**: Миграция — это файл (или набор файлов), содержащий инструкции для изменения структуры базы данных. Например, создание таблиц, добавление индексов или изменение типов данных столбцов.

2. **Применение миграций (migrate)**: Когда миграция создана, она может быть применена к базе данных, внося изменения в её структуру.

3. **Откат миграций (rollback)**: Если необходимо отменить изменения, миграции позволяют откатить структуру базы данных на предыдущую версию.

</details>

---

### 13. Расскажите о связи друг к другу, один ко многим, многие ко многим.

<details>
<summary>Раскрыть:</summary>

### 1. **Связь "Один ко многим" (One-to-Many)**

Связь **"Один ко многим"** означает, что одна запись в одной таблице может быть связана с несколькими записями в другой таблице, но каждая запись во второй таблице связана только с одной записью в первой таблице.

#### Пример:
Предположим, у нас есть две таблицы — **"Клиенты"** и **"Заказы"**. Один клиент может сделать несколько заказов, но каждый заказ принадлежит только одному клиенту.

- **Таблица `customers`** (Клиенты):
  | id  | name       |
  |-----|------------|
  | 1   | John Doe   |
  | 2   | Jane Smith |

- **Таблица `orders`** (Заказы):
  | order_id | customer_id | amount |
  |----------|-------------|--------|
  | 1        | 1           | 100    |
  | 2        | 1           | 150    |
  | 3        | 2           | 200    |

Здесь столбец `customer_id` в таблице `orders` является **внешним ключом**, который ссылается на столбец `id` в таблице `customers`. Это и создает связь **"один ко многим"**: один клиент (например, John Doe с `id = 1`) может иметь много заказов, но каждый заказ относится к одному клиенту.

### 2. **Связь "Многие ко многим" (Many-to-Many)**

Связь **"Многие ко многим"** возникает, когда каждая запись в одной таблице может быть связана с несколькими записями в другой таблице, и наоборот. Для реализации такой связи обычно используется **промежуточная таблица**, которая содержит внешние ключи на обе основные таблицы.

#### Пример:
Предположим, у нас есть две таблицы — **"Студенты"** и **"Курсы"**. Один студент может посещать несколько курсов, и каждый курс может посещать несколько студентов.

- **Таблица `students`** (Студенты):
  | id  | name        |
  |-----|-------------|
  | 1   | Alice       |
  | 2   | Bob         |

- **Таблица `courses`** (Курсы):
  | id  | course_name  |
  |-----|--------------|
  | 1   | Math         |
  | 2   | Physics      |

Чтобы создать связь **"многие ко многим"**, необходимо ввести **промежуточную таблицу** (таблицу связей), которая будет хранить отношения между студентами и курсами:

- **Таблица `student_courses`** (Промежуточная таблица):
  | student_id | course_id |
  |------------|-----------|
  | 1          | 1         |
  | 1          | 2         |
  | 2          | 1         |

Здесь:
- Студент Alice (`id = 1`) записана на два курса: Math (`course_id = 1`) и Physics (`course_id = 2`).
- Студент Bob (`id = 2`) записан только на курс Math (`course_id = 1`).

Таким образом, **"многие ко многим"** означает, что одна запись в таблице `students` может быть связана с несколькими записями в таблице `courses`, и каждая запись в таблице `courses` может быть связана с несколькими записями в таблице `students`.

### Как реализуются связи "Один ко многим" и "Многие ко многим":

#### Связь "Один ко многим":
1. **Основная таблица** (например, `customers`) содержит уникальные записи (первичный ключ).
2. **Дочерняя таблица** (например, `orders`) содержит внешний ключ, который ссылается на первичный ключ основной таблицы.
3. Пример SQL-запроса для создания связи:
   ```sql
   CREATE TABLE customers (
       id INT PRIMARY KEY,
       name VARCHAR(255)
   );

   CREATE TABLE orders (
       order_id INT PRIMARY KEY,
       customer_id INT,
       amount DECIMAL(10, 2),
       FOREIGN KEY (customer_id) REFERENCES customers(id)
   );
   ```

#### Связь "Многие ко многим":
1. Две основные таблицы (например, `students` и `courses`).
2. Промежуточная таблица (например, `student_courses`), которая содержит внешние ключи на обе основные таблицы.
3. Пример SQL-запроса для создания связи:
   ```sql
   CREATE TABLE students (
       id INT PRIMARY KEY,
       name VARCHAR(255)
   );

   CREATE TABLE courses (
       id INT PRIMARY KEY,
       course_name VARCHAR(255)
   );

   CREATE TABLE student_courses (
       student_id INT,
       course_id INT,
       PRIMARY KEY (student_id, course_id),
       FOREIGN KEY (student_id) REFERENCES students(id),
       FOREIGN KEY (course_id) REFERENCES courses(id)
   );
   ```

### Важные моменты:

- **"Один ко многим"** — это наиболее распространенная связь, когда одна запись в основной таблице может иметь несколько связанных записей в дочерней таблице.
- **"Многие ко многим"** требует создания промежуточной таблицы для управления отношениями между двумя таблицами.
- Для обеих связей важно правильно настраивать **внешние ключи**, чтобы обеспечить целостность данных.

</details>

---

### 14. Зачем используют оператор группировки GROUP BY?

<details>
<summary>Раскрыть:</summary>

Оператор **`GROUP BY`** в SQL используется для группировки строк, имеющих одинаковые значения в одном или нескольких столбцах, и применения **агрегатных функций** (например, `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()`) к каждой группе. Этот оператор позволяет выполнять групповые операции и получать сводные данные по определенным категориям.

### Основные цели использования `GROUP BY`:
1. **Группировка данных**: Позволяет объединить строки, которые имеют одинаковые значения в указанных столбцах.
2. **Агрегирование данных**: Позволяет применять агрегатные функции для каждой группы (например, суммировать, считать количество записей, находить среднее и т.д.).
3. **Создание сводных отчетов**: Помогает создавать сводные отчеты, показывающие, например, общую сумму заказов по каждому клиенту или количество товаров в каждой категории.

### Как работает `GROUP BY`:

Когда `GROUP BY` используется в запросе, SQL сначала группирует строки с одинаковыми значениями в указанных столбцах, а затем применяет к этим группам агрегатные функции, если они указаны.

### Пример:

Предположим, у нас есть таблица `orders`, содержащая информацию о заказах:

| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 1           | 150    |
| 3        | 2           | 200    |
| 4        | 3           | 250    |
| 5        | 3           | 300    |

Теперь, если мы хотим узнать общую сумму заказов для каждого клиента, можно использовать оператор `GROUP BY` вместе с агрегатной функцией `SUM()`.

#### Пример запроса:
```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id;
```

#### Результат:
| customer_id | total_amount |
|-------------|--------------|
| 1           | 250          |
| 2           | 200          |
| 3           | 550          |

В данном примере строки с одинаковым `customer_id` были сгруппированы, и для каждой группы агрегатная функция `SUM(amount)` вычислила общую сумму заказов по каждому клиенту.

### Применение агрегатных функций с `GROUP BY`:

Чаще всего `GROUP BY` используется с агрегатными функциями, такими как:

- **`COUNT()`** — подсчитывает количество строк в каждой группе.
- **`SUM()`** — вычисляет сумму значений в группе.
- **`AVG()`** — вычисляет среднее значение в группе.
- **`MIN()`** — находит минимальное значение в группе.
- **`MAX()`** — находит максимальное значение в группе.

#### Пример с `COUNT()`:

Если мы хотим узнать, сколько заказов сделал каждый клиент, можно использовать `COUNT()`:

```sql
SELECT customer_id, COUNT(order_id) AS total_orders
FROM orders
GROUP BY customer_id;
```

#### Результат:
| customer_id | total_orders |
|-------------|--------------|
| 1           | 2            |
| 2           | 1            |
| 3           | 2            |

Этот запрос сгруппировал строки по клиентам и подсчитал количество заказов для каждого клиента.

### `GROUP BY` с несколькими столбцами:

Можно использовать `GROUP BY` с несколькими столбцами для более сложной группировки данных. В этом случае строки группируются по уникальным комбинациям значений в указанных столбцах.

#### Пример:

Допустим, у нас есть таблица `sales` с продажами по месяцам и городам:

| sale_id | month | city      | amount |
|---------|-------|-----------|--------|
| 1       | Jan   | New York  | 100    |
| 2       | Jan   | Boston    | 150    |
| 3       | Feb   | New York  | 200    |
| 4       | Feb   | Boston    | 250    |

Если мы хотим узнать общую сумму продаж по месяцам и городам, мы можем использовать `GROUP BY` для обоих столбцов:

```sql
SELECT month, city, SUM(amount) AS total_sales
FROM sales
GROUP BY month, city;
```

#### Результат:
| month | city     | total_sales |
|-------|----------|-------------|
| Jan   | New York | 100         |
| Jan   | Boston   | 150         |
| Feb   | New York | 200         |
| Feb   | Boston   | 250         |

SQL сгруппировал данные по комбинации месяца и города и вычислил сумму продаж для каждой группы.

### Использование `HAVING` с `GROUP BY`:

Иногда нужно фильтровать группы после того, как они были созданы. Для этого используется оператор **`HAVING`**, который выполняет фильтрацию на уровне групп (в отличие от `WHERE`, который фильтрует строки до группировки).

#### Пример с `HAVING`:

Если мы хотим получить только тех клиентов, которые сделали заказы на общую сумму более 300, можно использовать `HAVING`:

```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id
HAVING SUM(amount) > 300;
```

#### Результат:
| customer_id | total_amount |
|-------------|--------------|
| 3           | 550          |

Этот запрос сначала сгруппировал строки по клиентам, вычислил сумму заказов для каждого клиента, а затем вывел только тех клиентов, у которых сумма заказов больше 300.

### Основные моменты использования `GROUP BY`:

- **Группировка**: `GROUP BY` группирует строки с одинаковыми значениями в указанных столбцах.
- **Агрегатные функции**: Обычно `GROUP BY` используется в сочетании с агрегатными функциями для выполнения вычислений по каждой группе.
- **Фильтрация с `HAVING`**: Для фильтрации результатов группировки используется `HAVING`, так как `WHERE` не работает с агрегатными функциями.

</details>

---

### 15. В чем разница между WHERE и HAVING? Приведите примеры.

<details>
<summary>Раскрыть:</summary>

**`WHERE`** и **`HAVING`** — это два оператора в SQL, которые используются для фильтрации данных в запросах, но они применяются на разных этапах выполнения запроса и имеют разные цели.

### Основные различия между `WHERE` и `HAVING`:

| **Критерий**        | **`WHERE`**                                            | **`HAVING`**                                           |
|---------------------|--------------------------------------------------------|--------------------------------------------------------|
| **Этап фильтрации** | Фильтрует строки **до** группировки и применения агрегатных функций. | Фильтрует группы **после** группировки и применения агрегатных функций. |
| **Применение к агрегатным функциям** | Не может использоваться для фильтрации результатов агрегатных функций. | Может использоваться для фильтрации результатов агрегатных функций. |
| **Контекст использования** | Применяется к отдельным строкам таблицы. | Применяется к группам строк, созданным с помощью `GROUP BY`. |
| **Взаимодействие с `GROUP BY`** | Используется для фильтрации строк **до** группировки. | Используется для фильтрации групп, **после** выполнения группировки. |

### Пример с `WHERE`:

Оператор **`WHERE`** используется для фильтрации строк **до** выполнения каких-либо группировок или агрегатных операций. Он фильтрует данные на уровне строк.

#### Пример 1: Фильтрация данных без использования агрегатных функций

Допустим, у нас есть таблица `orders`, и мы хотим найти все заказы, где сумма заказа больше 100.

```sql
SELECT order_id, customer_id, amount
FROM orders
WHERE amount > 100;
```

Этот запрос вернет все заказы с суммой, превышающей 100, до выполнения каких-либо группировок.

#### Пример данных:

| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 1           | 150    |
| 3        | 2           | 200    |

Результат:
| order_id | customer_id | amount |
|----------|-------------|--------|
| 2        | 1           | 150    |
| 3        | 2           | 200    |

Здесь `WHERE` отфильтровал строки на основе условия `amount > 100`.

### Пример с `HAVING`:

Оператор **`HAVING`** используется для фильтрации данных **после** группировки, а также может применяться для фильтрации результатов агрегатных функций.

#### Пример 2: Использование агрегатных функций с `HAVING`

Допустим, мы хотим узнать, какие клиенты сделали заказы на общую сумму более 200. Для этого мы будем группировать заказы по клиентам и использовать агрегатную функцию `SUM()`.

```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id
HAVING SUM(amount) > 200;
```

#### Пример данных:

| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 1           | 150    |
| 3        | 2           | 200    |

#### Результат:

| customer_id | total_amount |
|-------------|--------------|
| 1           | 250          |
| 2           | 200          |

Здесь:
- Сначала строки сгруппированы по `customer_id`, и для каждой группы посчитана сумма заказов.
- Затем оператор **`HAVING`** отфильтровал результаты, оставив только тех клиентов, у которых общая сумма заказов больше 200.

### Пример совместного использования `WHERE` и `HAVING`:

Оба оператора можно использовать в одном запросе. Например, если мы хотим сначала отфильтровать заказы по сумме (например, убрать заказы меньше 100), а затем отфильтровать клиентов, которые сделали заказы на общую сумму более 300.

#### Пример:

```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
WHERE amount > 100
GROUP BY customer_id
HAVING SUM(amount) > 300;
```

#### Пояснение:
1. **`WHERE`** сначала отфильтрует все заказы, у которых сумма меньше или равна 100.
2. Затем данные будут сгруппированы по клиентам.
3. **`HAVING`** оставит только те группы клиентов, у которых общая сумма заказов больше 300.

#### Пример данных:

| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 1           | 150    |
| 3        | 1           | 200    |
| 4        | 2           | 50     |
| 5        | 2           | 300    |

#### Результат:

| customer_id | total_amount |
|-------------|--------------|
| 1           | 350          |

В этом запросе:
- `WHERE` удалил заказ с `amount = 50`, так как он меньше 100.
- После этого клиент с `customer_id = 1` имел общую сумму заказов 350, что соответствует условию в `HAVING` (`SUM(amount) > 300`)

</details>

---

### 16. В чем разница между операторами DISTINCT и GROUP BY?

<details>
<summary>Раскрыть:</summary>


</details>

---

### 17. Для чего нужны операторы UNION, INTERSECT, EXCEPT?

<details>
<summary>Раскрыть:</summary>

Операторы **`DISTINCT`** и **`GROUP BY`** в SQL используются для работы с дубликатами данных, но они выполняют разные задачи и имеют разные сценарии применения. Вот основные различия:

### 1. **Назначение:**
- **`DISTINCT`**: Используется для **удаления дубликатов** и возвращает только уникальные строки из результата запроса.
- **`GROUP BY`**: Используется для **группировки данных** по одному или нескольким столбцам, часто в сочетании с **агрегатными функциями** (например, `SUM()`, `COUNT()`, `AVG()`), чтобы применить вычисления к каждой группе данных.

### 2. **Применение агрегатных функций:**
- **`DISTINCT`**: Не поддерживает прямую работу с агрегатными функциями (кроме как в контексте самой функции, например, `COUNT(DISTINCT)`).
- **`GROUP BY`**: Чаще всего используется с агрегатными функциями, такими как `COUNT()`, `SUM()`, `AVG()`, чтобы применить вычисления к каждой группе данных.

### 3. **Фильтрация данных:**
- **`DISTINCT`**: Удаляет дубликаты строк, возвращая уникальные записи на основе всех столбцов, указанных в запросе.
- **`GROUP BY`**: Группирует строки по указанным столбцам, и каждая группа может содержать несколько строк. Затем к этим группам могут быть применены агрегатные функции.

#### Пример 1: Использование `DISTINCT`

Предположим, у нас есть таблица `orders`:

| order_id | customer_id | amount |
|----------|-------------|--------|
| 1        | 1           | 100    |
| 2        | 1           | 150    |
| 3        | 2           | 200    |
| 4        | 2           | 200    |

Теперь, если мы хотим получить список уникальных клиентов, мы можем использовать `DISTINCT`:

```sql
SELECT DISTINCT customer_id
FROM orders;
```

#### Результат:

| customer_id |
|-------------|
| 1           |
| 2           |

Здесь `DISTINCT` вернул уникальные значения `customer_id` и удалил дублирующие записи. Даже если клиент сделал несколько заказов, он будет отображен только один раз.

#### Пример 2: Использование `GROUP BY`

Теперь, если мы хотим узнать, сколько заказов сделал каждый клиент, мы можем использовать `GROUP BY` вместе с агрегатной функцией `COUNT()`:

```sql
SELECT customer_id, COUNT(order_id) AS total_orders
FROM orders
GROUP BY customer_id;
```

#### Результат:

| customer_id | total_orders |
|-------------|--------------|
| 1           | 2            |
| 2           | 2            |

Здесь `GROUP BY` сгруппировал строки по `customer_id`, и для каждой группы посчитано количество заказов. В отличие от `DISTINCT`, который просто удаляет дубликаты, `GROUP BY` позволяет нам выполнить вычисления для каждой группы данных.

### Пример с числовыми агрегатами:

Предположим, что мы хотим узнать общую сумму заказов для каждого клиента:

```sql
SELECT customer_id, SUM(amount) AS total_amount
FROM orders
GROUP BY customer_id;
```

#### Результат:

| customer_id | total_amount |
|-------------|--------------|
| 1           | 250          |
| 2           | 400          |

В этом случае `GROUP BY` снова группирует строки по `customer_id`, но уже суммирует значения в столбце `amount` для каждой группы.

### Дополнительные примеры:

#### Пример 3: `DISTINCT` с несколькими столбцами

`DISTINCT` также может быть применен к нескольким столбцам, чтобы вернуть уникальные комбинации значений.

```sql
SELECT DISTINCT customer_id, amount
FROM orders;
```

#### Результат:

| customer_id | amount |
|-------------|--------|
| 1           | 100    |
| 1           | 150    |
| 2           | 200    |

Здесь `DISTINCT` удаляет дубликаты строк, но рассматривает комбинацию двух столбцов, поэтому каждая строка с уникальной комбинацией значений возвращается.

#### Пример 4: `GROUP BY` с несколькими столбцами

`GROUP BY` также может быть применен к нескольким столбцам, чтобы сгруппировать данные по комбинациям значений в этих столбцах.

```sql
SELECT customer_id, amount, COUNT(order_id) AS total_orders
FROM orders
GROUP BY customer_id, amount;
```

#### Результат:

| customer_id | amount | total_orders |
|-------------|--------|--------------|
| 1           | 100    | 1            |
| 1           | 150    | 1            |
| 2           | 200    | 2            |

Здесь строки сгруппированы по комбинации `customer_id` и `amount`, и для каждой такой группы посчитано количество заказов.

### Основные выводы:

- **`DISTINCT`** удаляет дублирующиеся строки из результата запроса и используется для получения уникальных значений, но не работает с агрегатными функциями напрямую.
- **`GROUP BY`** группирует строки по указанным столбцам и чаще всего используется с агрегатными функциями для выполнения вычислений на уровне групп (например, подсчета количества записей, суммирования значений и т.д.).

**Когда использовать `DISTINCT`:**
- Если нужно получить уникальные строки из набора данных.
- Пример: получение списка уникальных клиентов, товаров, категорий и т.д.

**Когда использовать `GROUP BY`:**
- Если нужно сгруппировать данные и применить агрегатные функции, такие как `SUM()`, `COUNT()`, `AVG()` и другие.
- Пример: подсчет заказов, суммирование продаж по категориям, расчет средней цены товаров в каждой категории и т.д.

</details>

---

### 18. Опишите разницу типов данных DATETIME и TIMESTAMP

<details>
<summary>Раскрыть:</summary>

### Основные различия:

| **Характеристика**       | **DATETIME**                                | **TIMESTAMP**                              |
|--------------------------|---------------------------------------------|--------------------------------------------|
| **Диапазон значений**     | От `'1000-01-01 00:00:00'` до `'9999-12-31 23:59:59'` | От `'1970-01-01 00:00:01'` до `'2038-01-19 03:14:07'` |
| **Хранение в БД**         | Хранит **абсолютное** значение даты и времени. | Хранит значение как **Unix-время** (количество секунд с 1970 года). |
| **Часовой пояс**          | Не зависит от часового пояса.                | Зависит от часового пояса сервера или клиента. |
| **Автоматическое обновление** | Не поддерживает автоматическое обновление при изменении записи. | Может автоматически обновляться при изменении записи, если указано. |
| **Размер хранения**       | 8 байт.                                     | 4 байта (если не используется поддержка микросекунд). |
| **Использование с UTC**   | Не поддерживает автоматическую конвертацию в UTC и обратно. | Хранит значение как UTC и автоматически конвертирует его в текущий часовой пояс при выводе. |

### Подробное сравнение:

1. **Диапазон значений**:
    - **`DATETIME`**: Хранит дату и время в диапазоне от **1000 года** до **9999 года**, что делает его более гибким для работы с датами в далеком прошлом или будущем.
    - **`TIMESTAMP`**: Ограничен диапазоном от **1 января 1970 года** до **19 января 2038 года**. Это связано с тем, что `TIMESTAMP` хранит время как количество секунд с **1970-01-01 00:00:00 UTC** (так называемое **Unix-время**).

2. **Хранение в базе данных**:
    - **`DATETIME`**: Хранит дату и время как текстовое представление, что делает его независимым от часовых поясов. Это полезно, когда вам нужно хранить конкретные значения времени, которые не должны зависеть от местоположения.
    - **`TIMESTAMP`**: Хранит значение как число секунд с **1 января 1970 года**, что делает его зависимым от часовых поясов и времени сервера.

3. **Часовые пояса**:
    - **`DATETIME`**: Не зависит от часового пояса. Если вы сохраните `DATETIME`, оно останется таким же независимо от изменения часового пояса системы или пользователя.
    - **`TIMESTAMP`**: Привязан к UTC и автоматически конвертируется в локальное время в зависимости от настроек сервера или клиента. Это полезно для хранения времени событий, которые могут произойти в разных часовых поясах.

4. **Автоматическое обновление**:
    - **`DATETIME`**: Не поддерживает автоматическое обновление при изменении записи.
    - **`TIMESTAMP`**: Может быть настроен для автоматического обновления при вставке или изменении записи. Это часто используется для создания временных меток последнего обновления данных (`created_at` или `updated_at`).

   Например, можно установить поле `TIMESTAMP` так, чтобы оно автоматически обновлялось при каждом изменении записи:
   ```sql
   CREATE TABLE example (
       id INT,
       modified TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
   );
   ```

5. **Размер хранения**:
    - **`DATETIME`**: Требует 8 байт для хранения.
    - **`TIMESTAMP`**: Требует 4 байта (или 7, если используется точность микросекунд), что делает его более эффективным с точки зрения использования памяти.

6. **Работа с UTC**:
    - **`DATETIME`**: Хранит значения без привязки к UTC. Если вы сохраняете `DATETIME`, оно будет таким, каким вы его задали, без конвертации в UTC и обратно.
    - **`TIMESTAMP`**: Всегда хранит данные в UTC и автоматически конвертирует их в локальное время при выводе. Это полезно для систем, где важно учитывать временные зоны.

### Когда использовать `DATETIME`, а когда `TIMESTAMP`?

- **Используйте `DATETIME`**, если:
    - Вам нужно хранить дату и время, которые не должны изменяться в зависимости от часовых поясов.
    - Диапазон дат выходит за пределы диапазона `TIMESTAMP` (например, даты до 1970 года или после 2038 года).
    - Время важно фиксировать точно в том виде, в котором оно было введено, без учета временной зоны.

- **Используйте `TIMESTAMP`**, если:
    - Вам нужно учитывать часовые пояса и хотите, чтобы значения времени автоматически конвертировались в локальное время.
    - Вы работаете с данными, которые нужно привязать к UTC (например, для регистрации времени событий в системе).
    - Нужно автоматическое обновление временных меток при вставке или обновлении данных (например, для полей `created_at` и `updated_at`).

### Заключение:

- **`DATETIME`** — это тип данных для хранения абсолютного времени без учета часовых поясов, с более широким диапазоном дат.
- **`TIMESTAMP`** — это тип данных для хранения времени с учетом временных зон и автоматической конвертацией в UTC, который более эффективен в плане хранения данных, но имеет ограниченный диапазон значений.

Оба типа данных полезны в зависимости от того, как вам нужно обрабатывать время в приложении: с учетом временной зоны или без нее.

</details>

---

### 19. Какие вы знаете двигатели таблиц и чем они отличаются?

<details>
<summary>Раскрыть:</summary>

В реляционных базах данных **двигатели таблиц** (или **механизмы хранения**) определяют, как данные хранятся, организуются и обрабатываются на физическом уровне. В различных СУБД существуют разные механизмы хранения, и каждая система предлагает свои варианты. Например, в MySQL наиболее популярными являются **InnoDB** и **MyISAM**.

### Основные двигатели таблиц в MySQL:

#### 1. **InnoDB**
**InnoDB** — это современный и наиболее часто используемый механизм хранения в MySQL. Он является движком по умолчанию с MySQL 5.5.

**Основные характеристики**:
- **Поддержка транзакций**: InnoDB поддерживает транзакции с использованием модели ACID (атомарность, согласованность, изоляция, долговечность). Это обеспечивает целостность данных и надежное восстановление в случае сбоя.
- **Поддержка внешних ключей**: InnoDB поддерживает внешние ключи и поддерживает **ссылочную целостность** данных.
- **Блокировки на уровне строк**: InnoDB использует блокировки на уровне строк, что улучшает производительность при одновременном доступе к данным из нескольких транзакций.
- **Кластерный индекс**: Первичный ключ таблицы в InnoDB используется как кластерный индекс, что означает, что данные физически сортируются по значению первичного ключа.
- **Надежность**: InnoDB обеспечивает безопасное хранение данных и журналирование изменений, что позволяет откатывать транзакции или восстанавливать данные после сбоя.

**Когда использовать**:
- Если вам важны транзакции и целостность данных.
- Когда нужна поддержка внешних ключей и блокировок на уровне строк для параллельной обработки данных.

#### 2. **MyISAM**
**MyISAM** — это более старый механизм хранения, который использовался по умолчанию до версии MySQL 5.5. Сейчас его использование снижается в пользу InnoDB.

**Основные характеристики**:
- **Отсутствие поддержки транзакций**: MyISAM не поддерживает транзакции и не обеспечивает целостность данных на уровне транзакций.
- **Отсутствие поддержки внешних ключей**: В MyISAM отсутствует поддержка внешних ключей и ссылочной целостности.
- **Блокировки на уровне таблиц**: MyISAM использует блокировки на уровне всей таблицы. Это может снижать производительность при большом количестве конкурентных запросов на запись.
- **Быстрое чтение**: MyISAM может работать быстрее на операциях **чтения**, чем InnoDB, благодаря более простому механизму хранения.
- **Размер таблиц**: MyISAM поддерживает большие таблицы (до 256 ТБ).

**Когда использовать**:
- В системах, где важны высокоскоростные операции чтения и нет необходимости в транзакциях или поддержке внешних ключей.

#### 3. **MEMORY (HEAP)**
**MEMORY** (или **HEAP**) — это механизм хранения, который хранит данные в оперативной памяти (RAM), что делает операции чтения и записи чрезвычайно быстрыми.

**Основные характеристики**:
- **Хранение в памяти**: Данные в таблицах MEMORY хранятся только в оперативной памяти, а не на диске. Это делает операции чрезвычайно быстрыми, но данные теряются при перезагрузке сервера.
- **Отсутствие долговременного хранения**: Так как данные не сохраняются на диске, они будут потеряны при перезапуске или сбое системы.
- **Используется для временных таблиц**: MEMORY часто используется для временных данных или кеширования.

**Когда использовать**:
- Когда нужна очень высокая скорость работы с временными данными, и потеря данных при перезагрузке системы не критична.

#### 4. **CSV**
**CSV** (Comma-Separated Values) — это механизм хранения, который хранит данные в виде текстовых файлов с разделителями, обычно используется для простого импорта/экспорта данных.

**Основные характеристики**:
- **Хранение данных в виде текстовых файлов**: Данные хранятся в виде файлов CSV на диске, что делает их легко доступными для импорта и экспорта.
- **Отсутствие индексов**: Механизм CSV не поддерживает индексы, что делает работу с большими объемами данных менее эффективной.

**Когда использовать**:
- Когда требуется экспорт данных в формате CSV или интеграция с внешними системами.

#### 5. **ARCHIVE**
**ARCHIVE** — это механизм хранения, который предназначен для хранения больших объемов данных, которые редко изменяются, но могут быть часто запрашиваемы.

**Основные характеристики**:
- **Сжатие данных**: ARCHIVE поддерживает сжатие данных, что экономит место на диске.
- **Только для чтения и вставки**: Механизм ARCHIVE поддерживает операции вставки и чтения, но не поддерживает обновление и удаление данных.
- **Отсутствие индексов**: ARCHIVE не поддерживает индексы, за исключением автоматически созданного индекса для первичного ключа.

**Когда использовать**:
- Для хранения архивных данных, которые редко изменяются, но могут быть запрашиваемы для анализа.

#### 6. **BLACKHOLE**
**BLACKHOLE** — это необычный механизм хранения, который не сохраняет данные вообще. Данные, вставленные в таблицу с этим механизмом, просто "исчезают".

**Основные характеристики**:
- **Отсутствие сохранения данных**: BLACKHOLE не сохраняет данные ни в памяти, ни на диске. Это полезно для тестирования или для маршрутизации данных.
- **Использование в репликации**: BLACKHOLE иногда используется для репликации данных, когда сервер должен принимать данные, но не хранить их локально.

**Когда использовать**:
- Для тестирования или при настройке сложной репликации, где данные должны быть переданы, но не сохранены.

### Другие популярные механизмы хранения в других СУБД:

#### 1. **PostgreSQL**
PostgreSQL не имеет концепции различных механизмов хранения, как в MySQL, поскольку поддержка транзакций, внешних ключей, индексов и других функций встроена в саму СУБД.

Однако PostgreSQL поддерживает:
- **TOAST** (The Oversized-Attribute Storage Technique): Это механизм для хранения больших данных в столбцах, которые превышают стандартный размер строки.
- **Partitioning**: Для хранения больших таблиц по частям для повышения производительности.

#### 2. **SQLite**
SQLite также использует единый механизм хранения и не имеет такого множества вариантов, как MySQL. Он сохраняет данные в одном файле базы данных, что упрощает развертывание.

#### 3. **Oracle**
Oracle имеет несколько механизмов хранения для оптимизации производительности и управления данными, такие как **ASSM (Automatic Segment Space Management)** и **IOT (Index Organized Tables)**, которые позволяют лучше управлять пространством и оптимизировать доступ к данным.

### Заключение:

- **InnoDB** — это основной механизм хранения в MySQL, который обеспечивает надежную работу с транзакциями, внешними ключами и высокой параллельностью.
- **MyISAM** — старый механизм, который подходит для систем, где важна скорость чтения и не нужны транзакции.
- **MEMORY** и **ARCHIVE** — это специализированные механизмы для хранения временных данных в оперативной памяти или архивных данных.
- **CSV** и **BLACKHOLE** — менее распространенные механизмы, которые используются для специфических задач.

</details>

---

### 20. Какие способы оптимизации производительности баз данных знаете?

<details>
<summary>Раскрыть:</summary>

### 1. **Оптимизация запросов (SQL Query Optimization)**

#### 1.1. **Использование индексов**
Индексы позволяют значительно ускорить выполнение запросов, особенно при работе с большими таблицами.
- **Создание индексов** на столбцы, которые часто используются в условиях `WHERE`, `JOIN`, `GROUP BY`, и `ORDER BY`.
- Использование **составных индексов** для часто запрашиваемых комбинаций столбцов.

Пример:
```sql
CREATE INDEX idx_customer_id ON orders (customer_id);
```

#### 1.2. **Избегание выборок всех полей (`SELECT *`)**
Запросы с `SELECT *` загружают все столбцы таблицы, что может замедлить работу. Лучше запрашивать только те столбцы, которые нужны.
- Пример:
  ```sql
  SELECT name, email FROM customers WHERE id = 1;
  ```

#### 1.3. **Использование ограничений (`LIMIT`)**
Если вам не нужно большое количество строк, лучше использовать `LIMIT` для ограничения результата, что сократит нагрузку на базу данных.

Пример:
```sql
SELECT * FROM orders ORDER BY created_at DESC LIMIT 10;
```

#### 1.4. **Избегание подзапросов (использование `JOIN`)**
Вместо подзапросов лучше использовать `JOIN`, так как это более эффективно с точки зрения производительности.

Пример:
```sql
-- Неэффективный подзапрос
SELECT * FROM orders WHERE customer_id = (SELECT id FROM customers WHERE email = 'test@example.com');

-- Эффективный запрос с JOIN
SELECT o.* FROM orders o JOIN customers c ON o.customer_id = c.id WHERE c.email = 'test@example.com';
```

#### 1.5. **Использование агрегатных функций и фильтрации**
Используйте агрегатные функции (`COUNT`, `SUM`, `AVG`) и фильтры (`HAVING`) с осторожностью и только по мере необходимости. При их частом использовании на больших объемах данных производительность может сильно пострадать.

### 2. **Использование индексов**

Индексы позволяют ускорить поиск и сортировку данных, но важно грамотно выбирать, где и как их использовать:
- **Индексы на ключевые столбцы** (`PRIMARY KEY`, `FOREIGN KEY`).
- Создавайте индексы на столбцы, которые часто участвуют в операциях поиска (`WHERE`), сортировки (`ORDER BY`) или фильтрации (`GROUP BY`).
- **Избегайте создания слишком большого количества индексов**, так как это замедлит операции вставки, обновления и удаления.

Пример создания индекса:
```sql
CREATE INDEX idx_orders_customer ON orders (customer_id);
```

### 3. **Кеширование результатов запросов**

#### 3.1. **Использование механизмов кеширования**
- **Кеширование часто выполняемых запросов** может существенно снизить нагрузку на базу данных. Инструменты вроде **Redis** или **Memcached** могут помочь сохранять результаты частых и одинаковых запросов.
- **MySQL Query Cache**: В MySQL ранее был встроенный механизм кеширования запросов, однако он был удален начиная с версии 8.0, поэтому рекомендуется использовать внешние кеши.

#### 3.2. **Использование кеширования на уровне приложения**
Если результаты запроса редко меняются, можно кешировать их на стороне приложения (например, с помощью Redis) и обновлять кеш при изменении данных.

### 4. **Оптимизация структуры базы данных**

#### 4.1. **Нормализация базы данных**
Нормализация базы данных помогает уменьшить избыточность данных и избежать дублирования. Основные формы нормализации включают:
- **1NF**: Все столбцы содержат атомарные значения.
- **2NF**: Удаление частичных зависимостей.
- **3NF**: Удаление транзитивных зависимостей.

#### 4.2. **Денормализация** (при необходимости)
В некоторых случаях для повышения производительности могут использоваться **денормализованные таблицы** — это обратный процесс нормализации. Денормализация может сократить количество `JOIN`-операций за счет хранения связанных данных в одной таблице.

#### 4.3. **Архивирование данных**
Удаление старых и редко используемых данных или перемещение их в архивные таблицы помогает уменьшить размер активных таблиц и ускорить работу запросов.

### 5. **Шардирование и репликация**

#### 5.1. **Шардирование (Sharding)**
Шардирование — это процесс разделения таблицы на более мелкие части (шарды) на разных серверах. Это позволяет распределить нагрузку между несколькими серверами и увеличить масштабируемость.
- Пример: Разделение таблицы пользователей по географическому признаку.

#### 5.2. **Репликация**
Репликация данных на несколько серверов позволяет распределить чтение по разным репликам, уменьшая нагрузку на основной сервер.
- Пример: В MySQL можно настроить **мастер-слейв репликацию**, где основной сервер обрабатывает записи, а реплики — запросы на чтение.

### 6. **Оптимизация операций ввода-вывода**

#### 6.1. **Использование индексов с фильтрацией**
Некоторые СУБД, например PostgreSQL, поддерживают **частичные индексы**. Они индексируют только те строки, которые соответствуют определенному условию.

Пример:
```sql
CREATE INDEX idx_active_customers ON customers (last_name) WHERE status = 'active';
```

#### 6.2. **Параллельные запросы**
Некоторые СУБД поддерживают **параллельное выполнение запросов** для увеличения скорости обработки данных, особенно в сложных аналитических запросах.

### 7. **Оптимизация блокировок (Locking)**

#### 7.1. **Использование правильных типов блокировок**
- Используйте **блокировки на уровне строк**, если работаете с конкретными записями, чтобы избежать блокировки всей таблицы.
- Избегайте длительных транзакций, которые могут удерживать блокировки слишком долго.

#### 7.2. **Оптимизация транзакций**
- Минимизируйте длительность транзакций: чем быстрее транзакции, тем меньше блокировок, что повышает параллелизм.

Пример:
```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;
COMMIT;
```

### 8. **Мониторинг и профилирование**

#### 8.1. **Использование EXPLAIN для анализа запросов**
Команда **`EXPLAIN`** в SQL помогает увидеть, как база данных планирует выполнить запрос, какие индексы используются и где происходят узкие места.

Пример:
```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 1;
```

#### 8.2. **Мониторинг производительности**
Инструменты мониторинга, такие как **Percona Monitoring and Management (PMM)**, **New Relic**, или встроенные утилиты СУБД (например, **MySQL Performance Schema**), могут помочь отслеживать медленные запросы, потребление ресурсов и общую производительность базы данных.

### 9. **Аппаратная оптимизация**

#### 9.1. **Оптимизация использования памяти**
- Увеличение объема памяти сервера позволяет хранить больше данных в кэше, что ускоряет доступ к часто запрашиваемым данным.

#### 9.2. **Использование SSD-дисков**
- Использование SSD-дисков для хранения базы данных может значительно ускорить операции ввода-вывода по сравнению с HDD

</details>

---

### 21. Что такое партицирование, репликация и шардинг?

<details>
<summary>Раскрыть:</summary>

### 1. **Партицирование (Partitioning)**

**Партицирование** — это процесс разделения таблицы на более мелкие части, называемые **партициями**, для облегчения работы с большими объемами данных. Каждая партиция содержит подмножество строк исходной таблицы, и каждая партиция хранится отдельно. Партицирование помогает ускорить запросы, улучшить производительность и упростить управление данными.

#### Виды партицирования:
1. **Диапазонное партицирование (Range Partitioning)**:
    - Таблица делится на партиции по диапазону значений в столбце.
    - Пример: Разделение таблицы заказов по диапазонам дат.
   ```sql
   PARTITION BY RANGE (order_date) (
       PARTITION p0 VALUES LESS THAN ('2021-01-01'),
       PARTITION p1 VALUES LESS THAN ('2022-01-01'),
       PARTITION p2 VALUES LESS THAN (MAXVALUE)
   );
   ```

2. **Хэширование (Hash Partitioning)**:
    - Таблица делится на партиции по хэш-функции, которая распределяет строки на основе значения ключевого столбца.
    - Пример: Разделение клиентов по хэш-функции их ID.
   ```sql
   PARTITION BY HASH (customer_id);
   ```

3. **Списковое партицирование (List Partitioning)**:
    - Строки распределяются по партициям на основе конкретных значений столбца.
    - Пример: Разделение таблицы пользователей по странам.
   ```sql
   PARTITION BY LIST (country) (
       PARTITION p_usa VALUES IN ('USA'),
       PARTITION p_canada VALUES IN ('Canada')
   );
   ```

4. **Комбинированное партицирование (Composite Partitioning)**:
    - Сочетание нескольких типов партицирования. Например, можно сначала разделить таблицу по диапазону дат, а затем по хэш-функции.

#### Преимущества партицирования:
- **Ускорение запросов**: Только нужные партиции сканируются для выполнения запросов, что ускоряет работу с большими таблицами.
- **Улучшение управления данными**: Легче управлять и архивировать части данных (например, старые данные).
- **Разделение нагрузки**: Партиции могут храниться на разных устройствах или серверах, что уменьшает нагрузку на отдельные компоненты.

### 2. **Репликация (Replication)**

**Репликация** — это процесс копирования данных с одного сервера базы данных на другие. Основная цель репликации — обеспечить доступность данных и улучшить производительность за счет распределения нагрузки между несколькими серверами.

#### Виды репликации:
1. **Мастер-слейв репликация (Master-Slave)**:
    - Один сервер (мастер) принимает все запросы на запись, а слейвы получают копии данных и обслуживают запросы на чтение. Это снижает нагрузку на мастер-сервер.
    - Пример: Мастер-сервер обновляет данные, а реплики обрабатывают только запросы на чтение.

2. **Мульти-мастер репликация (Multi-Master)**:
    - Несколько серверов могут выполнять операции записи одновременно, и изменения реплицируются между серверами. Это сложнее в реализации из-за необходимости разрешения конфликтов данных.
    - Пример: Сервера в разных регионах могут одновременно обрабатывать запросы на запись.

3. **Асинхронная репликация (Asynchronous Replication)**:
    - Мастер отправляет изменения на слейвы с задержкой, что может привести к тому, что данные на слейвах будут не актуальными в определенные моменты времени. Это быстрее, но менее надежно.

4. **Синхронная репликация (Synchronous Replication)**:
    - Мастер гарантирует, что все изменения данных реплицированы на слейвы в реальном времени. Это надежнее, но может замедлить работу системы из-за необходимости ожидания подтверждения от слейвов.

#### Преимущества репликации:
- **Высокая доступность данных**: Данные остаются доступными даже при сбое одного из серверов.
- **Распределение нагрузки**: Слейв-серверы могут обслуживать запросы на чтение, что снижает нагрузку на основной сервер.
- **Резервирование данных**: Репликация создает резервные копии данных, что улучшает отказоустойчивость системы.

### 3. **Шардирование (Sharding)**

**Шардирование (Sharding)** — это процесс горизонтального разделения данных на несколько **шардов**, или подмножества, которые могут храниться на разных серверах. Каждый шард содержит часть данных из таблицы, и запросы к базе данных направляются на соответствующий шард на основе значения ключа.

#### Как работает шардирование:
- **Горизонтальное разделение**: Каждая строка таблицы распределяется на разные серверы (шарды) на основе определенного ключа (например, идентификатор пользователя).
- **Ключ шардирования**: Это поле, по которому данные распределяются по шардам (например, по географическому признаку или ID пользователя).
- **Шарды обрабатываются независимо**: Каждый шард — это полноценная база данных, которая обслуживает часть данных. Запросы к базе данных направляются на нужный шард.

#### Пример:
Предположим, у нас есть большая таблица пользователей. Мы можем разделить данные на несколько шардов по идентификатору пользователя:
- Пользователи с ID от 1 до 1 000 000 будут храниться на первом шарде.
- Пользователи с ID от 1 000 001 до 2 000 000 — на втором шарде, и так далее.

#### Преимущества шардирования:
- **Горизонтальная масштабируемость**: Шардирование позволяет эффективно распределять нагрузку между несколькими серверами, увеличивая возможности масштабирования базы данных.
- **Улучшение производительности**: За счет разделения данных на шарды уменьшается объем данных, обрабатываемых на каждом сервере, что ускоряет выполнение запросов.
- **Уменьшение риска перегрузки**: Разделение данных на шарды позволяет избежать перегрузки одного сервера, поскольку данные и запросы равномерно распределяются.

#### Проблемы шардирования:
- **Сложность управления**: Шардирование добавляет сложность в управлении базой данных, поскольку необходимо эффективно распределять данные между шардами.
- **Масштабируемость шардов**: Важно предусмотреть механизм добавления новых шардов при увеличении объема данных.
- **Межшардовые запросы**: Запросы, которые требуют данных из нескольких шардов, могут стать сложнее и медленнее в выполнении.

### Сравнение:

| **Характеристика**         | **Партицирование**                               | **Репликация**                                | **Шардирование**                               |
|----------------------------|--------------------------------------------------|------------------------------------------------|------------------------------------------------|
| **Основная цель**           | Разделение таблиц для ускорения запросов.         | Создание копий данных для повышения доступности и распределения нагрузки. | Горизонтальное разделение данных между серверами для масштабируемости. |
| **Способ разделения данных**| Деление таблицы на партиции по ключевым признакам (диапазон, хэш и т.д.). | Полное копирование данных на другие сервера.   | Данные разделяются на несколько независимых частей (шардов). |
| **Использование индексов**  | Индексы применяются к каждой партиции.            | Индексы наследуются репликами от основного сервера. | Каждая база данных (шард) имеет свои индексы.  |
| **Масштабируемость**        | Масштабируемость внутри одной базы данных.        | Повышение масштабируемости при чтении (реплики обрабатывают запросы). | Высокая масштабируемость, так как каждый шард является независимым. |
| **Риски**                  | Сложность в управлении партициями.                | Возможны проблемы синхронизации данных.        | Трудности с межшардовыми запросами и добавлением новых шардов. |

### Заключение:

- **Партицирование** позволяет разбить таблицу на части для улучшения производительности запросов и удобства управления данными.
- **Репликация** помогает повысить доступность данных и распределить нагрузку за счет копирования данных на другие сервера.
- **Шардирование** позволяет горизонтально масштабировать базу данных, разделяя данные на независимые части, которые могут храниться на разных серверах.

</details>

---

### 22. Чем отличаются SQL от NoSQL базы данных?

<details>
<summary>Раскрыть:</summary>

### Основные отличия между SQL и NoSQL базами данных:

| **Характеристика**        | **SQL базы данных**                            | **NoSQL базы данных**                         |
|---------------------------|-------------------------------------------------|-----------------------------------------------|
| **Структура данных**       | Реляционная модель с таблицами (строки и столбцы). | Нереляционные модели (документы, ключ-значение, графы и т.д.). |
| **Язык запросов**          | Используют SQL (Structured Query Language) для запросов. | Используют различные API или языки запросов, в зависимости от типа базы. |
| **Схема данных**           | Строгая схема с фиксированными столбцами и типами данных. | Гибкая схема: данные могут иметь разную структуру, изменения в структуре не требуют изменения схемы. |
| **Масштабируемость**       | Вертикальная (улучшение одного сервера).        | Горизонтальная (добавление новых серверов/узлов). |
| **Поддержка транзакций**   | Поддержка транзакций ACID (атомарность, согласованность, изоляция, долговечность). | Поддержка BASE (гибкость и доступность, но возможна непоследовательность). |
| **Типы данных**            | Таблицы с четко определенными типами данных (числа, строки, даты и т.д.). | Поддержка более свободных типов данных, таких как JSON, ключ-значение, бинарные данные. |
| **Связи между данными**    | Поддержка сложных связей (JOIN, внешние ключи). | Часто отсутствуют связи, данные денормализованы. |
| **Поддержка операций JOIN** | Поддерживаются для объединения данных из нескольких таблиц. | JOIN-операции отсутствуют или ограничены, данные обычно хранятся в одной коллекции. |
| **Использование**          | Подходит для систем, где важны структурированные данные и согласованность (банки, бухгалтерия, ERP-системы). | Подходит для высокомасштабируемых систем с большой нагрузкой, где важна скорость и гибкость (социальные сети, интернет-магазины, Big Data). |

### Подробное описание:

#### 1. **Структура данных**

- **SQL базы данных**: Данные хранятся в реляционных таблицах с фиксированной структурой (строки и столбцы). Каждая таблица имеет четко определенные поля с типами данных, и схема данных (структура таблицы) должна быть строго соблюдена.
    - Примеры SQL баз: MySQL, PostgreSQL, Microsoft SQL Server, Oracle.

- **NoSQL базы данных**: Данные хранятся в нереляционных структурах, таких как:
    - **Документы** (например, JSON-структуры в MongoDB),
    - **Ключ-значение** (например, Redis),
    - **Графы** (например, Neo4j),
    - **Колонко-ориентированные** (например, Cassandra, HBase).

  В NoSQL базах данных структура данных более гибкая, данные могут иметь разную структуру, и схема может изменяться динамически.

#### 2. **Язык запросов**

- **SQL базы данных**: Используют стандартный язык запросов SQL, который позволяет выполнять сложные запросы, фильтрацию, сортировку, агрегатные функции, объединение таблиц через `JOIN` и другие операции.

  Пример запроса SQL:
  ```sql
  SELECT * FROM customers WHERE age > 30;
  ```

- **NoSQL базы данных**: В зависимости от типа базы данных используются различные API или специфичные для базы языки запросов. Например, MongoDB использует JSON-подобные запросы:
  ```json
  db.customers.find({ "age": { "$gt": 30 } });
  ```

#### 3. **Схема данных**

- **SQL базы данных**: Имеют строго определенную схему. Перед добавлением данных таблицы должны быть созданы с четко определенными столбцами и типами данных. Изменение структуры таблицы требует изменения схемы.

- **NoSQL базы данных**: Схема данных гибкая, данные могут иметь различную структуру в рамках одной и той же коллекции или таблицы. Например, в одной коллекции документов могут находиться документы с разными полями.

#### 4. **Масштабируемость**

- **SQL базы данных**: Чаще всего масштабируются **вертикально**, то есть за счет улучшения аппаратных характеристик одного сервера (увеличение оперативной памяти, процессорной мощности, дискового пространства). Горизонтальное масштабирование (разделение данных между несколькими серверами) в SQL базах данных более сложное и требует использования репликации или шардинга.

- **NoSQL базы данных**: Обычно масштабируются **горизонтально**, что означает, что можно добавлять новые серверы или узлы для хранения и обработки данных. Это позволяет более гибко распределять нагрузку при увеличении объема данных и запросов.

#### 5. **Поддержка транзакций**

- **SQL базы данных**: Поддерживают транзакции с соблюдением принципов **ACID**:
    - **Атомарность** (каждая транзакция либо выполняется целиком, либо не выполняется вообще),
    - **Согласованность** (данные после выполнения транзакции остаются в согласованном состоянии),
    - **Изоляция** (одна транзакция не влияет на выполнение других),
    - **Долговечность** (результаты транзакций сохраняются даже при сбоях).

- **NoSQL базы данных**: Следуют принципам **BASE** (Basically Available, Soft state, Eventual consistency):
    - **Гибкая доступность** (система всегда доступна для чтения и записи),
    - **Слабая согласованность** (данные могут быть временно неконсистентными),
    - **Конечная согласованность** (данные становятся консистентными через определенное время).

  Некоторые NoSQL базы данных (например, MongoDB) поддерживают транзакции, но это ограничено небольшими наборами операций.

#### 6. **Связи между данными**

- **SQL базы данных**: Поддерживают сложные связи между таблицами с использованием **внешних ключей** и операций **JOIN**, что позволяет строить сложные отношения между данными.

- **NoSQL базы данных**: В большинстве случаев данные хранятся в **денормализованной форме**, что означает отсутствие сложных связей между коллекциями или таблицами. Все необходимые данные могут быть сохранены в одном документе, чтобы избежать выполнения сложных запросов.

#### 7. **Примеры использования**

- **SQL базы данных**: Используются там, где важны строгие отношения между данными и согласованность. Примеры использования: банковские системы, бухгалтерские системы, ERP-системы.

- **NoSQL базы данных**: Используются там, где важна гибкость, горизонтальная масштабируемость и высокая скорость работы с большими объемами данных. Примеры использования: социальные сети, интернет-магазины, системы управления контентом, аналитика данных.

### Когда выбирать SQL, а когда NoSQL:

- **Выбор SQL**:
    - Когда важны строгие отношения между данными и транзакции.
    - Когда требуется высокая согласованность данных.
    - Если требуется выполнение сложных запросов с использованием `JOIN`.

- **Выбор NoSQL**:
    - Когда система должна обрабатывать большие объемы данных с высокой скоростью.
    - Когда структура данных гибкая и может меняться.
    - Если требуется горизонтальная масштабируемость и низкая задержка.

</details>

---

### 23. Какие типы данных есть в MySQL и PostgreSQL?

<details>
<summary>Раскрыть:</summary>

### Типы данных в MySQL и PostgreSQL

#### 1. **Числовые типы данных**

| **Тип данных**       | **MySQL**                           | **PostgreSQL**                      | **Описание** |
|----------------------|--------------------------------------|-------------------------------------|--------------|
| **TINYINT**           | Да                                  | Нет                                 | Целое число от -128 до 127 или от 0 до 255 (при UNSIGNED). |
| **SMALLINT**          | Да                                  | Да                                  | Целое число от -32,768 до 32,767 или от 0 до 65,535 (при UNSIGNED). |
| **MEDIUMINT**         | Да                                  | Нет                                 | Целое число от -8,388,608 до 8,388,607 или от 0 до 16,777,215 (при UNSIGNED). |
| **INT/INTEGER**       | Да                                  | Да                                  | Целое число от -2,147,483,648 до 2,147,483,647 или от 0 до 4,294,967,295 (при UNSIGNED). |
| **BIGINT**            | Да                                  | Да                                  | Большое целое число от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 или от 0 до 18,446,744,073,709,551,615 (при UNSIGNED). |
| **SERIAL**            | Нет                                 | Да                                  | Автоматическое увеличение целого числа (аналог AUTO_INCREMENT). |
| **FLOAT**             | Да                                  | Да                                  | Число с плавающей запятой одинарной точности. |
| **DOUBLE**            | Да                                  | Да                                  | Число с плавающей запятой двойной точности. |
| **DECIMAL (M, D)**    | Да                                  | Да                                  | Число с фиксированной точностью (M - общая длина числа, D - количество знаков после запятой). |
| **NUMERIC (M, D)**    | Нет                                 | Да                                  | То же, что и `DECIMAL`, но поддерживает стандарт SQL точнее. |
| **REAL**              | Да (синоним DOUBLE)                 | Да                                  | Число с плавающей запятой двойной точности. В MySQL синоним `DOUBLE`. |

#### 2. **Строковые типы данных**

| **Тип данных**       | **MySQL**                           | **PostgreSQL**                      | **Описание** |
|----------------------|--------------------------------------|-------------------------------------|--------------|
| **CHAR(M)**           | Да                                  | Да                                  | Строка фиксированной длины (M). |
| **VARCHAR(M)**        | Да                                  | Да                                  | Строка переменной длины с ограничением по длине (M). |
| **TEXT**              | Да                                  | Да                                  | Текстовые данные переменной длины. В PostgreSQL поддерживаются типы: `TEXT`, `TINYTEXT`, `MEDIUMTEXT`, `LONGTEXT` (аналогичные в MySQL). |
| **ENUM**              | Да                                  | Нет                                 | Перечислимый тип данных, где значение выбирается из заданного списка. |
| **SET**               | Да                                  | Нет                                 | Множественный перечислимый тип данных, позволяющий выбрать несколько значений. |
| **BLOB**              | Да                                  | Да (аналог BYTEA)                   | Двоичные данные. В MySQL поддерживаются типы: `TINYBLOB`, `BLOB`, `MEDIUMBLOB`, `LONGBLOB`. В PostgreSQL используется `BYTEA`. |
| **BYTEA**             | Нет                                 | Да                                  | Двоичные данные в PostgreSQL (аналог BLOB). |
| **JSON**              | Да                                  | Да                                  | Строка в формате JSON. В PostgreSQL также есть тип `JSONB`, который более эффективен для хранения и поиска. |

#### 3. **Дата и время**

| **Тип данных**       | **MySQL**                           | **PostgreSQL**                      | **Описание** |
|----------------------|--------------------------------------|-------------------------------------|--------------|
| **DATE**              | Да                                  | Да                                  | Дата (год, месяц, день). |
| **TIME**              | Да                                  | Да                                  | Время (часы, минуты, секунды). |
| **DATETIME**          | Да                                  | Да                                  | Дата и время. В PostgreSQL это `TIMESTAMP`. |
| **TIMESTAMP**         | Да                                  | Да                                  | Дата и время с учетом часового пояса. |
| **YEAR**              | Да                                  | Нет                                 | Год (в диапазоне 1901-2155). |
| **INTERVAL**          | Нет                                 | Да                                  | Интервал времени (например, разница между двумя датами). |

#### 4. **Логические и другие типы**

| **Тип данных**       | **MySQL**                           | **PostgreSQL**                      | **Описание** |
|----------------------|--------------------------------------|-------------------------------------|--------------|
| **BOOLEAN**           | Да (синоним TINYINT(1))             | Да (логическое значение)            | Логическое значение (TRUE/FALSE). В MySQL это синоним для `TINYINT(1)`. |
| **BIT(M)**            | Да                                  | Да                                  | Двоичные данные фиксированной длины (M). |
| **UUID**              | Нет                                 | Да                                  | Уникальный идентификатор (128-битный). |
| **ARRAY**             | Нет                                 | Да                                  | Массив значений одного типа данных. |
| **HSTORE**            | Нет                                 | Да                                  | Ключ-значение (хранение пар). |
| **CIDR, INET, MACADDR**| Нет                                 | Да                                  | Типы данных для хранения IP-адресов, масок подсетей и MAC-адресов. |
| **XML**               | Нет                                 | Да                                  | Данные в формате XML. |

#### 5. **Геометрические типы данных**

| **Тип данных**       | **MySQL**                           | **PostgreSQL**                      | **Описание** |
|----------------------|--------------------------------------|-------------------------------------|--------------|
| **GEOMETRY**          | Да                                  | Да                                  | Геометрические данные (точки, линии, полигоны и т.д.). |
| **POINT**             | Да                                  | Да                                  | Точка в 2D-пространстве. |
| **LINESTRING**        | Да                                  | Да                                  | Линия, состоящая из нескольких точек. |
| **POLYGON**           | Да                                  | Да                                  | Многоугольник. |
| **CIRCLE**            | Нет                                 | Да                                  | Круг (поддерживается в PostgreSQL). |
| **BOX**               | Нет                                 | Да                                  | Прямоугольник в пространстве. |

### Примеры применения некоторых типов данных:

#### 1. **Работа с числовыми типами (MySQL и PostgreSQL)**
```sql
-- MySQL
CREATE TABLE products (
    product_id INT AUTO_INCREMENT,
    name VARCHAR(100),
    price DECIMAL(10, 2),
    stock SMALLINT,
    PRIMARY KEY (product_id)
);

-- PostgreSQL
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price NUMERIC(10, 2),
    stock SMALLINT
);
```

#### 2. **Работа с текстовыми данными**
```sql
-- MySQL
CREATE TABLE users (
    user_id INT AUTO_INCREMENT,
    username VARCHAR(50),
    bio TEXT,
    PRIMARY KEY (user_id)
);

-- PostgreSQL
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50),
    bio TEXT
);
```

#### 3. **Работа с датами и временем**
```sql
-- MySQL
CREATE TABLE events (
    event_id INT AUTO_INCREMENT,
    event_name VARCHAR(100),
    event_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (event_id)
);

-- PostgreSQL
CREATE TABLE events (
    event_id SERIAL PRIMARY KEY,
    event_name VARCHAR(100),
    event_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 4. **Работа с JSON-данными (PostgreSQL и MySQL)**
```sql
-- MySQL
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT,
    customer_info JSON,
    PRIMARY KEY (order_id)
);

-- PostgreSQL
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_info JSONB
);
```

### Заключение:

- **MySQL**: имеет более простую систему типов данных, ориентированную на реляционные и строковые данные, с поддержкой некоторых специфичных типов данных, таких как `ENUM` и `SET`.
- **PostgreSQL**: предлагает более богатую и гибкую систему типов данных, включая массивы, ключ-значение, UUID, IP-адреса и сложные геометрические типы данных, а также поддерживает `JSONB` для более эффективной работы с данными в формате JSON.

</details>

---

### 24. Разница между JOIN и UNION?

<details>
<summary>Раскрыть:</summary>

### 1. **JOIN**
**`JOIN`** используется для объединения строк из **двух или более таблиц**, основываясь на определенных условиях (например, связях между столбцами этих таблиц). Результат — это комбинированные строки, которые соответствуют условию соединения.

#### Виды `JOIN`:
1. **`INNER JOIN`**: Возвращает только те строки, которые имеют соответствия в обеих таблицах.
2. **`LEFT JOIN` (или LEFT OUTER JOIN)**: Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если соответствий нет, строки из правой таблицы будут заполнены значениями `NULL`.
3. **`RIGHT JOIN` (или RIGHT OUTER JOIN)**: Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если соответствий нет, строки из левой таблицы будут заполнены `NULL`.
4. **`FULL JOIN` (или FULL OUTER JOIN)**: Возвращает все строки, которые соответствуют хотя бы одной из таблиц, заполняя отсутствующие значения `NULL`.

#### Пример использования `JOIN`:

Допустим, у нас есть две таблицы: `customers` (клиенты) и `orders` (заказы).

**Таблица `customers`:**
| customer_id | name        |
|-------------|-------------|
| 1           | John Doe    |
| 2           | Jane Smith  |

**Таблица `orders`:**
| order_id | customer_id | amount |
|----------|-------------|--------|
| 101      | 1           | 100    |
| 102      | 1           | 150    |

**Пример запроса с `JOIN`:**

```sql
SELECT customers.name, orders.amount
FROM customers
INNER JOIN orders ON customers.customer_id = orders.customer_id;
```

#### Результат:
| name      | amount |
|-----------|--------|
| John Doe  | 100    |
| John Doe  | 150    |

Здесь `INNER JOIN` объединил данные из двух таблиц на основе столбца `customer_id`. Были возвращены только те строки, где `customer_id` присутствует в обеих таблицах.

### Когда использовать `JOIN`:
- Когда нужно объединить данные из нескольких таблиц на основе связей между ними (например, внешние ключи).
- Для получения комбинированной информации из нескольких источников.

---

### 2. **UNION**
**`UNION`** используется для объединения результатов двух или более **запросов**, которые возвращают **одинаковые столбцы по структуре и типам данных**. Результат — это объединение строк из разных запросов.

#### Виды `UNION`:
1. **`UNION`**: Возвращает уникальные строки из всех запросов (то есть убирает дубликаты).
2. **`UNION ALL`**: Возвращает все строки, включая дубликаты.

#### Пример использования `UNION`:

Допустим, у нас есть две таблицы: `customers` (клиенты) и `suppliers` (поставщики).

**Таблица `customers`:**
| name       | country  |
|------------|----------|
| John Doe   | USA      |
| Jane Smith | Canada   |

**Таблица `suppliers`:**
| name         | country  |
|--------------|----------|
| ACME Corp    | USA      |
| Global Goods | Mexico   |

**Пример запроса с `UNION`:**

```sql
SELECT name, country FROM customers
UNION
SELECT name, country FROM suppliers;
```

#### Результат:
| name         | country  |
|--------------|----------|
| John Doe     | USA      |
| Jane Smith   | Canada   |
| ACME Corp    | USA      |
| Global Goods | Mexico   |

Здесь **`UNION`** объединяет результаты из двух таблиц и возвращает уникальные строки. Если бы мы использовали **`UNION ALL`**, дубликаты также были бы включены в результат.

### Когда использовать `UNION`:
- Когда нужно объединить результаты двух или более запросов в одну таблицу.
- Когда нужно получить набор данных из разных таблиц или запросов, но в одном формате (например, списки клиентов и поставщиков).

---

### Основные различия между `JOIN` и `UNION`:

| **Характеристика**        | **`JOIN`**                                      | **`UNION`**                                   |
|---------------------------|-------------------------------------------------|-----------------------------------------------|
| **Объединение**            | Объединяет строки из двух или более таблиц на основе условий. | Объединяет результаты двух или более запросов. |
| **Количество столбцов**    | Количество и структура столбцов могут быть разными в таблицах. | Одинаковое количество и структура столбцов во всех запросах. |
| **Удаление дубликатов**    | Дубликаты не удаляются, если не указано в запросе. | `UNION` удаляет дубликаты (используйте `UNION ALL` для сохранения всех строк). |
| **Тип объединения**        | Возвращает результат на основе совпадений в ключах (например, `customer_id`). | Возвращает результат, объединяя строки, как если бы это были независимые запросы. |
| **Использование для**      | Для объединения данных из нескольких связанных таблиц. | Для объединения результатов нескольких запросов с одинаковой структурой. |

### Примеры использования:

1. **JOIN**: Когда у вас есть две или более связанные таблицы, и вы хотите получить информацию, основанную на связи между ними.
    - Например, получить список клиентов и их заказов.

2. **UNION**: Когда у вас есть результаты нескольких запросов с одинаковой структурой, и вы хотите объединить их в одном наборе данных.
    - Например, объединить списки клиентов и поставщиков в одну таблицу.

</details>

---

### 25. Что такое индексы? Как они влияют на время выполнения SELECT, INSERT?

<details>
<summary>Раскрыть:</summary>

**Индексы** — это специальные структуры данных, которые создаются для ускорения поиска и доступа к данным в таблицах базы данных. Они организуют данные таким образом, чтобы СУБД могла быстро находить нужные записи, не сканируя всю таблицу целиком. Индексы могут значительно повысить производительность запросов, особенно при поиске, сортировке и фильтрации данных.

### Как работают индексы:

Индексы создаются на одном или нескольких столбцах таблицы и используются для быстрого поиска значений в этих столбцах. Они работают аналогично указателю в книге — вместо того чтобы просматривать все страницы книги, вы можете воспользоваться индексом для быстрого нахождения нужной информации.

В большинстве случаев индексы представляют собой структуры данных типа **B-дерево** или **хэш-таблицу**, которые обеспечивают быстрый доступ к данным за логарифмическое время.

### Виды индексов:

1. **Обычные индексы (B-tree индексы)**: Стандартный тип индекса, который помогает ускорить поиск, сортировку и фильтрацию данных.
2. **Уникальные индексы**: Обеспечивают уникальность значений в одном или нескольких столбцах.
3. **Составные индексы**: Создаются на нескольких столбцах для оптимизации сложных запросов, которые используют комбинацию этих столбцов.
4. **Полнотекстовые индексы** (FULLTEXT): Специализированные индексы для ускорения полнотекстового поиска в текстовых полях.
5. **Хэш-индексы**: Используются для точного соответствия в некоторых системах, таких как `MEMORY` таблицы в MySQL.

### Как индексы влияют на время выполнения запросов:

#### 1. **Влияние индексов на SELECT (чтение данных)**:

Индексы **ускоряют** выполнение запросов на чтение, таких как `SELECT`, за счет быстрого поиска нужных записей по индексам вместо полного сканирования всей таблицы. Это особенно важно для таблиц с большим количеством строк.

##### Пример без индекса:
```sql
SELECT * FROM orders WHERE customer_id = 12345;
```
Если на столбец `customer_id` нет индекса, база данных будет вынуждена **просканировать всю таблицу** для поиска нужных записей, что может занять много времени при большом объеме данных.

##### Пример с индексом:
```sql
CREATE INDEX idx_customer_id ON orders (customer_id);

SELECT * FROM orders WHERE customer_id = 12345;
```
С индексом на `customer_id` база данных использует индекс для быстрого нахождения строк, соответствующих `customer_id = 12345`, что значительно сокращает время выполнения запроса.

**Результат**: Индексы уменьшают количество строк, которые нужно обработать в запросе, что ускоряет поиск данных и выполнение запросов.

#### 2. **Влияние индексов на INSERT, UPDATE, DELETE (запись и модификация данных)**:

Хотя индексы значительно ускоряют операции чтения, они могут **замедлить** операции записи, такие как `INSERT`, `UPDATE` и `DELETE`. Это связано с тем, что каждый раз, когда изменяются данные в индексированных столбцах, индекс должен быть обновлен.

##### Пример с INSERT:
```sql
INSERT INTO orders (customer_id, product_id, amount) VALUES (12345, 6789, 150);
```
Если на столбец `customer_id` установлен индекс, при добавлении новой строки база данных должна не только вставить данные в таблицу, но и обновить индекс для этого столбца. Чем больше индексов на таблице, тем больше работы нужно выполнить при каждой операции записи.

**Результат**: Индексы замедляют операции записи, так как на обновление индексов тратится дополнительное время.


</details>

---

### 26. Что такое хранимые процедуры, функции и триггеры в MySQL? Для чего они? Приведите примеры использования.

<details>
<summary>Раскрыть:</summary>

**Хранимые процедуры**, **функции** и **триггеры** в MySQL — это инструменты, которые помогают автоматизировать и улучшить логику работы с данными в базе. Они используются для выполнения заранее определенных операций с данными, что позволяет улучшить производительность и повторяемость операций. Рассмотрим их подробнее:

### 1. **Хранимые процедуры**

**Хранимые процедуры** — это заранее написанные и сохраненные в базе данных блоки кода, которые могут быть вызваны для выполнения определенных операций. Они могут содержать набор SQL-запросов, логические операторы, циклы и другие программные конструкции.

#### Основные преимущества хранимых процедур:
- **Повторное использование**: Процедуры можно вызывать многократно, что упрощает выполнение стандартных операций.
- **Безопасность**: Процедуры могут ограничить доступ к данным и позволяют пользователям выполнять операции, не имея прямого доступа к таблицам.
- **Улучшение производительности**: Процедуры исполняются на сервере базы данных, что снижает нагрузку на сеть, так как операции выполняются локально.
- **Меньше кода в приложении**: Логика обработки данных переносится на уровень базы данных.

#### Пример создания хранимой процедуры:
```sql
DELIMITER $$

CREATE PROCEDURE GetCustomerOrders(IN customer_id INT)
BEGIN
    SELECT order_id, amount 
    FROM orders 
    WHERE customer_id = customer_id;
END $$

DELIMITER ;
```

#### Вызов процедуры:
```sql
CALL GetCustomerOrders(12345);
```

Эта процедура принимает идентификатор клиента и возвращает список его заказов.

---

### 2. **Функции**

**Функции** — это подпрограммы, которые могут возвращать значение и могут быть использованы в SQL-запросах. Основное отличие функций от хранимых процедур заключается в том, что функции **всегда возвращают значение** и могут быть вызваны внутри запросов, тогда как хранимые процедуры могут возвращать набор строк и выполнять более сложные задачи.

#### Основные преимущества функций:
- **Использование в запросах**: Функции можно использовать прямо в SQL-запросах, например в выражениях `SELECT`, `WHERE` и `ORDER BY`.
- **Возврат значения**: Функции всегда возвращают результат, что делает их полезными для вычислений и обработки данных.

#### Пример создания функции:
```sql
DELIMITER $$

CREATE FUNCTION GetCustomerOrderCount(customer_id INT) 
RETURNS INT
DETERMINISTIC
BEGIN
    DECLARE order_count INT;
    
    SELECT COUNT(*) INTO order_count
    FROM orders 
    WHERE customer_id = customer_id;
    
    RETURN order_count;
END $$

DELIMITER ;
```

#### Пример использования функции:
```sql
SELECT GetCustomerOrderCount(12345);
```

Эта функция возвращает количество заказов для указанного клиента.

---

### 3. **Триггеры**

**Триггеры** — это специальные объекты базы данных, которые автоматически выполняются при определенных событиях (например, вставке, обновлении или удалении строк в таблице). Триггеры можно использовать для автоматического выполнения логики до или после определенной операции над таблицей.

#### Основные преимущества триггеров:
- **Автоматизация процессов**: Триггеры автоматически запускают код при наступлении определенных событий (например, при добавлении новой строки в таблицу).
- **Контроль данных**: Они помогают обеспечивать целостность данных (например, проверку или изменение данных перед их вставкой).
- **Аудит**: Триггеры можно использовать для ведения истории изменений в таблицах (например, для записи логов).

#### Пример создания триггера:

Допустим, у нас есть таблица `orders`, и мы хотим автоматически обновлять информацию о последнем заказе клиента в таблице `customers` при добавлении нового заказа.

##### Таблица `customers`:
```sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100),
    last_order_date DATETIME
);
```

##### Таблица `orders`:
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    order_date DATETIME,
    amount DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);
```

##### Создание триггера:
```sql
DELIMITER $$

CREATE TRIGGER UpdateLastOrderDate
AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    UPDATE customers 
    SET last_order_date = NEW.order_date 
    WHERE customer_id = NEW.customer_id;
END $$

DELIMITER ;
```

Этот триггер автоматически обновляет поле `last_order_date` в таблице `customers` при добавлении новой записи в таблицу `orders`.

#### Типы триггеров:
- **BEFORE**: Выполняется перед выполнением операции (например, перед вставкой строки).
- **AFTER**: Выполняется после выполнения операции (например, после удаления строки).
- **INSERT, UPDATE, DELETE**: Тип операции, на которую реагирует триггер.

#### Пример вызова триггера:
```sql
INSERT INTO orders (customer_id, order_date, amount)
VALUES (1, '2024-09-15', 150.00);
```

Когда этот запрос выполнится, триггер автоматически обновит поле `last_order_date` в таблице `customers` для клиента с `customer_id = 1`.

---

### Основные отличия между хранимыми процедурами, функциями и триггерами:

| **Характеристика**       | **Хранимая процедура**                     | **Функция**                         | **Триггер**                             |
|--------------------------|--------------------------------------------|-------------------------------------|-----------------------------------------|
| **Назначение**            | Выполняет сложные операции, может возвращать набор данных. | Возвращает одно значение, может использоваться в SQL-запросах. | Автоматически выполняет код при определенных событиях (вставка, обновление, удаление). |
| **Возврат значения**      | Может не возвращать результат.             | Всегда возвращает одно значение.    | Не возвращает значения, но выполняет операции. |
| **Вызов**                 | Вызывается с помощью `CALL`.               | Вызывается в запросах (например, `SELECT`, `WHERE`). | Автоматически вызывается при определенных событиях в таблице. |
| **Использование в запросах** | Не используется в запросах напрямую.       | Используется в запросах.            | Не используется в запросах. |
| **Пример**                | `CALL GetCustomerOrders(12345);`           | `SELECT GetCustomerOrderCount(12345);` | Автоматическое выполнение при вставке данных. |

### Применение:

1. **Хранимые процедуры** используются для выполнения сложных операций над базой данных, например, для обработки данных в несколько шагов, выполнения циклов, создания отчетов и других операций.
2. **Функции** удобны для вычислений и обработки данных, когда требуется вернуть конкретное значение, например, вычисление суммы или среднего значения.
3. **Триггеры** полезны для автоматизации операций, таких как поддержание целостности данных, автоматическая запись логов изменений или проверка данных перед их вставкой.

</details>

---

### 27. Как организовать сохранность вложенных категорий в MySQL?

<details>
<summary>Раскрыть:</summary>

Для сохранения и управления вложенными категориями в MySQL существует несколько подходов. Рассмотрим три основных способа: **иерархическая модель (связь родитель-ребенок)**, **модель вложенных множеств** и **модель пути (path enumeration)**. Каждый метод имеет свои плюсы и минусы в зависимости от требований к производительности, сложности запросов и объема данных.

### 1. **Иерархическая модель (Parent-Child)**

Это самый простой способ сохранения вложенных категорий, когда каждая категория имеет ссылку на своего родителя. В этой модели каждая строка таблицы содержит ссылку на родительскую категорию.

#### Структура таблицы:

```sql
CREATE TABLE categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    parent_id INT,
    FOREIGN KEY (parent_id) REFERENCES categories(id)
);
```

- **id**: Уникальный идентификатор категории.
- **name**: Название категории.
- **parent_id**: Идентификатор родительской категории. Если категория верхнего уровня, `parent_id` будет `NULL`.

#### Пример данных:

| id  | name           | parent_id |
|-----|----------------|-----------|
| 1   | Электроника     | NULL      |
| 2   | Смартфоны       | 1         |
| 3   | Ноутбуки        | 1         |
| 4   | Аксессуары      | 2         |
| 5   | Чехлы для телефонов | 4      |

#### Пример запроса для получения подкатегорий:
```sql
SELECT * FROM categories WHERE parent_id = 1;
```
Этот запрос вернет все подкатегории для категории с id `1` ("Электроника").

#### Пример рекурсивного запроса для получения полного пути к категории:
Начиная с MySQL 8.0 можно использовать **рекурсивные CTE (Common Table Expressions)** для получения всех категорий в иерархии:
```sql
WITH RECURSIVE category_path (id, name, parent_id) AS (
    SELECT id, name, parent_id FROM categories WHERE id = 5
    UNION ALL
    SELECT c.id, c.name, c.parent_id
    FROM categories c
    INNER JOIN category_path cp ON c.id = cp.parent_id
)
SELECT * FROM category_path;
```
Этот запрос вернет полный путь для категории с `id = 5` ("Чехлы для телефонов").

#### Преимущества:
- Простота реализации.
- Легко добавлять, удалять и изменять категории.

#### Недостатки:
- Для получения полного дерева вложенных категорий требуется рекурсивный запрос, что может замедлять производительность при глубокой иерархии.
- Для старых версий MySQL (до 8.0) сложнее реализовать рекурсивные запросы.

---

### 2. **Модель вложенных множеств (Nested Set Model)**

Модель вложенных множеств сохраняет иерархию категорий в виде "вложенных" множеств с использованием значений "левое" (left) и "правое" (right). Это позволяет эффективно выполнять запросы для получения всех подкатегорий одной категории без рекурсии.

#### Структура таблицы:

```sql
CREATE TABLE categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    lft INT,
    rgt INT
);
```

- **id**: Уникальный идентификатор категории.
- **name**: Название категории.
- **lft** и **rgt**: Левые и правые границы для категории. Эти значения используются для представления иерархии.

#### Пример данных:

| id  | name              | lft  | rgt  |
|-----|-------------------|------|------|
| 1   | Электроника        | 1    | 10   |
| 2   | Смартфоны          | 2    | 7    |
| 3   | Аксессуары         | 3    | 6    |
| 4   | Чехлы для телефонов| 4    | 5    |
| 5   | Ноутбуки           | 8    | 9    |

- Категория "Электроника" охватывает все вложенные подкатегории от 1 до 10.
- Категория "Смартфоны" охватывает категории от 2 до 7, и внутри нее есть "Аксессуары" и "Чехлы для телефонов".

#### Пример запроса для получения всех подкатегорий:

Чтобы получить все подкатегории категории "Электроника", используйте следующий запрос:
```sql
SELECT * FROM categories WHERE lft > 1 AND rgt < 10;
```

#### Преимущества:
- Быстрые запросы для получения всех подкатегорий или полного дерева.
- Не требуется рекурсия для получения подкатегорий.

#### Недостатки:
- Сложность обновления дерева: при добавлении, удалении или перемещении категории нужно изменять много строк (пересчитывать значения `lft` и `rgt`).
- Трудно добавлять новые категории, особенно если структура часто изменяется.

---

### 3. **Модель пути (Path Enumeration)**

В этой модели хранится полный путь каждой категории в иерархии. Это позволяет легко получать полную иерархию для любой категории, но требует больше места для хранения и может усложнить обновления.

#### Структура таблицы:

```sql
CREATE TABLE categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    path VARCHAR(255)
);
```

- **id**: Уникальный идентификатор категории.
- **name**: Название категории.
- **path**: Полный путь к категории, разделенный символом (например, `/` или `.`).

#### Пример данных:

| id  | name                 | path           |
|-----|----------------------|----------------|
| 1   | Электроника           | /1             |
| 2   | Смартфоны             | /1/2           |
| 3   | Аксессуары            | /1/2/3         |
| 4   | Чехлы для телефонов   | /1/2/3/4       |
| 5   | Ноутбуки              | /1/5           |

#### Пример запроса для получения всех подкатегорий:
Чтобы получить все подкатегории категории "Смартфоны", можно выполнить следующий запрос:
```sql
SELECT * FROM categories WHERE path LIKE '/1/2%';
```

#### Преимущества:
- Простота запросов: легко получить полный путь или все подкатегории.
- Быстрый поиск по префиксу пути.

#### Недостатки:
- Увеличение объема хранимых данных, так как каждый путь может быть длинным.
- Трудности с обновлением структуры: если изменяется родительская категория, нужно обновить путь для всех подкатегорий.

---

### Сравнение подходов:

| **Метод**                 | **Преимущества**                                                                                                                                 | **Недостатки**                                                                                                                 |
|---------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| **Иерархическая модель (Parent-Child)** | Простая структура, легко реализовать, легко обновлять.                                                                                              | Для сложных иерархий требуется рекурсивные запросы, которые могут быть медленными (особенно в старых версиях MySQL).            |
| **Модель вложенных множеств (Nested Set)** | Быстрое получение всех подкатегорий, не требуется рекурсия.                                                                                       | Сложность при обновлении: нужно пересчитывать `lft` и `rgt` значения для многих строк при изменении структуры.                  |
| **Модель пути (Path Enumeration)**      | Легко получать полные пути и все подкатегории.                                                                                                     | Проблемы с обновлением: изменение родительской категории требует обновления путей всех подкатегорий. Увеличение объема данных.  |

</details>