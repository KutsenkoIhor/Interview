# Middle Database

## Оглавление
1. [В чём разница между MyISAM и InnoDB? В каких случаях и что лучше применять?](#1-в-чём-разница-между-myisam-и-innodb-в-каких-случаях-и-что-лучше-применять)
2. [Как найти и оптимизировать «тяжёлые» запросы?](#2-как-найти-и-оптимизировать-тяжёлые-запросы)
3. [Какие бывают типы индексов?](#3-какие-бывают-типы-индексов)
4. [Как хранить координаты точки на карте в БД?](#4-как-хранить-координаты-точки-на-карте-в-бд)
5. [Какие типы индексов бывают в RDBMS?](#5-какие-типы-индексов-бывают-в-rdbms)
6. [Какое свойство полей БД нужно учитывать при выборе типа индекса?](#6-какое-свойство-полей-бд-нужно-учитывать-при-выборе-типа-индекса)
7. [Когда стоит использовать индексы: преимущества и недостатки?](#7-когда-стоит-использовать-индексы-преимущества-и-недостатки)
8. [Что такое ACID?](#8-что-такое-acid)
9. [Что такое план выполнения запроса и как его узнать?](#9-что-такое-план-выполнения-запроса-и-как-его-узнать)
10. [В чём разница между CHAR и VARCHAR в SQL?](#10-в-чём-разница-между-char-и-varchar-в-sql)
11. [Зачем нужны транзакции? Расскажите принцип работы.](#11-зачем-нужны-транзакции-расскажите-принцип-работы)
12. [Назовите 3–4 нормальные формы реляционных БД.](#12-назовите-34-нормальные-формы-реляционных-бд)
13. [Зачем нужна репликация? Какие есть типы и в чём между ними разница?](#13-зачем-нужна-репликация-какие-есть-типы-и-в-чём-между-ними-разница)
14. [Что такое индексирование? Какие есть типы индексов? Зачем их использовать?](#14-что-такое-индексирование-какие-есть-типы-индексов-зачем-их-использовать)
15. [Что такое полнотекстовый поиск в MySQL? Как он реализуется?](#15-что-такое-полнотекстовый-поиск-в-mysql-как-он-реализуется)
16. [Что такое cursor в MySQL-процедурах?](#16-что-такое-cursor-в-mysql-процедурах)
17. [Расскажите про RabbitMQ или Gearman.](#17-расскажите-про-rabbitmq-или-gearman)
18. [Что вы знаете про Solr / ElasticSearch?](#18-что-вы-знаете-про-solr--elasticsearch)
19. [Что такое дедлоки в MySQL?](#19-что-такое-дедлоки-в-mysql)
20. [Влияет ли порядок JOIN на план выполнения MySQL-запроса?](#20-влияет-ли-порядок-join-на-план-выполнения-mysql-запроса)


### 1. В чём разница между MyISAM и InnoDB? В каких случаях и что лучше применять?

<details>
<summary>Раскрыть:</summary>

#### Ключевые отличия

**InnoDB (по умолчанию в MySQL)**
- Поддерживает **транзакции** и **ACID**
- Есть **внешние ключи (FK)**
- Блокировки на уровне **строк** (row-level locking)
- Есть **MVCC** (конкурентное чтение без блокировок)
- Лучше подходит для OLTP: частые записи/обновления

**MyISAM**
- **Нет транзакций**, нет FK
- Блокировки на уровне **таблицы**
- Быстрее в простом чтении на старых сценариях, но хуже при конкуренции
- Более высокий риск потери данных при сбоях (хуже recovery)

#### Когда что выбирать

✅ **InnoDB — почти всегда выбор №1**
- любые финансовые/критичные данные
- высокая конкуренция (много запросов)
- нужны транзакции, консистентность, FK

⚠️ **MyISAM** (редко, в legacy)
- старые проекты, где таблицы исключительно на чтение
- специфические legacy-требования (но обычно есть альтернатива)

**Вывод для собеседования:**
> InnoDB предпочтительнее: транзакции, FK, блокировки строк, лучше надёжность и конкуренция. MyISAM — устаревший вариант без транзакций, с table-locking.

</details>

---

### 2. Как найти и оптимизировать «тяжёлые» запросы?

<details>
<summary>Раскрыть:</summary>

#### Как найти «тяжёлые» запросы
- **slow query log** (лог медленных запросов)
- `performance_schema` / `sys` schema (статистика)
- `SHOW PROCESSLIST` (что выполняется прямо сейчас)
- Метрики (APM): NewRelic, Datadog, Grafana + exporters

#### Как анализировать
- `EXPLAIN` / `EXPLAIN ANALYZE`:
    - какие индексы используются
    - количество строк (rows)
    - тип доступа (ALL, range, ref, eq_ref, const)
    - наличие `Using filesort`, `Using temporary`
- Профилирование на стенде с похожими данными

#### Типовые действия по оптимизации
- Добавить/исправить индексы под `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`
- Убрать `SELECT *` → выбирать только нужные поля
- Избежать функций над индексируемыми колонками в `WHERE`
    - плохо: `WHERE DATE(created_at) = ...`
    - лучше: `WHERE created_at >= ... AND created_at < ...`
- Переписать подзапросы/`IN` → иногда лучше `JOIN`/`EXISTS`
- Ограничить выдачу: пагинация, лимиты, фильтры
- Нормализовать/денормализовать точечно (если реально нужно)
- Рассмотреть кеширование результата (Redis), материализованные агрегаты

**Вывод:**
> Находим через slow log/metrics, анализируем EXPLAIN, затем правим индексы и форму запроса, уменьшаем объём данных и избегаем сортировок/временных таблиц.

</details>

---

### 3. Какие бывают типы индексов?

<details>
<summary>Раскрыть:</summary>

#### В MySQL чаще всего
- **B-Tree / B+Tree** (основной тип для InnoDB)
    - отлично для `=`, `<`, `>`, диапазонов, сортировки
- **FULLTEXT** (полнотекстовый поиск)
- **SPATIAL** (геоданные)

#### По назначению
- **PRIMARY KEY** (первичный ключ)
- **UNIQUE** (уникальный)
- **INDEX** (обычный неуникальный)
- **COMPOSITE** (составной, по нескольким колонкам)

#### По логике хранения в InnoDB
- **Clustered index**: данные таблицы физически упорядочены по **PK**
- **Secondary index**: хранит ключ + значение PK как ссылку на строку

</details>

---

### 4. Как хранить координаты точки на карте в БД?

<details>
<summary>Раскрыть:</summary>

#### Вариант 1: два поля DECIMAL (простой и универсальный)
- `lat DECIMAL(9,6)`
- `lng DECIMAL(9,6)`
  Плюсы: просто, понятно, подходит почти всем  
  Минусы: сложнее гео-индексация и гео-функции

#### Вариант 2: Spatial типы (лучше для гео-поиска)
- `POINT` (MySQL Spatial)
- SRID (например, `4326` для WGS84)

Плюсы:
- можно делать запросы «рядом», «в радиусе», пересечения
- spatial индексы

Минусы:
- сложнее настройка и миграции
- надо разбираться в SRID и функциях

**Рекомендация:**
- если просто хранить/показывать — DECIMAL lat/lng
- если нужен «поиск рядом»/гео-аналитика — POINT + SPATIAL INDEX

</details>

---

### 5. Какие типы индексов бывают в RDBMS?

<details>
<summary>Раскрыть:</summary>

#### По структуре
- **B-Tree / B+Tree** (самый популярный)
- **Hash** (быстрый для `=`, но плохо для range / order)
- **Bitmap** (часто в DWH/аналитике)
- **GiST / GIN** (PostgreSQL, для сложных типов/поиска)
- **R-Tree** (геоданные)

#### По назначению
- Primary, Unique, Composite
- Fulltext
- Spatial

</details>

---

### 6. Какое свойство полей БД нужно учитывать при выборе типа индекса?

<details>
<summary>Раскрыть:</summary>

#### Главный критерий — селективность (cardinality)
**Селективность** = насколько поле различает строки.
- Хорошая селективность: `user_id`, `email`, `uuid`
- Плохая селективность: `gender`, `is_active`, `status` (2–5 значений)

Индекс на поле с низкой селективностью часто бесполезен для фильтрации,
потому что СУБД всё равно прочитает слишком много строк.

#### Что ещё важно
- Тип запросов: `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`
- Размер данных и частота обновлений
- Длина поля (особенно для строк)
- Распределение значений (skew)

</details>

---

### 7. Когда стоит использовать индексы: преимущества и недостатки?

<details>
<summary>Раскрыть:</summary>

#### Когда стоит
- Частые фильтры по `WHERE`
- Частые `JOIN` по ключам
- Сортировки `ORDER BY` и группировки `GROUP BY`
- Частые проверки уникальности

#### Плюсы
- Быстрее чтение и поиск
- Ускорение join/sort/group
- Контроль уникальности (UNIQUE)

#### Минусы
- Замедление INSERT/UPDATE/DELETE (индексы тоже обновляются)
- Рост размера БД
- Возможность «лишних» индексов и деградации производительности

**Правило:**
> Индексы ускоряют чтение, но замедляют запись — индексируй то, что реально нужно запросам.

</details>

---

### 8. Что такое ACID?

<details>
<summary>Раскрыть:</summary>

**ACID** — свойства транзакций:

- **A (Atomicity)** — атомарность: либо всё, либо ничего
- **C (Consistency)** — согласованность: данные не переходят в некорректное состояние
- **I (Isolation)** — изоляция: параллельные транзакции не ломают друг друга
- **D (Durability)** — долговечность: после commit данные не теряются при сбое

</details>

---

### 9. Что такое план выполнения запроса и как его узнать?

<details>
<summary>Раскрыть:</summary>

#### Что это
План выполнения — это «как СУБД собирается выполнять запрос»:
- какие индексы использовать
- в каком порядке делать join
- сколько строк прочитает
- будет ли сортировка/временная таблица

#### Как узнать в MySQL
- `EXPLAIN <query>`
- `EXPLAIN ANALYZE <query>` (даёт фактические метрики выполнения)

#### На что смотреть
- `type` (ALL плохо, const/eq_ref хорошо)
- `rows` (чем меньше — тем лучше)
- `key` (какой индекс выбран)
- `Extra`: `Using filesort`, `Using temporary` — часто тревожные признаки

</details>

---

### 10. В чём разница между CHAR и VARCHAR в SQL?

<details>
<summary>Раскрыть:</summary>

- **CHAR(n)** — фиксированная длина
    - хранит всегда `n` символов (добивает пробелами)
    - быстрее для фиксированных данных
    - подходит для: коды стран, статусы фикс. длины, хеши фикс. длины

- **VARCHAR(n)** — переменная длина
    - хранит только фактическую длину + служебные байты
    - экономит место при разной длине строк
    - подходит для: имён, email, произвольных строк

**Выбор:**
- фиксировано и коротко → CHAR
- переменная длина → VARCHAR

</details>

---

### 11. Зачем нужны транзакции? Расскажите принцип работы.

<details>
<summary>Раскрыть:</summary>

#### Назначение
Транзакции нужны, чтобы группа операций выполнялась **как единое целое**:
- перевод денег
- списание/зачисление
- создание заказа + списание остатков

#### Принцип
1) `BEGIN`
2) выполняем несколько SQL-операций
3) если всё ок → `COMMIT`
4) если ошибка → `ROLLBACK`

#### Важно
- транзакции обеспечивают целостность данных
- изоляция зависит от уровня isolation level (READ COMMITTED и т.д.)

</details>

---

### 12. Назовите 3–4 нормальные формы реляционных БД.

<details>
<summary>Раскрыть:</summary>

- **1NF**: атомарные значения, нет массивов/повторяющихся групп
- **2NF**: нет частичной зависимости неключевых полей от части составного ключа
- **3NF**: нет транзитивных зависимостей (не ключ → не ключ)
- **BCNF** (часто вместо «4NF» на собеседованиях): усиленная 3NF

Смысл нормализации:
- уменьшить дублирование
- повысить целостность
- упростить поддержку

</details>

---

### 13. Зачем нужна репликация? Какие есть типы и в чём разница?

<details>
<summary>Раскрыть:</summary>

#### Назначение репликации
- масштабирование чтения (read replicas)
- отказоустойчивость
- резервирование
- аналитика на репликах

#### Типы (по роли)
- **Primary/Replica** (Master/Slave) — запись в primary, чтение с replicas
- **Multi-Primary** — несколько узлов принимают запись (сложнее конфликты)

#### По синхронности
- **Asynchronous** — реплика отстаёт (самый частый)
- **Semi-sync / Sync** — больше гарантий, но выше задержки

</details>

---

### 14. Что такое индексирование? Какие есть типы индексов? Зачем их использовать?

<details>
<summary>Раскрыть:</summary>

**Индексирование** — создание структуры данных (обычно B-Tree), чтобы быстрее находить строки.

Зачем:
- ускорить `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`
- уменьшить число прочитанных строк (I/O)

Типы:
- PRIMARY, UNIQUE, обычные, составные
- FULLTEXT, SPATIAL

</details>

---

### 15. Что такое полнотекстовый поиск в MySQL? Как он реализуется?

<details>
<summary>Раскрыть:</summary>

#### Что это
Поиск по текстам «как в поисковике», а не `LIKE '%word%'`.

#### Как реализуется
- `FULLTEXT INDEX` по колонкам
- запросы через `MATCH(...) AGAINST(...)`

Плюсы:
- быстрее и релевантнее, чем `LIKE`

Минусы:
- есть ограничения по языкам/стеммингу/настройкам
- иногда лучше ElasticSearch/Solr для сложного поиска

</details>

---

### 16. Что такое cursor в MySQL-процедурах?

<details>
<summary>Раскрыть:</summary>

**Cursor** — механизм, позволяющий в хранимой процедуре **построчно** проходить результат запроса.

Используется, когда нужно:
- сделать сложную обработку строк в процедурном стиле
- выполнить действия для каждой строки

Минусы:
- медленнее set-based операций
- часто лучше переписать без курсора (обычными SQL-операциями)

</details>

---

### 17. Расскажите про RabbitMQ или Gearman.

<details>
<summary>Раскрыть:</summary>

#### RabbitMQ
Брокер сообщений (AMQP), используется для асинхронных задач и интеграций.

Ключевые понятия:
- **Producer** → отправляет сообщение
- **Exchange** → маршрутизация
- **Queue** → хранит сообщения
- **Consumer** → читает и обрабатывает
- **Ack/Nack** → подтверждение обработки
- **DLQ** (dead letter queue) → для «упавших» сообщений

Плюсы:
- надёжная доставка
- ретраи, DLQ, маршрутизация
- decouple сервисов

#### Gearman
Система распределённых задач (job server), чаще встречается в legacy.

**Вывод:**
> В современных системах чаще используют RabbitMQ / Kafka, Gearman — реже.

</details>

---

### 18. Что вы знаете про Solr / ElasticSearch?

<details>
<summary>Раскрыть:</summary>

**Solr** и **Elasticsearch** — поисковые движки (обычно поверх Lucene) для:
- полнотекстового поиска
- ранжирования (relevance)
- фасетного поиска, агрегаций
- автокомплита

#### Когда они лучше MySQL FULLTEXT
- сложная релевантность
- большие объёмы данных
- аналитика и агрегации
- мульти-языковой поиск, синонимы, стемминг

Минусы:
- отдельная инфраструктура
- синхронизация данных (индексация)

</details>

---

### 19. Что такое дедлоки в MySQL?

<details>
<summary>Раскрыть:</summary>

**Deadlock** — взаимная блокировка, когда транзакции ждут друг друга:

- T1 держит lock A и ждёт lock B
- T2 держит lock B и ждёт lock A

InnoDB обычно:
- обнаруживает дедлок
- откатывает одну транзакцию (жертву), чтобы разблокировать систему

Как уменьшить:
- обновлять строки всегда в одном порядке
- держать транзакции короткими
- избегать лишних блокировок
- правильные индексы (чтобы не блокировать «лишние» строки)

</details>

---

### 20. Влияет ли порядок JOIN на план выполнения MySQL-запроса?

<details>
<summary>Раскрыть:</summary>

#### Коротко
Обычно **нет напрямую**, потому что оптимизатор MySQL может **переупорядочить join** для лучшего плана.

#### Но есть нюансы
- При `STRAIGHT_JOIN` порядок фиксируется
- При сложных запросах и статистике оптимизатор может ошибаться
- Наличие/отсутствие индексов и селективность сильно влияют на выбор порядка

Практика:
- проверять `EXPLAIN`
- иногда переписывать запрос или добавлять подсказки/индексы

</details>
