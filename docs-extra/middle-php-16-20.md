---
### 16. Как хранятся данные в Redis и Memcached?

<details>
<summary>Раскрыть:</summary>

И Redis, и Memcached — это быстрые in-memory хранилища, но **модель хранения и возможности сильно отличаются**.

#### 1. Memcached: простое key-value хранилище
Memcached хранит данные как:
* **ключ → бинарная строка (blob)**

То есть вы сами решаете, что класть:
* JSON
* сериализованный PHP (`serialize()`)
* простая строка/число

Особенности:
* **только память**, без “родного” persistence (обычно без сохранения на диск)
* нет сложных структур (только value-blob)
* TTL есть (expiration)
* при нехватке памяти удаляет ключи согласно политике (LRU — классический вариант)

Пример (идея):
```
SET user:123 "{...json...}" EX 300
GET user:123
```

#### 2. Redis: key-value + структуры данных
Redis тоже хранит:
* **ключ → значение**, но значение может быть **разных типов**:

* **String** — строка/число/байты  
* **Hash** — набор полей (похоже на мини-объект)  
* **List** — список (очереди, ленты)  
* **Set** — множество уникальных значений  
* **Sorted Set** — множество с сортировкой по score  
* **Stream** — поток сообщений  
* и другие (bitmaps, hyperloglog, geo)

Это даёт возможность делать операции **на стороне Redis**, без скачивания/пересборки всего объекта.

Пример: Hash для пользователя
```
HSET user:123 name "Ihor" city "Warsaw"
HGET user:123 name
```

#### 3. Persistence: главное отличие
Redis умеет сохранять данные на диск:
* **RDB** — снимки (snapshot)
* **AOF** — журнал операций (append-only file)
Можно включать отдельно или вместе.

Memcached обычно не хранит данные на диск (это чистый кеш).

#### 4. Истечение ключей (TTL)
И там, и там можно задавать TTL:
* ключ живёт N секунд, потом удаляется
* в Redis TTL применяется ко всему ключу (не к отдельным полям hash)

#### 5. Практические последствия
* Memcached чаще всего используют как “тупой” кеш (простые ключи/значения).
* Redis подходит и для кеша, и для более сложных задач (locks, rate-limit, очереди, pub/sub, streams).

</details>

---
### 17. Redis и Memcached для кеширования: плюсы и минусы.

<details>
<summary>Раскрыть:</summary>

Оба решения подходят для кеширования, но выбор зависит от задачи.

#### 1. Redis — плюсы
* **Больше возможностей**: структуры данных, atomic операции.
* **Locks** (distributed locks) — защита от параллельных запусков/кеш-штампа.
* **Rate limiting** (счётчики, sliding window).
* **Pub/Sub, Streams** — события/очереди.
* **Persistence** (RDB/AOF) и репликация → может переживать перезапуски лучше.
* **Lua scripts** — сложные атомарные сценарии на стороне Redis.

#### 2. Redis — минусы
* Сложнее в эксплуатации: настройки памяти, persistence, репликация/cluster.
* При неверной конфигурации persistence может влиять на latency.
* Можно “перегрузить” Redis задачами, которые лучше делать отдельным брокером (RabbitMQ/Kafka), если нет дисциплины.

#### 3. Memcached — плюсы
* **Очень простой**: ключ → значение.
* Часто даёт отличную производительность на “тупом” кеше.
* Меньше “функций” → меньше способов ошибиться.
* Хорош для больших объёмов однотипного кеша.

#### 4. Memcached — минусы
* Нет сложных структур и атомарных сценариев уровня Redis.
* Обычно без persistence (после рестарта кеш пропадает).
* Меньше инструментов для locks/rate-limit/pubsub.

#### 5. Что выбрать на практике
* **Нужен простой кеш страниц/ответов/DTO** → Memcached или Redis (оба ок).
* **Нужны locks / rate-limit / счётчики / очереди / streams** → Redis.
* **Микросервисы + много use-case** → Redis чаще выигрывает универсальностью, но важно не превращать его во “всё сразу”.

#### 6. Типичные ошибки при кешировании (для обоих)
* Нет стратегии инвалидирования (теги, версии ключей).
* Неправильный TTL (слишком большой или слишком маленький).
* Нет защиты от cache stampede (jitter TTL, locks, soft TTL).
* Кешируют “персональные” данные без учёта контекста (locale, permissions, brand, etc.).

</details>

---
### 18. Отличия между nginx и Apache.

<details>
<summary>Раскрыть:</summary>

Оба — веб-серверы, но архитектура и сценарии применения отличаются.

#### 1. Архитектура
**nginx**
* event-driven, асинхронная модель
* хорошо держит много одновременных соединений
* низкое потребление памяти при высокой нагрузке

**Apache**
* исторически process/thread-based (prefork/worker/event MPM)
* более “тяжёлый” в классических конфигурациях, но гибкий

#### 2. Статика и проксирование
nginx очень силён в:
* раздаче статики (css/js/images)
* reverse proxy (проксирование на PHP-FPM, Node, Go)
* балансировке
* TLS termination

Apache тоже умеет, но nginx часто проще и быстрее в роли “фронта”.

#### 3. Конфигурация и .htaccess
Apache:
* поддерживает `.htaccess` (конфиги в директориях)
* удобно для shared-hosting, но это накладно по производительности (нужно проверять .htaccess)

nginx:
* **нет** `.htaccess`
* все правила в одном месте (централизованно) → лучше для продакшна и контроля

#### 4. Модули и экосистема
Apache:
* огромная экосистема модулей
* мощные возможности на уровне директории (auth, rewrite)

nginx:
* тоже модули, но подход другой; часто меньше “магии”, больше явной конфигурации

#### 5. Типичный сетап для PHP
На практике очень распространено:
* **nginx** как фронт (TLS, статика, proxy)
* **PHP-FPM** как обработчик PHP
* Apache в современных PHP-проектах реже используется как основной фронт, но встречается

#### 6. Когда выбирать что
* Высокая нагрузка, много соединений, прокси, микросервисы → nginx.
* Shared-hosting, проекты, завязанные на .htaccess/модули Apache → Apache.

</details>

---
### 19. Что такое OPcache и как он работает?

<details>
<summary>Раскрыть:</summary>

**OPcache** — встроенный в PHP механизм кеширования **скомпилированного байткода (opcode)**.

Идея: PHP — интерпретируемый язык, и без OPcache на каждый запрос происходило бы:
* чтение PHP-файла
* парсинг
* компиляция в opcode
* выполнение

OPcache убирает “компиляцию на каждый запрос”.

#### 1. Что кешируется
* результат компиляции PHP-скриптов → **opcode** в общей памяти (shared memory)
* несколько процессов PHP-FPM могут использовать один кеш

#### 2. Как работает (в общем виде)
1) Первый запрос к файлу:
* PHP компилирует файл в opcode
* кладёт в OPcache

2) Следующие запросы:
* opcode берётся из кеша
* этапы парсинга/компиляции пропускаются

#### 3. Важные настройки (по смыслу)
* размер памяти OPcache
* количество кешируемых файлов
* валидация изменений файлов:
  * в dev — часто включают проверку изменений
  * в prod — часто отключают постоянную проверку и используют деплой с рестартом/инвалидацией

#### 4. Что даёт OPcache
* сильно снижает CPU на парсинг/компиляцию
* ускоряет отклик
* особенно заметно на больших Symfony/Laravel проектах

#### 5. Типовые нюансы
* Если OPcache не проверяет изменения, после деплоя нужен рестарт PHP-FPM/инвалидация.
* При нехватке памяти: “cache full” → падение эффективности (частые вытеснения).
* OPcache — не кеш результата выполнения, а кеш компиляции.

</details>

---
### 20. Что такое JIT и как он работает?

<details>
<summary>Раскрыть:</summary>

**JIT (Just-In-Time compiler)** — механизм, который **во время выполнения** может компилировать часть opcode в **машинный код**, чтобы ускорить выполнение.

В PHP JIT появился в PHP 8 (как часть OPcache).

#### 1. Как это работает концептуально
1) PHP компилирует скрипт в opcode (как обычно).
2) JIT анализирует горячие участки (часто выполняемые).
3) Эти участки могут быть скомпилированы в машинный код.
4) Повторные выполнения идут быстрее.

#### 2. Где JIT реально помогает
Лучше всего — в “CPU-bound” задачах:
* численные вычисления
* обработка больших массивов данных
* алгоритмы, криптография (частично), парсеры, вычисления

В типичных веб-приложениях (Symfony/Laravel), где основное время:
* БД
* сеть
* сериализация
* IO
— JIT часто даёт **небольшой эффект**.

#### 3. JIT vs OPcache (важно)
* **OPcache** кеширует *opcode* (убирает компиляцию на каждый запрос).
* **JIT** ускоряет *выполнение* opcode, компилируя “горячее” в машинный код.

#### 4. Риски и нюансы
* JIT потребляет память и может усложнить профилирование.
* Не всегда ускоряет веб, иногда эффект близок к нулю.
* В проде включают осознанно, после измерений (benchmarks/profiling).

#### 5. Как “правильно” рассказывать на собесе
* OPcache — must-have почти всегда.
* JIT — опционально, помогает в вычислениях, не магическая кнопка ускорения API.

</details>

---
