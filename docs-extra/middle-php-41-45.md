---
### 41. Разница между стеком и очередью.

<details>
<summary>Раскрыть:</summary>

Стек и очередь — это структуры данных, которые отличаются **порядком извлечения элементов**.

#### 1. Стек (Stack) — LIFO
* **Last In, First Out**: последний добавленный выходит первым.
* Операции:
  * `push` — добавить
  * `pop` — достать последний
  * `peek/top` — посмотреть последний

Пример:
* добавили: 1, 2, 3
* достали: 3, 2, 1

Где используется:
* стек вызовов функций
* undo/redo
* парсинг выражений
* обход графов/деревьев (DFS)

#### 2. Очередь (Queue) — FIFO
* **First In, First Out**: первый добавленный выходит первым.
* Операции:
  * `enqueue` — добавить в конец
  * `dequeue` — достать из начала
  * `front` — посмотреть первый

Пример:
* добавили: 1, 2, 3
* достали: 1, 2, 3

Где используется:
* очереди задач (jobs)
* обработка событий
* планировщики
* сетевые буферы
* обход графов (BFS)

#### 3. Практический “middle” вывод
* стек — для вложенности/обратного порядка
* очередь — для справедливой обработки по порядку поступления
* в асинхронных системах чаще нужен FIFO (очереди задач)

</details>

---
### 42. Unit и Functional тесты. Моки и стабы в PHP.

<details>
<summary>Раскрыть:</summary>

#### 1. Unit tests
Unit-тесты проверяют **маленький кусок логики** (класс/метод) в изоляции.
* зависимости подменяются моками/стабами
* быстрые
* легко запускать постоянно

Пример: тестируем `FeeCalculator`, мокаем `RateProvider`.

#### 2. Functional tests
Functional-тесты проверяют **поведение фичи** ближе к реальности:
* часто поднимается контейнер Symfony
* реальный роутинг, контроллер, сериализация
* могут использовать тестовую БД или фикстуры
* медленнее, но ловят “стыковые” ошибки

В Symfony это обычно:
* `WebTestCase` / `KernelTestCase`
* запросы через test client

#### 3. Моки и стабы: отличия
**Stub**:
* возвращает заранее подготовленные данные
* не проверяет, “как” его вызывали

**Mock**:
* может возвращать данные
* плюс проверяет взаимодействие: вызовы, аргументы, количество

#### 4. Пример (идея PHPUnit)
```php
$repo = $this->createMock(UserRepository::class);

$repo->expects($this->once())
    ->method('save')
    ->with($this->isInstanceOf(User::class));
```

#### 5. Где что использовать
* unit: бизнес-правила, алгоритмы, use-case логика
* functional: API endpoints, интеграция контейнера, сериализация/валидаторы
* интеграционные: БД, doctrine mapping, кеш, очереди

#### 6. Типичные ошибки
* слишком много моков → тест “зависит от реализации”, ломается при рефакторинге
* отсутствие интеграционных тестов → проблемы с ORM/SQL всплывают поздно
* functional тесты без чистой тестовой среды → флейки (нестабильные) тесты

</details>

---
### 43. Как вызвать приватный метод (гипотетическая ситуация)?

<details>
<summary>Раскрыть:</summary>

В нормальной архитектуре приватные методы **не вызывают напрямую** — тестируют публичное поведение.  
Но если это “гипотетическая” ситуация, есть варианты.

#### 1. Правильный подход (рекомендуется)
* не тестировать private напрямую
* тестировать через public API (behavior)
* если private сложный — вынести логику в отдельный класс/сервис и тестировать его

#### 2. Reflection (как “последний вариант”)
```php
$ref = new ReflectionClass(MyClass::class);
$method = $ref->getMethod('privateMethod');
$method->setAccessible(true);

$obj = new MyClass();
$result = $method->invoke($obj, $arg1, $arg2);
```

Минусы:
* тест становится привязан к реализации
* ломается при рефакторинге
* нарушает инкапсуляцию

#### 3. Closure binding (редко)
```php
$call = function() { return $this->privateMethod(); };
$call = $call->bindTo($obj, $obj);
$call();
```

#### 4. Наследование не поможет
Private-методы не доступны наследникам.

#### 5. Как отвечать на собесе
* “Лучше тестировать public. Если нужно — вынесу private-логику в отдельный сервис. В крайнем случае можно через Reflection, но это костыль.”

</details>

---
### 44. Разница между PHP-FPM и «PHP на сокете».

<details>
<summary>Раскрыть:</summary>

Тут обычно имеют в виду два способа связки веб-сервера и PHP:

#### 1. PHP-FPM (FastCGI Process Manager)
* отдельный процесс-менеджер для PHP
* nginx/apache передают запросы по FastCGI
* FPM управляет пулом воркеров (процессы), перезапусками, лимитами

Плюсы:
* масштабируемость (pool workers)
* стабильность и управление ресурсами
* изоляция от веб-сервера
* стандартный продакшн-выбор для nginx + PHP

#### 2. «PHP на сокете» — что обычно имеют в виду
Чаще всего это один из вариантов:
* **FastCGI через Unix socket** (например `/var/run/php/php-fpm.sock`)
* либо устаревший запуск через CGI (реже)

Если речь про **Unix socket vs TCP**:
* Unix socket — быстрее на одной машине, проще безопасность
* TCP — удобно, если FPM на другом хосте/контейнере

Пример nginx:
```nginx
fastcgi_pass unix:/run/php/php-fpm.sock; # Unix socket
# или
fastcgi_pass 127.0.0.1:9000;            # TCP
```

#### 3. Как объяснить кратко
* PHP-FPM — это менеджер PHP-воркеров.
* «на сокете» — это транспорт, по которому nginx общается с PHP-FPM (unix socket или tcp).
* Чаще в проде nginx + PHP-FPM, а выбор socket/tcp зависит от инфраструктуры.

</details>

---
### 45. Как реализовать загрузку больших отчетов (1GB и более)?

<details>
<summary>Раскрыть:</summary>

Большие отчёты нельзя генерировать и отдавать “в одном HTTP-запросе” обычным способом — упрёмся в таймауты и память.

Правильный подход — **асинхронно + потоково**.

#### 1. Асинхронная генерация (лучший подход)
##### Шаг 1: старт задачи
* API принимает запрос “сгенерировать отчёт”
* создаёт запись “report job” в БД (status = pending)
* отправляет job в очередь (RabbitMQ/Redis/SQS)

##### Шаг 2: worker генерирует файл
* consumer читает job
* генерирует отчёт **потоково** (streaming) в файл (CSV/JSONL)
* сохраняет в объектное хранилище (S3/MinIO) или файловое хранилище
* обновляет статус job (done) и ссылку на файл

##### Шаг 3: скачивание
* клиент дергает endpoint “скачать отчёт”
* сервер отдаёт ссылку или стримит файл (лучше через nginx/X-Accel-Redirect)

#### 2. Потоковая генерация (streaming) — обязательно
Чтобы не держать 1GB в памяти:
* читаем данные батчами (chunking)
* пишем в файл построчно

Пример идеи (CSV):
```php
$fp = fopen($path, 'w');
foreach ($repo->iterateByChunks(1000) as $rows) {
    foreach ($rows as $row) {
        fputcsv($fp, $row);
    }
}
fclose($fp);
```

#### 3. Streaming download
Если нужно отдавать файл напрямую:
* использовать `readfile()`/streams
* отключать буферизацию
* лучше — отдавать через nginx (X-Accel-Redirect), чтобы PHP не тащил 1GB через себя

#### 4. Архитектурные варианты
* CSV/JSONL + gzip (сжатие на лету)
* подготовка отчёта заранее по расписанию (precompute)
* пагинация/фильтрация вместо “всё сразу” (если бизнес позволяет)

#### 5. Важные нюансы
* лимиты времени выполнения и памяти
* ретраи и идемпотентность job
* мониторинг (прогресс/статус)
* очистка старых отчётов (TTL)

#### 6. Как звучит хороший ответ
* “1GB отчёт — это job в очереди + streaming генерация батчами + хранение файла (S3) + скачивание по ссылке/через nginx. В синхронном HTTP это делать нельзя.”

</details>

---
