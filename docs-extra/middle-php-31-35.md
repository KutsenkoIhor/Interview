---
### 31. Что такое рефлексия?

<details>
<summary>Раскрыть:</summary>

**Рефлексия** — это механизм, который позволяет программе **исследовать свою структуру во время выполнения**:
* какие есть классы/методы/свойства
* какие типы параметров
* какие атрибуты (attributes)
* какие модификаторы доступа (public/protected/private)

В PHP это реализовано через набор классов `Reflection*` (ReflectionClass, ReflectionMethod, и т.д.).

#### 1. Зачем нужна рефлексия
* **DI-контейнеры** (Symfony) — автосвязывание зависимостей по типам.
* **ORM/Serializer** — чтение метаданных, аннотаций/атрибутов.
* **Автогенерация документации** (OpenAPI).
* **Тестирование** — доступ к приватным методам/свойствам в редких случаях.
* **Фреймворки** — роутинг, middleware, атрибуты.

#### 2. Пример: узнать методы класса
```php
$ref = new ReflectionClass(UserService::class);

foreach ($ref->getMethods() as $method) {
    echo $method->getName() . PHP_EOL;
}
```

#### 3. Пример: получить атрибуты (PHP 8+)
```php
#[Attribute]
class Route {
    public function __construct(public string $path) {}
}

final class Controller {
    #[Route('/users')]
    public function list() {}
}

$refMethod = new ReflectionMethod(Controller::class, 'list');
$attrs = $refMethod->getAttributes(Route::class);

$route = $attrs[0]->newInstance();
echo $route->path; // /users
```

#### 4. Минусы рефлексии
* медленнее, чем прямые вызовы (обычно не критично, но важно)
* повышает “магичность” кода и может усложнить отладку
* может ломать инкапсуляцию (если использовать для доступа к private)

#### 5. Как звучит “Middle” ответ
* “Рефлексия — это интроспекция структуры кода во время выполнения. В PHP она используется в DI, ORM, сериализации и атрибутах, но нужно помнить про накладные расходы и не злоупотреблять.”

</details>

---
### 32. Что такое хеш-функция и где она используется?

<details>
<summary>Раскрыть:</summary>

**Хеш-функция** — это функция, которая преобразует данные произвольной длины в строку фиксированной длины (хеш).  
Хеш обычно выглядит как набор символов (hex/base64) и используется для быстрого сравнения/поиска и контроля целостности.

#### 1. Основные свойства хеш-функций
* **Детерминированность**: одинаковый вход → одинаковый хеш.
* **Быстрота вычисления**.
* **Лавинный эффект**: малое изменение входа сильно меняет хеш.
* **Коллизии возможны**, но качественные функции делают их очень редкими.

#### 2. Криптографические vs некриптографические
**Криптографические** (SHA-256, SHA-512):
* устойчивы к подбору, коллизиям (на практике)
* используются в безопасности и целостности

**Некриптографические** (CRC32, MurmurHash):
* быстрые, но не для безопасности
* используются в хеш-таблицах, шардировании

#### 3. Где используют хеши
* **Пароли**: хранить не пароль, а хеш + salt  
  ⚠️ Важно: для паролей используют специальные функции (`password_hash`) — не просто SHA.
* **Подписи запросов** (HMAC) — защита от подмены.
* **Проверка целостности** файлов/данных (checksum).
* **Кеш-ключи**: md5/sha от параметров запроса.
* **Индексация/хеш-таблицы**: быстрый доступ к данным.
* **Дедупликация**: найти одинаковые файлы по хешу.

#### 4. Пример: пароли в PHP (правильно)
```php
$hash = password_hash($password, PASSWORD_ARGON2ID);

if (password_verify($password, $hash)) {
    // ok
}
```

#### 5. Пример: HMAC подпись
```php
$signature = hash_hmac('sha256', $payload, $secret);
```

</details>

---
### 33. Как используются очереди в PHP?

<details>
<summary>Раскрыть:</summary>

**Очереди** используют, чтобы выполнять задачи **асинхронно** и разгружать основной поток обработки запроса.

Идея:
* веб-запрос должен быть быстрым
* тяжёлые операции отправляем в background

#### 1. Типичные кейсы
* отправка email/SMS
* генерация отчётов, экспорт CSV/PDF
* обработка изображений
* интеграции (webhooks, сторонние API)
* перерасчёты, миграции данных
* обработка событий из других сервисов

#### 2. Архитектура: Producer → Broker → Consumer
##### Producer (продьюсер)
* приложение кладёт сообщение в очередь (job/event)

##### Broker (брокер)
* RabbitMQ / Redis Streams / Kafka / SQS

##### Consumer (воркер)
* отдельный процесс/контейнер читает очередь и выполняет задачу

#### 3. Важные понятия
* **At-least-once delivery** — сообщение может прийти повторно → обработка должна быть идемпотентной.
* **Retry** — повторная попытка при ошибке.
* **DLQ (dead-letter queue)** — очередь для “упавших” сообщений.
* **Visibility timeout / ack** — подтверждение успешной обработки.

#### 4. Как это выглядит в PHP (концептуально)
* Symfony Messenger (AMQP/Redis)
* Laravel Queue (Redis/RabbitMQ/SQS)
* Свой consumer на основе php-amqplib

Пример “идея”:
```php
// producer
$bus->dispatch(new SendEmailMessage($userId));
```

#### 5. Практические советы
* Делать jobs **идемпотентными** (особенно при ретраях).
* Логировать correlation id, trace id.
* Ограничивать память воркеров, перезапускать по лимитам.
* Метрики: время обработки, размер очереди, ошибки.

</details>

---
### 34. Как в общих чертах работает OPcache?

<details>
<summary>Раскрыть:</summary>

**OPcache** — механизм PHP, который кеширует **скомпилированные opcode** в shared memory, чтобы не компилировать PHP-файлы на каждом запросе.

#### 1. Что происходит без OPcache
На каждый запрос:
1) читается файл PHP  
2) парсится код  
3) компилируется в opcode  
4) выполняется

Это дорого по CPU.

#### 2. Что меняет OPcache
##### Первый запрос к файлу
* PHP компилирует файл в opcode
* кладёт opcode в общий кеш (shared memory)

##### Следующие запросы
* opcode берётся из OPcache
* парсинг/компиляция пропускаются
* остаётся только выполнение

#### 3. Почему OPcache важен для веба
* снижает CPU
* уменьшает latency
* особенно заметно на больших фреймворках (Symfony/Laravel)

#### 4. Важные настройки (по смыслу)
* размер памяти OPcache
* количество файлов
* проверка обновления файлов:
  * dev: проверять часто
  * prod: лучше деплой + рестарт/инвалидация, без постоянных проверок

#### 5. Нюансы
* OPcache не кеширует результаты выполнения — только компиляцию.
* Если кеш переполнен, эффективность падает (вытеснения).
* При деплое без проверки изменений нужен рестарт PHP-FPM или сброс кеша.

</details>

---
### 35. Что такое GRASP?

<details>
<summary>Раскрыть:</summary>

**GRASP (General Responsibility Assignment Software Patterns)** — набор принципов/паттернов, которые помогают **правильно распределять ответственность** между объектами.

Это не “классические” GoF паттерны, а скорее гайд по дизайну.

#### 1. Зачем нужен GRASP
* уменьшить связанность
* повысить переиспользуемость
* улучшить читаемость и тестируемость
* избежать “God object”

#### 2. Основные принципы GRASP (что важно знать)
##### 1) Information Expert (Информационный эксперт)
* ответственность даётся тому классу, у которого есть нужные данные  
Пример: `Order` считает total, потому что у него есть позиции.

##### 2) Creator (Создатель)
* объект должен создавать другой объект, если:
  * он агрегирует его
  * содержит/управляет им
  * имеет данные для его создания

##### 3) Controller
* выделение контроллера как точки входа (не UI-контроллер, а use-case контроллер)
* принимает запрос и делегирует домену/сервисам

##### 4) Low Coupling
* минимизировать зависимости между классами

##### 5) High Cohesion
* класс должен быть сфокусирован на своей задаче, без разнородных обязанностей

##### 6) Polymorphism
* использовать полиморфизм вместо `if/switch` по типам (стратегии, интерфейсы)

##### 7) Indirection
* добавлять промежуточные слои (например, сервис/фасад), чтобы снизить связанность

##### 8) Protected Variations
* защищать систему от изменений через стабильные интерфейсы/абстракции

#### 3. Как применить в “middle” объяснении
* “GRASP помогает распределять ответственность: высокое сцепление, низкая связанность, эксперт, контроллер, полиморфизм. Это как набор правил, как правильно строить объектную модель.”

</details>

---
