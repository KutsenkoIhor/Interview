---
### 36. Что такое TDD?

<details>
<summary>Раскрыть:</summary>

**TDD (Test-Driven Development)** — подход к разработке, при котором код пишется **через тесты**.  
Классический цикл: **Red → Green → Refactor**.

#### 1. Цикл TDD (Red → Green → Refactor)
##### 1) Red
* Пишем тест на новую функциональность.
* Запускаем — тест падает (функциональности ещё нет).

##### 2) Green
* Пишем минимальный код, чтобы тест прошёл.
* Главное — сделать тест зелёным, без идеальной архитектуры.

##### 3) Refactor
* Улучшаем код (чистота, структура, SOLID), сохраняя тесты зелёными.

#### 2. Зачем TDD
* помогает уточнить требования (тест = спецификация)
* снижает количество регрессий
* улучшает дизайн (код становится более модульным)
* ускоряет рефакторинг (есть “страховка”)

#### 3. Виды TDD на практике
* “Классический” — с unit-тестами.
* “Outside-in / BDD” — от сценария/контракта (feature) к деталям.
* В реальности часто используют “semi-TDD”: пишут тесты параллельно с кодом.

#### 4. Минусы / ограничения
* требует дисциплины и времени в начале
* сложно применять к legacy-коду без тестов (нужны seams)
* не все вещи удобно тестировать на unit-уровне (интеграции)

#### 5. Как звучит хороший ответ на собесе
* “TDD — это цикл red-green-refactor: сначала тест, потом минимальная реализация, потом рефакторинг. Это повышает качество, ускоряет безопасные изменения и улучшает дизайн, но требует дисциплины и разумного баланса с интеграционными тестами.”

</details>

---
### 37. Чем отличаются модульные тесты от интеграционных?

<details>
<summary>Раскрыть:</summary>

**Unit-тесты (модульные)** проверяют **маленькую единицу** (функцию/класс) в изоляции.  
**Интеграционные** проверяют работу **нескольких компонентов вместе** (например, сервис + БД).

#### 1. Unit (модульные) тесты
* Тестируют один класс/метод.
* Зависимости обычно мокают/стабят.
* Быстрые, запускаются часто.
* Хорошо ловят логические ошибки.

Пример: тест сервиса с mocked repository.

#### 2. Интеграционные тесты
* Поднимают реальные зависимости:
  * БД (MySQL/PostgreSQL)
  * кеш (Redis)
  * файловую систему
  * HTTP-клиент (иногда с test-server)
* Медленнее, сложнее в настройке.
* Ловят ошибки интеграции: миграции, конфиги, SQL, маппинги.

#### 3. Ключевые отличия (коротко)
* **Изоляция**: unit — да, интеграция — нет
* **Скорость**: unit быстрее
* **Достоверность окружения**: интеграция ближе к продакшну
* **Сложность поддержки**: интеграция сложнее

#### 4. Как правильно выстраивать пирамиду тестов
* много unit-тестов (быстро и дёшево)
* меньше интеграционных (важно, но дороже)
* ещё меньше e2e/functional (самые дорогие)

#### 5. Practical tip
* Unit хорошо проверяет бизнес-правила.
* Интеграционные обязательно нужны для:
  * Doctrine mapping
  * реальные SQL запросы
  * транзакции, миграции
  * кеш-инвалидация

</details>

---
### 38. Что такое трейты и как применять их на практике?

<details>
<summary>Раскрыть:</summary>

**Trait** — механизм повторного использования кода в PHP (аналог “миксина”).  
Trait позволяет “вмешать” методы/свойства в класс **без наследования**.

#### 1. Зачем нужны traits
* переиспользование общей логики в разных классах
* альтернатива множественному наследованию (которого в PHP нет)

#### 2. Пример trait
```php
trait TimestampableTrait
{
    private \DateTimeImmutable $createdAt;
    private \DateTimeImmutable $updatedAt;

    public function touch(): void {
        $this->updatedAt = new \DateTimeImmutable();
    }
}
```

Использование:
```php
final class User
{
    use TimestampableTrait;
}
```

#### 3. Где traits полезны
* общие инфраструктурные вещи:
  * timestamps (createdAt/updatedAt)
  * soft-delete
  * логирование
  * небольшие helper-методы
* в Doctrine Entity часто применяют traits для повторяющихся полей

#### 4. Минусы traits (важно на собесе)
* могут ухудшать читаемость (методы “появляются” неявно)
* риск конфликтов имён
* легко превратить в “свалку” логики, нарушая SRP

#### 5. Рекомендации
* trait должен быть маленьким и сфокусированным
* не смешивать бизнес-логику домена в “общие” traits
* для поведения чаще лучше композиция (объекты/сервисы), чем trait

</details>

---
### 39. Как решать конфликты при использовании trait?

<details>
<summary>Раскрыть:</summary>

Конфликт возникает, когда:
* два trait содержат метод с одинаковым именем
* или класс и trait имеют одинаковый метод

PHP даёт инструменты:
* `insteadof` — выбрать, какой метод использовать
* `as` — сделать алиас (переименовать метод)

#### 1. Пример конфликта двух traits
```php
trait A {
    public function foo(): string { return 'A'; }
}

trait B {
    public function foo(): string { return 'B'; }
}
```

Исправление:
```php
final class C
{
    use A, B {
        A::foo insteadof B; // берём foo из A
        B::foo as fooFromB; // алиас для foo из B
    }
}
```

Теперь:
```php
$c = new C();
$c->foo();       // A
$c->fooFromB();  // B
```

#### 2. Конфликт trait vs класс
* метод класса имеет приоритет над методом trait
* метод trait имеет приоритет над методом родительского класса

#### 3. Практические советы
* избегать больших traits
* давать уникальные имена методам
* если конфликтов много — возможно, trait не подходит, лучше композиция

</details>

---
### 40. Как работает автозагрузка классов?

<details>
<summary>Раскрыть:</summary>

**Автозагрузка (autoload)** — механизм, который подгружает PHP-класс **в момент первого обращения** к нему, без ручных `require/include`.

В современном PHP это почти всегда делается через **Composer autoload** и стандарт **PSR-4**.

#### 1. Идея PSR-4
Namespace соответствует директории.

Пример настройки в `composer.json`:
```json
{
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  }
}
```

Это значит:
* `App\Service\UserService` → `src/Service/UserService.php`

#### 2. Как это работает (в общем)
1) В проекте подключён `vendor/autoload.php`.
2) Когда PHP встречает неизвестный класс:
   * вызывается зарегистрированная функция автозагрузки
3) Composer по правилам PSR-4 строит путь к файлу.
4) Если файл найден — подключает его.

#### 3. Почему это важно
* нет ручного require
* стандартизированная структура проекта
* совместимость библиотек

#### 4. Полезные команды Composer
* после изменения автозагрузки:
```bash
composer dump-autoload
```

#### 5. Нюансы
* В больших проектах используют оптимизацию:
  * classmap / authoritative classmap
  * opcache + preload
* Ошибки часто из-за:
  * неправильного namespace
  * неправильного пути/регистра букв
  * забыли `composer dump-autoload`

</details>

---
