---
### 26. Что такое Service Layer и где его стоит применять?

<details>
<summary>Раскрыть:</summary>

**Service Layer** — это слой приложения, который содержит **бизнес-операции (use-cases)** и координирует работу домена и инфраструктуры.  
Его задача — держать “командную” логику в одном месте, а контроллеры/CLI/консоль — максимально тонкими.

#### 1. Что делает Service Layer
* принимает входные данные (DTO/команда)
* валидирует/нормализует (или вызывает валидатор)
* вызывает доменные сущности/доменные сервисы
* работает с репозиториями/транзакциями
* публикует события/интеграции (очередь, email, webhook)
* возвращает результат (DTO/ResponseModel)

#### 2. Что НЕ должен делать Service Layer
* не должен знать про HTTP/Request/Response (это ответственность контроллера)
* не должен содержать SQL/ORM-детали напрямую (лучше репозитории)
* не должен превращаться в “God Service” (слишком много обязанностей)

#### 3. Типичный пример структуры (упрощённо)
* Controller (Infrastructure) → вызывает
* Application Service / UseCase (Service Layer) → использует
* Domain (Entities, ValueObjects, Domain Services)
* Infrastructure (Repositories, HTTP clients, Cache, Queue)

#### 4. Пример (идея)
```php
final class CreateUserService
{
    public function __construct(
        private UserRepositoryInterface $users,
        private PasswordHasherInterface $hasher
    ) {}

    public function handle(CreateUserCommand $cmd): UserDto
    {
        $user = User::register($cmd->email, $this->hasher->hash($cmd->password));
        $this->users->save($user);

        return UserDto::fromEntity($user);
    }
}
```

#### 5. Где применять
* когда есть **несколько точек входа** (HTTP, CLI, cron, message bus) к одной логике
* когда бизнес-операции сложные и не должны жить в контроллере
* когда нужен чистый DDD/слоистая архитектура

#### 6. Плюсы
* тонкие контроллеры
* тестируемость (unit-тесты сервисов)
* переиспользуемость use-case
* лучшее разделение ответственности

#### 7. Минусы/ошибки
* можно “раздуть” слой, если нет границ
* чрезмерная абстракция в маленьких проектах (YAGNI)

</details>

---
### 27. Singleton: как устроен и почему является антипаттерном.

<details>
<summary>Раскрыть:</summary>

**Singleton** — паттерн, который гарантирует, что у класса будет **только один экземпляр** и предоставляет глобальную точку доступа к нему.

#### 1. Как устроен (классический вариант)
```php
final class Config
{
    private static ?self $instance = null;

    private function __construct() {}
    private function __clone() {}
    public function __wakeup() { throw new \RuntimeException('No'); }

    public static function getInstance(): self
    {
        return self::$instance ??= new self();
    }
}
```

#### 2. Почему в приложениях его часто считают антипаттерном
* **Скрытые зависимости**: класс в любом месте кода может дернуть Singleton, DI не видно.
* **Глобальное состояние**: сложно контролировать и тестировать.
* **Сложные тесты**: трудно подменять реализацию (моки), состояние “течёт” между тестами.
* **Нарушение SRP/DIP**: класс сам управляет своим жизненным циклом и доступом.
* **Проблемы с параллелизмом/конкурентностью** в некоторых сценариях.

#### 3. Чем заменить в современных проектах
* **DI container** (Symfony Container) — один shared-сервис = “singleton по контейнеру”, но без глобального доступа
* **Интерфейсы** + конфигурации
* **Factory / Provider** для управляемого создания
* **Static config** — только там, где действительно безопасно и нужно

#### 4. Когда Singleton допустим
* очень ограниченно: глобальные константные данные, которые не меняются
* внутренние механизмы языка/расширений (не бизнес-уровень)
Но в большинстве бизнес-приложений лучше DI.

</details>

---
### 28. Что такое идемпотентность?

<details>
<summary>Раскрыть:</summary>

**Идемпотентность** — свойство операции, при котором **повторное выполнение** (один или много раз) приводит к **тому же состоянию**, что и одно выполнение.

#### 1. Идемпотентность в HTTP
Идемпотентные методы:
* **GET** — не меняет состояние
* **PUT** — устанавливает состояние ресурса
* **DELETE** — удаление (повторный delete не меняет итог)
* **HEAD** — как GET без тела

Неидемпотентный:
* **POST** — обычно создаёт новый ресурс каждый раз

#### 2. Пример
```http
PUT /users/1
{ "name": "Ihor" }
```
Если отправить 5 раз — пользователь всё равно будет “Ihor”.

А вот:
```http
POST /users
{ "name": "Ihor" }
```
5 раз → может создать 5 пользователей.

#### 3. Идемпотентность в бизнес-операциях
Иногда нужно сделать POST идемпотентным:
* платежи
* создание заявок
* отправка уведомлений

Обычно решают через **Idempotency-Key**:
* клиент присылает уникальный ключ
* сервер хранит результат по ключу и возвращает тот же ответ при повторе

#### 4. Зачем это важно
* сеть ненадёжна, ретраи неизбежны
* балансировщики/клиенты могут повторять запрос
* идемпотентность предотвращает двойные платежи/создания

</details>

---
### 29. Жизненный цикл HTTP-запроса.

<details>
<summary>Раскрыть:</summary>

Это “путь” запроса от браузера/клиента до приложения и обратно.

#### 1. Клиент формирует запрос
* URL, метод, заголовки, тело
* cookies, auth headers

#### 2. DNS
* домен → IP (кеш браузера/ОС/резолвер)

#### 3. Соединение
* TCP handshake
* TLS handshake (если HTTPS)
* возможен HTTP/2 или HTTP/3

#### 4. Запрос попадает на web-server
* nginx / apache принимает соединение
* проверка правил (location, rewrite)
* статика отдаётся сразу или проксируется дальше

#### 5. Передача в приложение
Для PHP обычно:
* nginx → **PHP-FPM** (FastCGI) → PHP runtime → framework (Symfony/Laravel)

#### 6. Обработка в приложении
* Routing → Controller
* Middleware/Kernel events
* Service Layer / UseCase
* DB/Cache/HTTP calls
* формирование ответа

#### 7. Ответ клиенту
* статус (200/201/400/500)
* headers (cache-control, content-type, set-cookie)
* body (HTML/JSON)

#### 8. На стороне клиента
* браузер рендерит HTML/CSS/JS или клиент обрабатывает JSON
* кеширование и повторные запросы (ETag, If-Modified-Since)

#### 9. Где чаще всего “узкие места”
* DB (запросы, индексы)
* внешние API
* сериализация больших ответов
* отсутствие кеша / неправильно настроенный кеш
* медленный TLS/сеть при большом трафике

</details>

---
### 30. Что такое куча и стек?

<details>
<summary>Раскрыть:</summary>

Это две базовые области памяти, которые используются программой по-разному.

#### 1. Стек (Stack)
Стек — это область памяти для:
* локальных переменных функций
* параметров вызова
* адресов возврата
* кадров стека (stack frames)

Особенности:
* работает по принципу **LIFO** (последний вошёл — первый вышел)
* очень быстрый (выделение/освобождение)
* ограничен по размеру → возможен **stack overflow** при глубокой рекурсии

Пример: глубокая рекурсия в PHP может привести к ошибкам/лимитам.

#### 2. Куча (Heap)
Куча — это область памяти для:
* объектов
* больших структур данных
* данных с “непредсказуемым” временем жизни

Особенности:
* управление памятью сложнее
* освобождение происходит через сборщик мусора (GC) / reference counting (в PHP)

#### 3. Как это связано с PHP
* Переменные в PHP — это zval структуры, а объекты обычно живут в куче.
* PHP использует **reference counting + cycle collector** (GC) для циклических ссылок.
* Стек используется для вызовов функций, но сам PHP-уровень скрывает детали.

#### 4. Важные практические последствия
* бесконтрольная рекурсия → проблемы со стеком
* циклические ссылки в объектах → может потребоваться GC
* большие массивы/объекты → давление на кучу и память

</details>

---
