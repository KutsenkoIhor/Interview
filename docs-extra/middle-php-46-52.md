---
### 46. Как импортировать 50GB XML в базу данных?

<details>
<summary>Раскрыть:</summary>

Импорт 50GB XML нельзя делать “в лоб” через `simplexml_load_file()` — упадёшь по памяти/времени. Нужен **стриминг + батчи + контроль транзакций**.

#### 1. Общая стратегия
**Цель:** читать XML потоково, доставать нужные элементы, писать в БД пакетами.

Основные принципы:
* **Streaming parser**: `XMLReader` (pull-парсер) или SAX.
* **Chunk/batch**: вставки пачками (например, 500–5000 строк).
* **Транзакции**: коммитить по пачкам, не держать одну транзакцию на 50GB.
* **Минимум индексов во время импорта**: по возможности отключить/снять индексы и создать после.
* **Staging table**: сначала в “сырую” таблицу, потом нормализация/merge.

#### 2. Вариант А: XMLReader + батч-вставки (типовой)
```php
$reader = new XMLReader();
$reader->open($file);

$batch = [];
$batchSize = 1000;

while ($reader->read()) {
    if ($reader->nodeType === XMLReader::ELEMENT && $reader->name === 'item') {
        $xml = $reader->readOuterXML();

        // Парсим только "один item", не весь файл
        $item = simplexml_load_string($xml);

        $batch[] = [
            'id' => (string)$item->id,
            'name' => (string)$item->name,
            // ...
        ];

        if (count($batch) >= $batchSize) {
            insertBatch($batch); // prepared statements / bulk insert
            $batch = [];
        }
    }
}

if ($batch) {
    insertBatch($batch);
}

$reader->close();
```

#### 3. Вариант B: “Преобразовать в CSV → LOAD DATA”
Если XML однотипный, иногда выгодно:
1) потоково распарсить XML и записать в CSV/TSV,
2) затем загрузить в MySQL/PostgreSQL через bulk-loader (`LOAD DATA INFILE` / `COPY`).

Плюс:
* bulk loader обычно быстрее, чем INSERT.

Минус:
* доп. шаг и место на диске.

#### 4. Производительность: что важно сделать
* **Подготовленные запросы** (PDO) и множественные вставки:
  * `INSERT INTO t (...) VALUES (...), (...), (...)`
* **Отключить автокоммит** и делать commit пачками.
* **Временно отключить/отложить индексы** (если возможно).
* **Увеличить буферы/лимиты** (в рамках разумного): innodb_buffer_pool_size, max_allowed_packet.
* **Параллелизм**: если XML можно безопасно разделить (по файлам/диапазонам) — несколько воркеров.

#### 5. Надёжность: контроль ошибок и возобновление
* вести **checkpoint**: позиция/последний обработанный id
* логировать “плохие” записи отдельно (dead-letter file)
* делать import idempotent (upsert / ignore duplicates)

#### 6. Итоговая “правильная” архитектура
* CLI-команда (не HTTP)
* streaming parser
* batch inserts
* staging tables
* метрики/логирование/чекпоинты

</details>

---
### 47. Почему после PHP 5 сразу вышел PHP 7, куда делся PHP 6?

<details>
<summary>Раскрыть:</summary>

“PHP 6” как полноценный релиз **не вышел**, поэтому следующая крупная версия после 5 стала 7.

#### 1. Что планировалось в PHP 6
* Основная большая цель: **полная поддержка Unicode** на уровне ядра/строк.
* Разработка шла отдельной веткой, появлялись патчи и экспериментальные изменения.

#### 2. Почему PHP 6 “не случился”
* Unicode-подход оказался слишком сложным и конфликтным для экосистемы.
* Было много несовместимостей и проблем производительности.
* В итоге ветку фактически “заморозили”, а часть полезных идей/фич постепенно попала в PHP 5.3+.

#### 3. Почему назвали следующую версию PHP 7
* Чтобы не путать людей с существующей “веткой PHP 6” (которую многие видели/упоминали).
* Большой набор изменений производительности/ядра (Zend Engine), поэтому было логично поднять major.
* Итог: “6” пропустили, чтобы избежать путаницы и подчеркнуть новый этап развития.

</details>

---
### 48. Есть ли разница между self и $this в PHP?

<details>
<summary>Раскрыть:</summary>

Да, разница принципиальная.

#### 1. `$this`
* это **текущий объект (экземпляр класса)**.
* доступен **только в нестатическом контексте** (в обычных методах).
* используется для обращения к:
  * свойствам объекта: `$this->prop`
  * методам объекта: `$this->method()`

```php
class A {
    public function foo(): void {
        $this->bar();
    }
    private function bar(): void {}
}
```

#### 2. `self`
* это ссылка на **текущий класс**, в котором написан код.
* используется в статическом контексте:
  * `self::CONST`
  * `self::staticMethod()`

```php
class A {
    public const NAME = 'A';
    public static function name(): string {
        return self::NAME;
    }
}
```

#### 3. Важный нюанс: `self::` vs `static::` (Late Static Binding)
* `self::` привязан к **классу, где объявлен метод**.
* `static::` учитывает **класс, на котором вызвали метод** (позднее статическое связывание).

```php
class A {
    public static function who(): string { return self::class; }
    public static function whoLate(): string { return static::class; }
}
class B extends A {}

echo B::who();     // A
echo B::whoLate(); // B
```

#### 4. Как отвечать на собесе (коротко)
* `$this` — объект, только instance.
* `self` — текущий класс (compile-time binding).
* `static` — late static binding (runtime).

</details>

---
### 49. Что такое PuTTY?

<details>
<summary>Раскрыть:</summary>

**PuTTY** — популярный клиент для удалённых подключений, прежде всего:
* **SSH**
* также исторически поддерживал Telnet, rlogin, serial (в зависимости от сборки)

Чаще всего PuTTY используют (особенно на Windows):
* подключиться по SSH к серверу
* работать в терминале
* хранить профили подключений

#### 1. Что обычно входит в “набор PuTTY”
* **PuTTY** — SSH-клиент (терминал)
* **PuTTYgen** — генератор ключей (RSA/Ed25519 в новых версиях)
* **Pageant** — SSH-agent (хранит ключи в памяти)
* **Plink** — консольный клиент для скриптов/CI

#### 2. Чем похож/отличается от OpenSSH
* По сути решает ту же задачу (SSH).
* На Linux/macOS обычно используют `ssh` из OpenSSH.
* PuTTY удобен интерфейсом и исторически был стандартом в Windows-среде.

</details>

---
### 50. Как запускать важный PHP-файл каждые 20 секунд?

<details>
<summary>Раскрыть:</summary>

Классический cron работает с точностью **в 1 минуту**, поэтому “каждые 20 секунд” делается обходными способами.

#### Вариант 1: cron + sleep (3 запуска в минуту)
В crontab:
```cron
* * * * * /usr/bin/php /app/job.php
* * * * * sleep 20; /usr/bin/php /app/job.php
* * * * * sleep 40; /usr/bin/php /app/job.php
```
Плюс:
* просто и быстро
Минус:
* нужно следить за временем выполнения (чтобы не налезали процессы)

#### Вариант 2: бесконечный worker под supervisor/systemd
Скрипт:
```bash
while true; do
  /usr/bin/php /app/job.php
  sleep 20
done
```
Запускать как сервис (systemd) или под supervisor.
Плюс:
* лучше контроль рестартов/логов
Минус:
* нужно правильно настроить monitoring/restart policy

#### Вариант 3: systemd timer (если нужен более “родной” подход)
Systemd timers могут быть гибче cron (но зависит от дистрибутива и настройки).

#### Важные нюансы (обязательно на собесе)
* защита от параллельных запусков:
  * file lock (`flock`)
  * redis lock
  * “unique job” в очереди
* логирование и алерты
* ограничения по памяти/времени

</details>

---
### 51. Как расшифровать права 644 для файла в Linux?

<details>
<summary>Раскрыть:</summary>

Права `644` — это запись в восьмеричной системе (octal) для:
* владельца (user)
* группы (group)
* остальных (others)

#### 1. Раскладка цифр
`6 4 4`

Каждая цифра — сумма:
* `4` — read (r)
* `2` — write (w)
* `1` — execute (x)

#### 2. Расшифровка 6
`6 = 4 + 2` → `rw-`
* владелец: читать и писать

#### 3. Расшифровка 4
`4 = 4` → `r--`
* группа: только читать
* остальные: только читать

#### 4. Итог в виде rwx
`644` → `rw-r--r--`

То есть:
* owner: rw-
* group: r--
* others: r--

#### 5. Команда для установки
```bash
chmod 644 file.txt
```

</details>

---
### 52. Что такое Opcode?

<details>
<summary>Раскрыть:</summary>

**Opcode** — это промежуточный “байткод” (инструкции), в который PHP компилирует исходный код перед выполнением.

#### 1. Как выполняется PHP-код (упрощённо)
1) PHP читает файл
2) парсит и строит AST
3) компилирует в **opcodes**
4) Zend VM выполняет эти opcodes

#### 2. Почему это важно
* На каждый запрос компиляция в opcode — это CPU-затраты.
* **OPcache** кеширует opcodes в общей памяти, поэтому:
  * компиляция делается один раз
  * дальше — берём opcode из кеша и выполняем

#### 3. Opcode ≠ машинный код
* opcode — инструкции виртуальной машины (Zend VM)
* машинный код — это уже то, что выполняет процессор
* JIT (PHP 8) может компилировать часть opcodes в машинный код для ускорения CPU-bound задач

#### 4. Как звучит хороший ответ
* “Opcode — это байткод Zend VM. PHP компилирует скрипт в opcode и исполняет. OPcache кеширует opcode, чтобы не компилировать на каждом запросе.”

</details>

---
