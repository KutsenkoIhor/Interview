# Database / Redis — вопросы 1–10

---
### 1. Какие структуры данных поддерживает Redis?

<details>
<summary>Раскрыть:</summary>

Redis — это in-memory key-value хранилище, где значение у ключа может быть **разных типов** (структур данных).

#### 1) Основные структуры данных
* **String** — строка/байты/число  
  * инкременты/декременты: `INCR`, `DECR`
* **Hash** — “мини-объект” (поле → значение)  
  * удобно хранить сущности: `HSET user:1 name Ihor city Warsaw`
* **List** — список (двухсторонняя очередь)  
  * очереди: `LPUSH/RPUSH`, `LPOP/RPOP`, блокирующие `BLPOP`
* **Set** — множество уникальных значений  
  * `SADD`, `SREM`, `SISMEMBER`
* **Sorted Set (ZSET)** — множество с сортировкой по score  
  * рейтинги, топы: `ZADD`, `ZRANGE`, `ZREVRANGE`
* **Stream** — поток сообщений  
  * очереди событий, consumer groups: `XADD`, `XREADGROUP`
* **Bitmap / Bitfield** — работа с битами  
  * флаги, статистика, компактные метрики
* **HyperLogLog** — приблизительный подсчёт уникальных  
  * `PFADD`, `PFCOUNT`
* **Geo** — геоиндексация  
  * `GEOADD`, `GEORADIUS`
* **Pub/Sub** — публикация/подписка (не структура, но важная возможность)

#### 2) Почему это важно
* можно выполнять операции **атомарно** на стороне Redis
* не надо тащить весь объект в приложение, чтобы “подправить одно поле”
* удобно для кеша, rate-limit, счётчиков, очередей, лидербордов

</details>

---
### 2. Что подразумевается под понятием «триггер» в SQL?

<details>
<summary>Раскрыть:</summary>

**Триггер** — это объект БД, который автоматически выполняет код (обычно SQL/процедуру) **при событии** в таблице:
* `INSERT`
* `UPDATE`
* `DELETE`

#### 1) Виды триггеров
* **BEFORE** — до изменения данных (можно валидировать/модифицировать)
* **AFTER** — после изменения (логирование, аудит, каскадная логика)
* (в некоторых СУБД есть `INSTEAD OF` для views)

#### 2) Пример (идея)
```sql
CREATE TRIGGER users_before_update
BEFORE UPDATE ON users
FOR EACH ROW
SET NEW.updated_at = NOW();
```

#### 3) Когда триггеры полезны
* аудит/логирование изменений (audit log)
* автоматическое заполнение полей (`updated_at`)
* поддержка денормализации/счётчиков (осторожно)
* сложные правила целостности, когда не хватает FK/constraints

#### 4) Недостатки (важно на собесе)
* скрытая логика (труднее понимать систему)
* сложнее тестировать и дебажить
* возможны проблемы производительности и блокировок
* риск рекурсий/цепочек триггеров

**Правило:** триггеры использовать осознанно, лучше — минимально и прозрачно.

</details>

---
### 3. Какая разница между реляционными и нереляционными СУБД?

<details>
<summary>Раскрыть:</summary>

#### 1) Реляционные (SQL) СУБД
* данные в таблицах (строки/колонки)
* связи через ключи (PK/FK), JOIN
* строгая схема (schema)
* мощные транзакции (ACID часто “из коробки”)

Примеры: MySQL, PostgreSQL, SQL Server, Oracle.

#### 2) Нереляционные (NoSQL)
Общее: уход от строгой табличной модели, разные типы хранения:
* документные
* key-value
* колонночные
* графовые
* time-series

Часто:
* проще горизонтально масштабировать
* гибче схема (schema-less / schema-on-read)
* иногда слабее транзакционность (но это зависит от конкретной СУБД)

#### 3) Практический выбор
* сложные связи, отчёты, транзакции → чаще SQL
* огромные объёмы, специфичные модели (документы/графы/таймсерии) → NoSQL
* в реальности часто гибрид: SQL как основа + Redis/Elastic/ClickHouse по задачам

</details>

---
### 4. Какие NoSQL СУБД знаете?

<details>
<summary>Раскрыть:</summary>

#### 1) Key-Value
* **Redis** — кеш, структуры данных, streams, locks
* **Memcached** — простой кеш key-value

#### 2) Документные
* **MongoDB** — JSON-подобные документы, гибкая схема
* **CouchDB** — документы + репликации

#### 3) Колонночные (wide-column)
* **Cassandra** — распределённое хранение, высокая запись
* **HBase** — поверх Hadoop

#### 4) Графовые
* **Neo4j** — графы, связи, traversal
* **JanusGraph** — распределённые графы

#### 5) Search / аналитика (часто относят к NoSQL экосистеме)
* **Elasticsearch / OpenSearch** — поиск, агрегации
* **ClickHouse** — аналитическая колоночная БД (OLAP)

#### 6) Time-series
* **InfluxDB**
* **TimescaleDB** (расширение PostgreSQL, но часто упоминают в one-liner списках)

На собеседовании важно: не просто перечислить, а сказать “где применял/для чего”.

</details>

---
### 5. Что такое ACID Compliance?

<details>
<summary>Раскрыть:</summary>

**ACID** — набор свойств транзакций, которые гарантируют корректность данных.

#### A — Atomicity (Атомарность)
* либо выполняется всё, либо ничего  
  пример: списать деньги и записать лог — вместе, иначе откат

#### C — Consistency (Согласованность)
* транзакция переводит БД из одного корректного состояния в другое  
  соблюдаются constraints (PK/FK/unique/check)

#### I — Isolation (Изоляция)
* параллельные транзакции не “мешают” друг другу сверх выбранного уровня  
  (READ COMMITTED / REPEATABLE READ / SERIALIZABLE)

#### D — Durability (Надёжность)
* после commit данные не теряются при сбоях (журналы, fsync, WAL)

#### Практический момент
* “ACID compliance” зависит от СУБД и режима (движок InnoDB vs MyISAM, настройки fsync, репликации).
* В распределённых системах часто делают компромисс (CAP), но многие современные БД всё равно дают сильные гарантии.

</details>

---
### 6. Что такое Views? Какие преимущества и недостатки?

<details>
<summary>Раскрыть:</summary>

**View (представление)** — это сохранённый SQL-запрос, который выглядит как таблица.

#### 1) Типы
* **Обычные (virtual) views** — не хранят данные, каждый раз выполняют запрос
* **Materialized views** (в некоторых СУБД) — хранят результат, требуют refresh

#### 2) Преимущества
* упрощают сложные запросы (скрывают JOIN/агрегации)
* безопасность: можно дать доступ к view вместо базовых таблиц
* стабильный контракт для отчётов/BI
* уменьшают дублирование SQL в приложении

#### 3) Недостатки
* могут скрывать тяжёлые запросы → неожиданная нагрузка
* оптимизатор не всегда идеально “раскрывает” view
* ограничения на update/insert (не все views обновляемые)
* риск “спагетти” из вложенных view

#### 4) Когда использовать
* read-only отчётность
* ограничение доступа
* стандартизация часто используемых выборок

</details>

---
### 7. Что такое уровни изоляции транзакций?

<details>
<summary>Раскрыть:</summary>

Уровень изоляции определяет, **что одна транзакция может увидеть** из изменений другой при параллельной работе.

#### 1) Проблемы параллельности
* **Dirty read** — чтение незакоммиченных данных
* **Non-repeatable read** — повторное чтение даёт другой результат
* **Phantom read** — новые строки “появляются” при повторном запросе

#### 2) Стандартные уровни
##### READ UNCOMMITTED
* допускает dirty read  
* почти не используют в проде

##### READ COMMITTED
* нет dirty read  
* возможны non-repeatable и phantom  
* часто дефолт в PostgreSQL

##### REPEATABLE READ
* повторное чтение одинаковых строк стабильно  
* phantom зависит от СУБД/механизма (MVCC/locking)  
* дефолт InnoDB в MySQL обычно REPEATABLE READ

##### SERIALIZABLE
* максимально строго: как будто транзакции идут последовательно  
* меньше параллелизма, больше блокировок/конфликтов

#### 3) Практика
* Для обычных CRUD — READ COMMITTED/REPEATABLE READ достаточно.
* Для денег/инвентаря — часто нужен строгий контроль (locks/serializable/optimistic locking).
* Важно знать механику конкретной СУБД (MVCC в Postgres, InnoDB).

</details>

---
### 8. Что такое concurrent query?

<details>
<summary>Раскрыть:</summary>

**Concurrent query** — это ситуация, когда **несколько запросов выполняются одновременно** (параллельно) и потенциально конкурируют за ресурсы:
* CPU/IO
* блокировки строк/таблиц
* индексы
* буферы/кэш

#### 1) Почему это важно
При высокой конкуренции возникают:
* lock wait / deadlocks
* рост времени ответа
* “пилы” по нагрузке из-за contention

#### 2) Типовые примеры конкуренции
* два UPDATE одной и той же строки → один ждёт блокировку
* массовые INSERT + тяжелые SELECT → IO contention
* ALTER TABLE в неподходящий момент → блокировки (зависит от СУБД)

#### 3) Как уменьшают проблемы
* правильные индексы (быстрее запрос → меньше времени держит lock)
* короткие транзакции (не держать lock долго)
* выбор правильного уровня изоляции
* оптимистичные блокировки (версия/updated_at)
* разделение нагрузки (read replicas, шардинг)
* очередь/буферизация записи (batch)

#### 4) Хорошая формулировка
* “Concurrent queries — это параллельные запросы, которые могут конфликтовать по блокировкам и ресурсам. Основная задача — минимизировать время владения locks и правильно индексировать.”

</details>

---
### 9. Что такое кластерные индексы?

<details>
<summary>Раскрыть:</summary>

**Кластерный индекс (clustered index)** — это индекс, который определяет **физический порядок хранения строк** в таблице.

#### 1) Ключевая идея
* данные хранятся на диске/страницах в порядке clustered key
* поэтому поиск по clustered key очень быстрый (меньше прыжков по страницам)

#### 2) Особенности
* в таблице обычно **может быть только один** clustered index (потому что физический порядок один)
* остальные индексы (non-clustered) обычно содержат ссылку на clustered key

#### 3) InnoDB (MySQL) как пример
* В InnoDB **таблица “кластеризована” по PRIMARY KEY**.
* Если нет PK — InnoDB создаёт скрытый кластерный ключ.
* Secondary indexes хранят: (secondary key + primary key), чтобы найти строку.

Практический вывод:
* выбор PK влияет на размер вторичных индексов и локальность данных
* последовательные PK (AUTO_INCREMENT) обычно хорошо для вставок
* случайные PK (UUID) могут фрагментировать и замедлять вставки (если не использовать оптимизации)

#### 4) В SQL Server
* clustered index можно выбрать отдельно (не обязательно PK), но концепция та же.

</details>

---
### 10. Как построить социальную сеть?

<details>
<summary>Раскрыть:</summary>

На собеседовании этот вопрос чаще про **архитектуру хранения и масштабирование**: схема БД, индексы, лента, кеш, очереди.

#### 1) Минимальная модель данных (SQL)
##### Users
* `users(id, email, name, created_at, ...)`

##### Relations (подписки)
* `follows(follower_id, followee_id, created_at)`
  * PK/unique: `(follower_id, followee_id)`
  * индексы:
    * `(follower_id)` — кого я читаю
    * `(followee_id)` — кто читает меня

##### Posts
* `posts(id, user_id, body, created_at, ...)`
  * индекс: `(user_id, created_at DESC)`

##### Likes / Comments
* `likes(user_id, post_id, created_at)` (unique user+post)
* `comments(id, post_id, user_id, body, created_at)`

#### 2) Главная сложность — лента (feed)
Есть две базовые стратегии:

##### A) Fan-out on read (строим ленту при чтении)
* при запросе ленты:
  * берём список followee
  * берём последние посты каждого
  * сливаем/сортируем
Плюсы:
* проще запись
Минусы:
* тяжело при большом количестве подписок

##### B) Fan-out on write (готовим ленту при записи)
* когда пользователь публикует пост:
  * пушим его в “inbox”/feed таблицу подписчиков
  * делаем это асинхронно через очередь
Плюсы:
* быстро читать ленту
Минусы:
* тяжёлая запись для больших аккаунтов (миллионы подписчиков)

На практике часто гибрид:
* обычные аккаунты — fan-out on write
* “звёзды” — отдельная логика (fan-out on read или кешированная лента)

#### 3) Кеш и очереди (обязательно)
* Redis:
  * кеш профилей/счётчиков
  * кеш ленты/страниц
  * rate limit
* Очереди (RabbitMQ/Kafka/Redis Streams):
  * построение ленты
  * уведомления
  * обработка медиа

#### 4) Масштабирование БД
* реплики для чтения (read replicas)
* шардинг по user_id (если нужно)
* отдельные хранилища:
  * поиск → Elasticsearch
  * аналитика → ClickHouse
  * файлы/медиа → S3/MinIO + CDN

#### 5) Индексы и ограничения
* уникальность follow/like
* правильные композитные индексы по (user_id, created_at)
* мягкое удаление (soft delete) или отдельные флаги
* защита от N+1 запросов на уровне API

#### 6) Как отвечать “middle”
* “Схема: users, follows, posts, likes, comments. Самое сложное — feed: fan-out on read vs write. Для производительности: индексы, кеш Redis, очереди для асинхронных задач, реплики/шардинг при росте.”

</details>

---
